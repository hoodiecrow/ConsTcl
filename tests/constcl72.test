
package require tcltest
namespace import -force tcltest::*
source ../constcl.tcl

test eval-12.0 {try eval-ing a procedure call} -body {
  pew "(* 5 20)"
} -output "100\n"

test eval-12.1 {try triggering a check} -body {
    ::constcl::invoke ${::#NIL} [list ${::#NIL} ${::#NIL}]
} -returnCodes error -result "PROCEDURE expected\n(() val ...)"

test eval-13.3 {expand let macro} -body {
    set x [parse "(let ((x 10)) (* x x))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
    set x [parse "(let ((x 10) (y 5)) (* x y))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
    set x [parse "(let ((x 10) (y 5)) (define z 7) (* x y z))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
} -output "((lambda (x) (* x x)) 10)\n((lambda (x y) (* x y)) 10 5)\n((lambda (x y) (define z 7) (* x y z)) 10 5)\n"

test eval-13.4 {run let macro} -body {
    pew "(let ((x 10)) (* x x))"
    pew "(let ((x 10) (y 5)) (* x y))"
    pew "(let ((x 10) (y 5) (z 7)) (+ 2 3) (* x y z))"
} -output "100\n50\n350\n"

test eval-13.5 {expand named let macro} -body {
    set x [parse {(let loop ((lst lst) (result '()))
    (if (null? lst)
        (reverse result)
        (let ((item (car lst)))
          (loop (cdr lst)
                (if (fn item) result (cons item result))))))}]
    set x [::constcl::rewrite-named-let $x ::constcl::global_env]
    w $x
} -output "(let ((loop #f) (lst lst) (result (quote ()))) (set! loop (lambda (lst result) (if (null? lst) (reverse result) (let ((item (car lst))) (loop (cdr lst) (if (fn item) result (cons item result))))))) (loop lst result))\n"

test eval-13.7 {expand let macro} -body {
    set x [parse "(let ((vec #(a b c)) (k 1)) (list vec k))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
} -output "((lambda (vec k) (list vec k)) #(a b c) 1)\n"

test eval-13.8 {run let macro} -body {
    pew "(let ((vec '#(a b c)) (k 1)) (list vec k))"
} -output "(#(a b c) 1)\n"

test eval-13.9 {trigger error in let macro} -body {
    pew "(let ((a 0) (a 1)) (* a a))"
} -returnCodes error -result "'a' occurs more than once"


cleanupTests
return
