package require tcltest
source constcl.tcl


::tcltest::test read-1.0 {try reading quoted symbol} -body {
    pp "'foo"
} -output "(quote foo)\n"

::tcltest::test read-1.1 {try reading a list} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(a (b))"
        set obj [read]
        [caadr $obj] name
    }
} -result "b"

::tcltest::test read-1.2 {try reading a list} -body {
    pp "(a)"
} -output "(a)\n"

::tcltest::test read-1.3 {try reading a list} -body {
    pp "(a b)"
} -output "(a b)\n"

::tcltest::test read-1.4 {try reading a list} -body {
    pp "(a b c)"
} -output "(a b c)\n"

::tcltest::test read-1.5 {try reading a list} -body {
    pp "(a b c d)"
} -output "(a b c d)\n"

::tcltest::test read-1.6 {try reading a list} -body {
    pp "(a b c d e)"
} -output "(a b c d e)\n"

::tcltest::test read-1.7 {try reading a list} -body {
    pp "(a (b) )"
} -output "(a (b))\n"

::tcltest::test read-1.8 {try reading a list} -body {
    pp "(a (b))"
} -output "(a (b))\n"


::tcltest::test read-2.0 {try reading a number} {
    set ::inputbuffer "99.99"
    set obj [::constcl::read]
    $obj value
} "99.99"

::tcltest::test read-2.1 {try reading a number} {
    set ::inputbuffer "     99.99"
    set obj [::constcl::read]
    $obj value
} "99.99"

::tcltest::test read-2.2 {try reading a number} {
    set ::inputbuffer "     9"
    set obj [::constcl::read]
    $obj value
} "9"

::tcltest::test read-2.3 {try reading a number} {
    set ::inputbuffer "     +9"
    set obj [::constcl::read]
    $obj value
} "+9"

::tcltest::test read-2.4 {try reading a number} {
    set ::inputbuffer "     -9"
    set obj [::constcl::read]
    $obj value
} "-9"

::tcltest::test read-2.5 {try reading a number} {
    set ::inputbuffer "     - "
    set obj [::constcl::read]
    $obj name
} "-"

::tcltest::test read-2.6 {try reading a number} {
    set ::inputbuffer "     + "
    set obj [::constcl::read]
    $obj name
} "+"



::tcltest::test read-3.0 {try reading a character} {
    set ::inputbuffer {#\A}
    set obj [::constcl::read]
    $obj char
} "A"

::tcltest::test read-3.1 {try reading a character} {
    set ::inputbuffer "#\\space"
    set obj [::constcl::read]
    $obj char
} " "

::tcltest::test read-3.2 {try reading a character} {
    set ::inputbuffer "#\\newline"
    set obj [::constcl::read]
    $obj char
} "\n"

::tcltest::test read-3.3 {try reading a character} -body {
    set ::inputbuffer "#\\foobar"
    set obj [::constcl::read]
    $obj char
} -returnCodes error -result "Invalid character constant #\\foobar"



::tcltest::test read-4.0 {try reading a string} {
    set ::inputbuffer {"foo bar"}
    set obj [::constcl::read]
    $obj value
} "foo bar"

::tcltest::test read-4.1 {try reading a string} {
    set ::inputbuffer {"\"foo\" \\ bar"}
    set obj [::constcl::read]
    $obj value
} {"foo" \ bar}



::tcltest::test read-5.0 {try reading an identifier} {
    set ::inputbuffer "foo"
    set obj [::constcl::read]
    $obj name
} "foo"

::tcltest::test read-5.1 {try reading an identifier} -body {
    set ::inputbuffer "+foo"
    set obj [::constcl::read-identifier]
    $obj name
} -returnCodes error -result "Identifier expected (+foo)"

::tcltest::test read-5.2 {try reading an identifier} -body {
    set ::inputbuffer "let"
    set obj [::constcl::read]
    ::constcl::varcheck [$obj name]
} -returnCodes error -result "Macro name can't be used as a variable: let"


::tcltest::test read-6.0 {try reading an improper list} -body {
    pp "(a . b)"
} -output "(a . b)\n"

::tcltest::test read-6.1 {try reading an improper list} -body {
    pp "(a b . c)"
} -output "(a b . c)\n"


::tcltest::test eval-1.0 {expand and macro} -body {
    pxp "(and)"
    pxp "(and #t)"
    pxp "(and (> 3 2))"
    pxp "(and (> 3 2) (= 7 8))"
} -output "(begin #t)\n(begin #t)\n(begin (> 3 2))\n(if (> 3 2) (if (= 7 8) (= 7 8) #f) #f)\n"

::tcltest::test eval-1.1 {run and macro} -body {
    pep "(and)"
    pep "(and #t)"
    pep "(and (> 3 2))"
    pep "(and (> 3 2) (= 7 8))"
} -output "#t\n#t\n#t\n#f\n"

::tcltest::test eval-1.2 {expand or macro} -body {
    pxp "(or)"
    pxp "(or #f)"
    pxp "(or (> 3 2))"
    pxp "(or (> 3 2) (= 7 8))"
} -output "(begin #f)\n(begin #f)\n(begin (> 3 2))\n(let ((x (> 3 2))) (if x x (let ((x (= 7 8))) (if x x #f))))\n"

::tcltest::test eval-1.3 {expand let macro} -body {
    pxp "(let ((x 10)) (* x x))"
    pxp "(let ((x 10) (y 5)) (* x y))"
} -output "((lambda (x) (begin (* x x))) 10)\n((lambda (x y) (begin (* x y))) 10 5)\n"

::tcltest::test eval-1.4 {expand named let macro} -body {
    pxp {(let loop ((lst lst) (result '()))
    (if (null? lst)
        (reverse result)
        (let ((item (car lst)))
          (loop (cdr lst)
                (if (fn item) result (cons item result))))))}
} -output "(let ((loop #f) (lst lst) (result (quote ()))) (set! loop (lambda (lst result) (if (null? lst) (reverse result) (let ((item (car lst))) (loop (cdr lst) (if (fn item) result (cons item result))))))) (loop lst result))\n"

::tcltest::test eval-2.0 {expand cond macro} -body {
    pxp "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"
} -output "(if (> 3 4) (begin (+ 4 2)) (if (> 1 2) (begin (+ 5 5)) (if #t (begin (- 8 5)) (quote ()))))\n"

::tcltest::test eval-2.1 {run cond macro} -body {
    pep "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"
} -output "3\n"

::tcltest::test eval-2.2 {expand cond macro} -body {
    pxp "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"
} -output "(if (> 3 4) (begin (+ 4 2)) (if (> 1 2) (begin (+ 5 5)) (quote ())))\n"

::tcltest::test eval-2.3 {run cond macro} -body {
    pep "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"
} -output "()\n"

::tcltest::test eval-2.4 {expand cond macro} -body {
    pxp "(cond ((> 3 4) (+ 4 2) (+ 3 5)) ((> 1 2) (+ 5 5)))"
} -output "(if (> 3 4) (begin (+ 4 2) (+ 3 5)) (if (> 1 2) (begin (+ 5 5)) (quote ())))\n"

::tcltest::test eval-3.0 {expand case macro} -body {
    pxp "(case (* 2 3) ((2 3 5 7) (quote prime)) ((1 4 6 8 9) (quote composite)))"
} -output "(if (memv (* 2 3) (quote (2 3 5 7))) (begin (quote prime)) (if (memv (* 2 3) (quote (1 4 6 8 9))) (begin (quote composite)) (quote ())))\n"

::tcltest::test eval-3.1 {run case macro} -body {
    pep "(case (* 2 3) ((2 3 5 7) (quote prime)) ((1 4 6 8 9) (quote composite)))"
} -output "composite\n"

::tcltest::test eval-3.2 {expand case macro} -body {
    pxp "(case (car (quote (c d))) ((a e i o u) (quote vowel)) ((w y) (quote semivowel)) (else (quote consonant)))"
} -output "(if (memv (car (quote (c d))) (quote (a e i o u))) (begin (quote vowel)) (if (memv (car (quote (c d))) (quote (w y))) (begin (quote semivowel)) (if #t (begin (quote consonant)) (quote ()))))\n"

::tcltest::test eval-3.3 {run case macro} -body {
    pep "(case (car (quote (c d))) ((a e i o u) (quote vowel)) ((w y) (quote semivowel)) (else (quote consonant)))"
} -output "consonant\n"

::tcltest::test eval-4.0 {expand for macro} -body {
    pxp "(for ((i (quote (1 2 3)))) (display i))"
} -output "(begin (let ((i 1)) (display i)) (let ((i 2)) (display i)) (let ((i 3)) (display i)) (quote ()))\n"

::tcltest::test eval-4.1 {run for macro} -body {
    pep "(for ((i (quote (1 2 3)))) (display i))"
} -result "" -output 123()\n

::tcltest::test eval-4.2 {expand for macro} -body {
    pxp "(for ((i 4)) (display i))"
} -output "(begin (let ((i 0)) (display i)) (let ((i 1)) (display i)) (let ((i 2)) (display i)) (let ((i 3)) (display i)) (quote ()))\n"

::tcltest::test eval-4.3 {run for macro} -body {
    pep "(for ((i 4)) (display i))"
} -result "" -output "0123()\n"

::tcltest::test macro-5.0 {expand for/list macro} -body {
    pxp {(for/list ([i (quote (1 2 3))]) (* i i))}
} -output "(list (let ((i 1)) (* i i)) (let ((i 2)) (* i i)) (let ((i 3)) (* i i)))\n"

::tcltest::test macro-5.1 {run for/list macro} -body {
    pep {(for/list ([i (quote (1 2 3))]) (* i i))}
} -output "(1 4 9)\n"

::tcltest::test macro-5.2 {expand for/list macro} -body {
    pxp {(for/list ([c "abc"]) (char-upcase c))}
} -output "(list (let ((c #\\a)) (char-upcase c)) (let ((c #\\b)) (char-upcase c)) (let ((c #\\c)) (char-upcase c)))\n"

::tcltest::test macro-5.3 {run for/list macro} -body {
    pep {(for/list ([c "abc"]) (char-upcase c))}
} -output "(#\\A #\\B #\\C)\n"

::tcltest::test macro-5.4 {expand for/list macro} -body {
    pxp {(for/list ([i (in-range 1 4)]) (* i i))}
} -output "(list (let ((i 1)) (* i i)) (let ((i 2)) (* i i)) (let ((i 3)) (* i i)))\n"

::tcltest::test macro-5.5 {run for/list macro} -body {
    pep {(for/list ([i (in-range 1 4)]) (* i i))}
} -output "(1 4 9)\n"

::tcltest::test macro-5.6 {expand for/list macro} -body {
    pxp {(for/list ([i (in-range 1 4)] [j "abc"]) (list i j))}
} -output "(list (let ((i 1) (j #\\a)) (list i j)) (let ((i 2) (j #\\b)) (list i j)) (let ((i 3) (j #\\c)) (list i j)))\n"

::tcltest::test macro-5.7 {run for/list macro} -body {
    pep {(for/list ([i (in-range 1 4)] [j "abc"]) (list i j))}
} -output "((1 #\\a) (2 #\\b) (3 #\\c))\n"


::tcltest::test eval-5.0 {lambda parameter lists} -body {
    pep {((lambda (x y z) (list x y z)) 3 4 5)}
    pep {((lambda x x) 3 4 5 6)}
    pep {((lambda (x y . z) (list x y)) 3 4 5 6)}
    pep {((lambda (x y . z) z) 3 4 5 6)}
} -output "(3 4 5)\n(3 4 5 6)\n(3 4)\n(5 6)\n"




::tcltest::test write-1.0 {read, eval, and write a number} -body {
    pep "99.99"
} -output "99.99\n"

::tcltest::test write-1.1 {read, eval, and write a boolean} -body {
    pep "#t"
} -output "#t\n"

::tcltest::test write-1.2 {read, eval, and write a list} -body {
    pep "'(a b c)"
} -output "(a b c)\n"



::tcltest::test number-1.0 {try number?} -body {
    pep "(number? 99.99)"
} -output "#t\n"

::tcltest::test number-1.1 {try number?} -body {
    ::constcl::MkNumber foo
} -returnCodes error -result "NUMBER expected\nfoo"



::tcltest::test number-1.2 {try =} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(= 9 9 9 9)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.3 {try <} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(< 1 2 4 7)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.4 {try >} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(> 7 4 2 1)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.5 {try <=} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(<= 1 4 4 7)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.6 {try >=} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(>= 7 4 4 1)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.7 {try zero?} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(zero? 77)"
        write [eval [read]]
    }
} -output "#f\n"



::tcltest::test number-1.8 {try positive?} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(positive? 77)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.9 {try negative?} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(negative? 77)"
        write [eval [read]]
    }
} -output "#f\n"



::tcltest::test number-1.10 {try even?} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(even? 77)"
        write [eval [read]]
    }
} -output "#f\n"



::tcltest::test number-1.11 {try odd?} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(odd? 77)"
        write [eval [read]]
    }
} -output "#t\n"



::tcltest::test number-1.12 {try max} -body {
    pep "(max 7 1 10 3)"
} -output "10\n"



::tcltest::test number-1.13 {try min} -body {
    namespace eval ::constcl {
        set ::inputbuffer "(min 7 1 10 3)"
        write [eval [read]]
    }
} -output "1\n"



::tcltest::test number-1.14 {try +} -body {
    pep "(+)"
    pep "(+ 5)"
    pep "(+ 7 1 10 3)"
} -output "0\n5\n21\n"



::tcltest::test number-1.15 {try *} -body {
    pep "(*)"
    pep "(* 5)"
    pep "(* 7 1 10 3)"
} -output "1\n5\n210\n"



::tcltest::test number-1.16 {try -} -body {
    pep "(-)"
} -returnCodes error -result {wrong # args: should be "::tcl::mathop::- value ?value ...?"}

::tcltest::test number-1.16 {try -} -body {
    pep "(- 5)"
    pep "(- 7 1 10 3)"
} -output "-5\n-7\n"



::tcltest::test number-1.17 {try /} -body {
    pep "(/)"
} -returnCodes error -result {wrong # args: should be "::tcl::mathop::/ value ?value ...?"}

::tcltest::test number-1.17 {try /} -body {
    pep "(/ 5)"
    pep "(/ 21 7 3)"
} -output "0.2\n1\n"



::tcltest::test number-1.18 {try abs} -body {
    pep "(abs -99)"
} -output "99\n"



::tcltest::test number-1.19 {try floor} -body {
    pep "(floor 99.9)"
} -output "99.0\n"



::tcltest::test number-1.20 {try ceiling} -body {
    pep "(ceiling 99.9)"
} -output "100.0\n"



::tcltest::test number-1.21 {try truncate} -body {
    pep "(truncate 99.9)"
    pep "(truncate -99.9)"
} -output "99.0\n-99.0\n"



::tcltest::test number-1.22 {try round} -body {
    pep "(round 99.9)"
    pep "(round 99.3)"
} -output "100\n99\n"

::tcltest::test number-1.23 {try various} -body {
    pep "(floor 3.5)"
    pep "(ceiling 3.5)"
    pep "(truncate 3.5)"
    pep "(round 3.5)"
} -output "3.0\n4.0\n3.0\n4\n"



::tcltest::test number-1.24 {try exp} -body {
    pep "(exp 3)"
} -output "20.085536923187668\n"



::tcltest::test number-1.25 {try log} -body {
    pep "(log 3)"
} -output "1.0986122886681098\n"



::tcltest::test number-1.26 {try trig} -body {
    pep "(sin (/ pi 3))"
    pep "(cos (/ pi 3))"
    pep "(tan (/ pi 3))"
} -output "0.8660254037844386\n0.5000000000000001\n1.7320508075688767\n"



::tcltest::test number-1.27 {try trig} -body {
    pep "(asin 0.3)"
    pep "(acos 0.3)"
    pep "(atan 0.3)"
} -output "0.3046926540153975\n1.2661036727794992\n0.2914567944778671\n"



::tcltest::test number-1.28 {try sqrt} -body {
    pep "(sqrt 16)"
} -output "4.0\n"



::tcltest::test number-1.29 {try expt} -body {
    pep "(expt 4 2)"
} -output "16.0\n"



::tcltest::test number-1.30 {try number->string} -body {
    pep "(number->string 23)"
    pep "(number->string 23 2)"
    pep "(number->string 23 8)"
    pep "(number->string 23 16)"
} -output "\"23\"\n\"10111\"\n\"27\"\n\"17\"\n"



::tcltest::test number-1.31 {try string->number} -body {
    pep {(string->number "23")}
    pep {(string->number "10111" 2)}
    pep {(string->number "27" 8)}
    pep {(string->number "17" 16)}
} -output "23\n23\n23\n23\n"



::tcltest::test boolean-1.0 {evaluate boolean values} -body {
        pep "#t"
} -output "#t\n"

::tcltest::test boolean-1.1 {evaluate boolean values} -body {
        pep "#f"
} -output "#f\n"

::tcltest::test boolean-1.2 {evaluate boolean values} -body {
        pep "'#f"
} -output "#f\n"



::tcltest::test boolean-2.0 {evaluate boolean values} -body {
        pep "(boolean? #f)"
} -output "#t\n"

::tcltest::test boolean-2.1 {evaluate boolean values} -body {
        pep "(boolean? 0)"
} -output "#f\n"

::tcltest::test boolean-2.2 {evaluate boolean values} -body {
        pep "(boolean? '())"
} -output "#f\n"



::tcltest::test boolean-3.0 {not procedure} -body {
        pep "(not #t)"
} -output "#f\n"

::tcltest::test boolean-3.1 {not procedure} -body {
        pep "(not 3)"
} -output "#f\n"

::tcltest::test boolean-3.2 {not procedure} -body {
        pep "(not (list 3))"
} -output "#f\n"

::tcltest::test boolean-3.3 {not procedure} -body {
        pep "(not #f)"
} -output "#t\n"

::tcltest::test boolean-3.4 {not procedure} -body {
        pep "(not '())"
} -output "#f\n"

::tcltest::test boolean-3.5 {not procedure} -body {
        pep "(not (list))"
} -output "#f\n"

::tcltest::test boolean-3.6 {not procedure} -body {
        pep "(not 'nil)"
} -output "#f\n"



::tcltest::test characters-1.0 {try char?} -body {
    pep {(char? #\A)}
} -output "#t\n"



::tcltest::test characters-1.1 {try char=?} -body {
    pep {(char=? #\A #\A)}
    pep {(char=? #\A #\a)}
    pep {(char=? #\Space #\space)}
} -output "#t\n#f\n#t\n"



::tcltest::test characters-1.2 {try char<?} -body {
    pep {(char<? #\A #\A)}
    pep {(char<? #\A #\B)}
    pep {(char<? #\B #\A)}
} -output "#f\n#t\n#f\n"



::tcltest::test characters-1.3 {try char>?} -body {
    pep {(char>? #\A #\A)}
    pep {(char>? #\A #\B)}
    pep {(char>? #\B #\A)}
} -output "#f\n#f\n#t\n"



::tcltest::test characters-1.4 {try char<=?} -body {
    pep {(char<=? #\A #\A)}
    pep {(char<=? #\A #\B)}
    pep {(char<=? #\B #\A)}
} -output "#t\n#t\n#f\n"



::tcltest::test characters-1.5 {try char>=?} -body {
    pep {(char>=? #\A #\A)}
    pep {(char>=? #\A #\B)}
    pep {(char>=? #\B #\A)}
} -output "#t\n#f\n#t\n"



::tcltest::test characters-1.6 {try char-ci=?} -body {
    pep {(char-ci=? #\A #\a)}
    pep {(char-ci=? #\A #\b)}
    pep {(char-ci=? #\B #\a)}
} -output "#t\n#f\n#f\n"



::tcltest::test characters-1.7 {try char-ci<?} -body {
    pep {(char-ci<? #\A #\a)}
    pep {(char-ci<? #\A #\b)}
    pep {(char-ci<? #\B #\a)}
} -output "#f\n#t\n#f\n"



::tcltest::test characters-1.8 {try char-ci>?} -body {
    pep {(char-ci>? #\A #\a)}
    pep {(char-ci>? #\A #\b)}
    pep {(char-ci>? #\B #\a)}
} -output "#f\n#f\n#t\n"



::tcltest::test characters-1.9 {try char-ci<=?} -body {
    pep {(char-ci<=? #\A #\a)}
    pep {(char-ci<=? #\A #\b)}
    pep {(char-ci<=? #\B #\a)}
} -output "#t\n#t\n#f\n"



::tcltest::test characters-1.10 {try char-ci>=?} -body {
    pep {(char-ci>=? #\A #\a)}
    pep {(char-ci>=? #\A #\b)}
    pep {(char-ci>=? #\B #\a)}
    pep {(char-ci>=? #\A #\Space)}
} -output "#t\n#f\n#t\n#t\n"



::tcltest::test characters-1.11 {try char-alphabetic?} -body {
    pep {(char-alphabetic? #\A)}
    pep {(char-alphabetic? #\9)}
    pep {(char-alphabetic? #\space)}
    pep {(char-alphabetic? #\A)}
    pep {(char-alphabetic? #\a)}
    pep {(char-alphabetic? #\%)}
} -output "#t\n#f\n#f\n#t\n#t\n#f\n"



::tcltest::test characters-1.12 {try char-numeric?} -body {
    pep {(char-numeric? #\A)}
    pep {(char-numeric? #\9)}
    pep {(char-numeric? #\space)}
    pep {(char-numeric? #\A)}
    pep {(char-numeric? #\a)}
    pep {(char-numeric? #\%)}
} -output "#f\n#t\n#f\n#f\n#f\n#f\n"



::tcltest::test characters-1.13 {try char-whitespace?} -body {
    pep {(char-whitespace? #\A)}
    pep {(char-whitespace? #\9)}
    pep {(char-whitespace? #\space)}
    pep {(char-whitespace? #\A)}
    pep {(char-whitespace? #\a)}
    pep {(char-whitespace? #\%)}
} -output "#f\n#f\n#t\n#f\n#f\n#f\n"



::tcltest::test characters-1.14 {try char-upper-case?} -body {
    pep {(char-upper-case? #\A)}
    pep {(char-upper-case? #\9)}
    pep {(char-upper-case? #\space)}
    pep {(char-upper-case? #\A)}
    pep {(char-upper-case? #\a)}
    pep {(char-upper-case? #\%)}
} -output "#t\n#f\n#f\n#t\n#f\n#f\n"



::tcltest::test characters-1.15 {try char-lower-case?} -body {
    pep {(char-lower-case? #\A)}
    pep {(char-lower-case? #\9)}
    pep {(char-lower-case? #\space)}
    pep {(char-lower-case? #\A)}
    pep {(char-lower-case? #\a)}
    pep {(char-lower-case? #\%)}
} -output "#f\n#f\n#f\n#f\n#t\n#f\n"



::tcltest::test characters-1.16 {try char-upcase?} -body {
    pep {(char-upcase #\A)}
    pep {(char-upcase #\a)}
    pep {(char-upcase #\space)}
} -output "#\\A\n#\\A\n#\\space\n"



::tcltest::test characters-1.17 {try char-downcase?} -body {
    pep {(char-downcase #\A)}
    pep {(char-downcase #\a)}
    pep {(char-downcase #\space)}
} -output "#\\a\n#\\a\n#\\space\n"



::tcltest::test control-1.0 {try procedure?)} -body {
    pep {(procedure? car)}
    pep {(procedure? 'car)}
    pep {(procedure? (lambda (x) (* x x)))}
} -output "#t\n#f\n#t\n"



::tcltest::test control-1.1 {try apply)} -body {
    pep {(apply + (list 3 4))}
    pep {(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))}
    pep {((compose sqrt *) 12 75)}
} -output "7\n30.0\n"



::tcltest::test pairslists-1.0 {playing with lists} -body {
    pep {(define x (list 'a 'b 'c))}
    pep {(define y x)}
    pep {y}
    pep {(list? y)}
} -output "(a b c)\n#t\n"

::tcltest::test pairslists-1.2 {playing with lists} -body {
    pep {(set-cdr! x 4)}
    pep {x}
} -output "4\n(a . 4)\n"

::tcltest::test pairslists-1.3 {playing with lists} -body {
    pep {(eqv? x y)}
    pep {y}
} -output "#t\n(a . 4)\n"

::tcltest::test pairslists-1.4 {playing with lists} -body {
    pep {(eqv? x y)}
    pep {y}
    pep {(list? y)}
} -output "#t\n(a . 4)\n#f\n"

::tcltest::test pairslists-1.5 {try pair?} -body {
    pep {(pair? '(a . b))}
    pep {(pair? '(a b c))}
    pep {(pair? '())}
} -output "#t\n#t\n#f\n"



::tcltest::test pairslists-1.6 {try cons} -body {
    pep {(cons 'a '())}
    pep {(cons '(a) '(b c d))}
    pep {(cons "a" '(b c))}
    pep {(cons 'a 3)}
    pep {(cons '(a b) 'c)}
} -output "(a)\n((a) b c d)\n(\"a\" b c)\n(a . 3)\n((a b) . c)\n"



::tcltest::test pairslists-1.7 {try car} -body {
    pep {(car '(a b c))}
    pep {(car '((a) b c d))}
    pep {(car '(1 . 2))}
} -output "a\n(a)\n1\n"

::tcltest::test pairslists-1.8 {try car} -body {
    pep {(car '())}
} -returnCodes error -result "PAIR expected"



::tcltest::test pairslists-1.9 {try cdr} -body {
    pep {(cdr '((a) b c d))}
    pep {(cdr '(1 . 2))}
} -output "(b c d)\n2\n"

::tcltest::test pairslists-1.10 {try cdr} -body {
    pep {(cdr '())}
} -returnCodes error -result "PAIR expected"



::tcltest::test pairslists-1.11 {try set-car!} -body {
    pep {(define f (lambda () (list 'not-a-constant-list)))}
    pep {(define g (lambda () '(constant-list)))}
    pep {(set-car! (f) 3)}
} -output "3\n"

::tcltest::test pairslists-1.12 {try set-car!} -body {
    pep {(set-car! (g) 3)}
} -returnCodes error -result "Can't modify a constant pair"



::tcltest::test pairslists-1.13 {try set-cdr!} -body {
    pep {(define f (lambda () (list 'not-a-constant-list)))}
    pep {(define g (lambda () '(constant-list)))}
    pep {(set-cdr! (f) 3)}
} -output "3\n"

::tcltest::test pairslists-1.14 {try set-cdr!} -body {
    pep {(set-cdr! (g) 3)}
} -returnCodes error -result "Can't modify a constant pair"



::tcltest::test pairslists-1.15 {try list?} -body {
    pep {(list? '(a b c))}
    pep {(list? '())}
    pep {(list? '(a . b))}
} -output "#t\n#t\n#f\n"

::tcltest::test pairslists-1.16 {try list?} -constraints knownBug -body {
    pep {(let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))}
} -output "#f"



::tcltest::test pairslists-1.17 {try list} -body {
    pep {(list 'a (+ 3 4) 'c)}
    pep {(list)}
} -output "(a 7 c)\n()\n"



::tcltest::test pairslists-1.18 {try length} -body {
    pep {(length '(a b c))}
    pep {(length '(a (b) (c d e)))}
    pep {(length '())}
} -output "3\n3\n0\n"



::tcltest::test pairslists-1.19 {try append} -body {
    pep {(append '(x) '(y))}
    pep {(append '(a) '(b c d))}
    pep {(append '(a (b)) '((c)))}
    pep {(append '(a b) '(c . d))}
    pep {(append '() 'a)}
} -output "(x y)\n(a b c d)\n(a (b) (c))\n(a b c . d)\na\n"



::tcltest::test pairslists-1.20 {try reverse} -body {
    pep {(reverse '(a b c))}
    pep {(reverse '(a (b c) d (e (f))))}
} -output "(c b a)\n((e (f)) d (b c) a)\n"



::tcltest::test pairslists-1.21 {try list-tail} -body {
    pep {(list-tail '(a b c d) 2)}
} -output "(c d)\n"



::tcltest::test pairslists-1.22 {try list-ref} -body {
    pep {(list-ref '(a b c d) 2)}
} -output "c\n"



::tcltest::test pairslists-1.23 {try memq, memv} -body {
    pep {(memq 'a '(a b c))}
    pep {(memq 'b '(a b c))}
    pep {(memq 'a '(b c d))}
    pep {(memq (list 'a) '(b (a) c))}
    pep {(memq 101 '(100 101 102))}
    pep {(memv 101 '(100 101 102))}
} -output "(a b c)\n(b c)\n#f\n#f\n(101 102)\n(101 102)\n"

::tcltest::test pairslists-1.24 {try member} -body {
    pep {(member (list 'a) '(b (a) c))}
} -output "((a) c)\n"


::tcltest::test pairslists-1.25 {try member} -body {
    pep {(define e '((a 1) (b 2) (c 3)))}
    pep {(assq 'a e)}
    pep {(assq 'b e)}
    pep {(assq 'd e)}
    pep {(assq (list 'a) '(((a)) ((b)) ((c))))}
    pep {(assoc (list 'a) '(((a)) ((b)) ((c))))}
    pep {(assq 5 '((2 3) (5 7) (11 13)))}
    pep {(assv 5 '((2 3) (5 7) (11 13)))}
} -output "(a 1)\n(b 2)\n#f\n#f\n((a))\n(5 7)\n(5 7)\n"


::tcltest::test strings-1.0 {try string?} -body {
    pep {(string? "foo bar")}
    pep {(string? 'foo-bar)}
} -output "#t\n#f\n"



::tcltest::test strings-1.1 {try make-string} -body {
    pep {(make-string 5 #\x)}
} -output "\"xxxxx\"\n"



::tcltest::test strings-1.2 {try string} -body {
    pep {(string #\f #\o #\o)}
} -output "\"foo\"\n"



::tcltest::test strings-1.3 {try string-length} -body {
    pep {(string-length "foo bar")}
} -output "7\n"



::tcltest::test strings-1.4 {try string-ref} -body {
    pep {(string-ref "foo bar" 4)}
} -output "#\\b\n"



::tcltest::test strings-1.5 {try string-set!} -body {
    pep {(string-set! (string #\f #\o #\o) 0 #\x)}
} -output "\"xoo\"\n"

::tcltest::test strings-1.6 {try string-set!} -body {
    pep {(define f (lambda () (make-string 3 #\*)))}
    pep {(define g (lambda () "***"))}
    pep {(string-set! (f) 0 #\?)}
} -output "\"?**\"\n"

::tcltest::test strings-1.7 {try string-set!} -body {
    pep {(string-set! (g) 0 #\?)}
} -returnCodes error -result "string is constant"



::tcltest::test strings-1.8 {try string=?} -body {
    pep {(string=? "foo bar" "faa bor")}
    pep {(string=? "foo bar" "foo bar")}
    pep {(string=? "foo bar" "Foo bar")}
} -output "#f\n#t\n#f\n"



::tcltest::test strings-1.9 {try string-ci=?} -body {
    pep {(string-ci=? "foo bar" "faa bor")}
    pep {(string-ci=? "foo bar" "foo bar")}
    pep {(string-ci=? "foo bar" "Foo bar")}
} -output "#f\n#t\n#t\n"



::tcltest::test strings-1.10 {try string<?} -body {
    pep {(string<? "bar" "car")}
    pep {(string<? "bar" "bar")}
    pep {(string<? "bar" "aar")}
} -output "#t\n#f\n#f\n"



::tcltest::test strings-1.11 {try string-ci<?} -body {
    pep {(string-ci<? "bar" "Car")}
    pep {(string-ci<? "bar" "Bar")}
    pep {(string-ci<? "bar" "Aar")}
} -output "#t\n#f\n#f\n"



::tcltest::test strings-1.12 {try string>?} -body {
    pep {(string>? "bar" "car")}
    pep {(string>? "bar" "bar")}
    pep {(string>? "bar" "aar")}
} -output "#f\n#f\n#t\n"



::tcltest::test strings-1.13 {try string-ci>?} -body {
    pep {(string-ci>? "bar" "Car")}
    pep {(string-ci>? "bar" "Bar")}
    pep {(string-ci>? "bar" "Aar")}
} -output "#f\n#f\n#t\n"



::tcltest::test strings-1.14 {try string<=?} -body {
    pep {(string<=? "bar" "car")}
    pep {(string<=? "bar" "bar")}
    pep {(string<=? "bar" "aar")}
} -output "#t\n#t\n#f\n"



::tcltest::test strings-1.15 {try string-ci<=?} -body {
    pep {(string-ci<=? "bar" "Car")}
    pep {(string-ci<=? "bar" "Bar")}
    pep {(string-ci<=? "bar" "Aar")}
} -output "#t\n#t\n#f\n"



::tcltest::test strings-1.16 {try string>=?} -body {
    pep {(string>=? "bar" "car")}
    pep {(string>=? "bar" "bar")}
    pep {(string>=? "bar" "aar")}
} -output "#f\n#t\n#t\n"



::tcltest::test strings-1.17 {try string-ci>=?} -body {
    pep {(string-ci>=? "bar" "Car")}
    pep {(string-ci>=? "bar" "Bar")}
    pep {(string-ci>=? "bar" "Aar")}
} -output "#f\n#t\n#t\n"



::tcltest::test strings-1.18 {try substring} -body {
    pep {(substring "foo bar" 0 2)}
} -output "\"foo\"\n"



::tcltest::test strings-1.19 {try string-append} -body {
    pep {(string-append "foo" " bar")}
} -output "\"foo bar\"\n"



::tcltest::test strings-1.20 {try string->list} -body {
    pep {(string->list "foo")}
} -output "(#\\f #\\o #\\o)\n"



::tcltest::test strings-1.21 {try list->string} -body {
    pep {(list->string '(#\f #\o #\o))}
} -output "\"foo\"\n"



::tcltest::test strings-1.22 {try string-copy} -body {
    pep {(define x (string-copy "foo"))}
    pep {(string-set! x 0 #\x)}
} -output "\"xoo\"\n"



::tcltest::test strings-1.23 {try string-fill!} -body {
    pep {(define x (string-copy "foo"))}
    pep {(string-fill! x #\x)}
} -output "\"xxx\"\n"



::tcltest::test symbols-1.0 {try symbol?} -body {
    pep {(symbol? 'foo)}
    pep {(symbol? (car '(a b)))}
    pep {(symbol? "bar")}
    pep {(symbol? 'nil)}
    pep {(symbol? '())}
    pep {(symbol? #f)}
    puts [::constcl::symbol? #Q]
} -output "#t\n#t\n#f\n#t\n#f\n#f\n#t\n"



::tcltest::test symbols-1.1 {try symbol->string (and string->symbol)} -body {
    pep {(symbol->string 'flying-fish)}
    pep {(symbol->string 'Martin)}
    pep {(symbol->string (string->symbol "Malvina"))}
} -output {"flying-fish"
"martin"
"Malvina"
}

# hangs tkcon
::tcltest::test symbols-1.2 {try symbol->string} -constraints knownBug -body {
    pep {(string-set! (symbol->string 'flying-fish) 3 #\A}
} -returnCodes error -result ""



::tcltest::test vectors-1.0 {try vector? (and make-vector, vector)} -body {
    pep {(vector? '#(0 (2 2 2 2) "Anna"))}
    pep {(vector? (make-vector 3 #\X))}
    pep {(vector? (vector 'a 'b 'c))}
} -output "#t\n#t\n#t\n"



::tcltest::test vectors-1.1 {try vector} -body {
    pep {(vector 'a 'b 'c)}
    pep {(vector 0 '(2 2 2 2) "Anna")}
} -output "#(a b c)\n#(0 (2 2 2 2) \"Anna\")\n"



::tcltest::test vectors-1.2 {try vector-length} -body {
    pep {(vector-length (vector 'a 'b 'c))}
} -output "3\n"



::tcltest::test vectors-1.3 {try vector-ref} -body {
    pep {(vector-ref (vector 'a 'b 'c) 1)}
} -output "b\n"



::tcltest::test vectors-1.4 {try vector-set!} -body {
    pep {(define x (lambda () (vector 0 '(2 2 2 2) "Anna")))}
    pep {(vector-set! (x) 1 '(foo bar))}
} -output "#(0 (foo bar) \"Anna\")\n"



::tcltest::test vectors-1.5 {try vector->list} -body {
    pep {(vector->list (vector 'a 'b 'c))}
} -output "(a b c)\n"



::tcltest::test vectors-1.6 {try list->vector} -body {
    pep {(list->vector '(a b c))}
} -output "#(a b c)\n"



::tcltest::test vectors-1.7 {try vector-fill!} -body {
    pep {(vector-fill! (vector 'a 'b 'c) 'x)}
} -output "#(x x x)\n"


::tcltest::test cons-1.0 {calculate circle area} -body {
    pep "(define circle-area (lambda (r) (* pi (* r r))))"
    pep "(circle-area 3)"
} -output 28.274333882308138\n

::tcltest::test cons-2.0 {calculate factorial} -body {
    pep "(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))"
    pep "(fact 10)"
} -output 3628800\n

::tcltest::test cons-2.1 {calculate factorial} -body {
    pep "(fact 100)"
} -output 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n

::tcltest::test cons-2.2 {calculate factorial} -body {
    pep "(circle-area (fact 10))"
} -output 41369087205782.695\n

::tcltest::test cons-3.0 {count} -body {
    pep "(define first car)"
    pep "(define rest cdr)"
    pep "(define truthtoint (lambda (val) (if val 1 0)))"
    pep "(define count (lambda (item L) (if (not (eqv? L '())) (+ (truthtoint (equal? item (first L))) (count item (rest L))) 0)))"
} -output ""

::tcltest::test cons-3.0 {count} -body {
    pep "(count 0 (list 0 1 2 3 0 0))"
} -output 3\n

::tcltest::test cons-3.1 {count} -body {
    pep "(count (quote the) (quote (the more the merrier the bigger the better)))"
} -output 4\n

::tcltest::test cons-4.0 {twice} -body {
    pep "(define twice (lambda (x) (* 2 x)))"
    pep "(twice 5)"
} -output 10\n

::tcltest::test cons-4.1 {twice} -body {
    pep "(define repeat (lambda (f) (lambda (x) (f (f x)))))"
    pep "((repeat twice) 10)"
} -output 40\n

::tcltest::test cons-4.2 {twice} -body {
    pep "((repeat (repeat twice)) 10)"
} -output 160\n

::tcltest::test cons-4.3 {twice} -body {
    pep "((repeat (repeat (repeat twice))) 10)"
} -output 2560\n

::tcltest::test cons-4.4 {twice} -body {
    pep "((repeat (repeat (repeat (repeat twice)))) 10)"
} -output 655360\n

::tcltest::test cons-5.0 {fib-range} -body {
    pep "(define fib (lambda (n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))"
    pep "(define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+ a 1) b)))))"
    pep "(range 0 10)"
} -output "(0 1 2 3 4 5 6 7 8 9)\n"

::tcltest::test cons-5.1 {fib-range} -constraints knownBug -body { ;# no map
    pep "(map fib (range 0 10))"
} -output "(1 1 2 3 5 8 13 21 34 55)"

::tcltest::test cons-5.2 {fib-range} -constraints knownBug -body { ;# no map
    pep "(map fib (range 0 20))"
} -output "(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)"

::tcltest::test cons-6.0 {procedure call with a list operator} -body {
    pep "((if #t + *) 2 3)"
} -output "5\n"

::tcltest::test cons-7.0 {assignment} -body {
    pep "(begin (define r 10) (set! r 20) r)"
} -output "20\n"

::tcltest::test cons-7.1 {assignment returns a value} -body {
    pep "(begin (define r 10) (set! r 20))"
} -output "20\n"

::tcltest::test cons-7.2 {assignment to an unbound symbol} -body {
    pep "(begin (set! XX 20))"
} -returnCodes error -result "Unbound variable: XX"

::tcltest::test cons-8.0 {procedure definition} -body {
    pep "(lambda (r) (* r r))"
} -match regexp -output "::oo::Obj\\d+\n"

::tcltest::test cons-8.1 {procedure with two expressions} -body {
    pep "(define f (lambda () (define r 20) (* r r)))"
    pep "(f)"
} -output "400\n"

::tcltest::test cons-9.0 {symbol?} -body {
    pep "(symbol? (quote foo99))"
} -output "#t\n"

::tcltest::test cons-10.0 {shadowing} -body {
    pep "(begin (define r 10) (define f (lambda (r) (set! r 20))) (f 30) r)"
} -output "10\n"

#-constraints knownBug 
::tcltest::test cons-11.0 {and} -body {
    pep "(and (= 2 2) (> 2 1))"
} -output "#t\n"

::tcltest::test cons-11.1 {and} -body {
    pep "(and (= 2 2) (< 2 1))"
} -output "#f\n"

::tcltest::test cons-11.2 {and :( } -body {
    pep "(and)"
} -output "#t\n"

::tcltest::test cons-11.3 {and} -body {
    pep "(and 1 2 (quote c) (quote (f g)))"
} -output "(f g)\n"

::tcltest::test cons-12.0 {or} -body {
    pep "(or (= 2 2) (> 2 1))"
} -output "#t\n"

::tcltest::test cons-12.1 {or} -body {
    pep "(or (= 2 2) (< 2 1))"
} -output "#t\n"

::tcltest::test cons-12.2 {or} -body {
    pep "(or #f #f #f)"
} -output "#f\n"

::tcltest::test cons-12.3 {or} -body {
    pep "(or)"
} -output "#f\n"

::tcltest::test cons-13.0 {expandquotes} -body {
    pep "''foo"
} -output "(quote foo)\n"

::tcltest::test cons-14.0 {Scheme cookbook, due to Jakub T. Jankiewicz} -body {
    pep "(define every? (lambda (fn list)
  (or (null? list)
      (and (fn (car list)) (every? fn (cdr list))))))"
    pep "(every? number? '(1 2 3 4))"
} -output "#t\n"

::tcltest::test cons-14.1 {Scheme cookbook, due to Jakub T. Jankiewicz} -body {
    pep "(define adjoin (lambda (x a)
  (if (member x a)
      a
      (cons x a))))"
    pep "(adjoin 'x '(a b c))"
} -output "(x a b c)\n"

::tcltest::test cons-14.2 {Scheme cookbook, due to Nils M Holm} -body {
    pep "(adjoin 'c '(a b c))"
} -output "(a b c)\n"

::tcltest::test cons-14.3 {Scheme cookbook, due to Jakub T. Jankiewicz} -body {
    pep "(define list-index (lambda (fn list)
  (let iter ((list list) (index 0))
    (if (null? list)
        -1
        (let ((item (car list)))
          (if (fn item)
              index
              (iter (cdr list) (+ index 1))))))))"
    pep "(define >10 (lambda (x) (> x 10)))"
    pep "(list-index >10 '(1 2 3 4 10 11 12 13 14))"
} -output "5\n"

::tcltest::test cons-14.4 {Scheme cookbook, due to Jakub T. Jankiewicz} -body {
    pep "(define take (lambda (lst n)
  (let loop ((result '()) (i n) (lst lst))
    (if (or (null? lst) (<= i 0))
        (reverse result)
        (loop (cons (car lst) result) (- i 1) (cdr lst))))))"
    pep "(define sublist-map (lambda (n fn lst)
  (let loop ((lst lst) (result '()))
    (if (< (length lst) n)
        (reverse result)
        (let ((next-list (take lst n)))
          (loop (cdr lst) (cons (apply fn next-list) result)))))))"
    pep "(sublist-map 2 < '(1 2 3 4))"
} -output "(#t #t #t)\n"

::tcltest::test cons-14.5 {Scheme cookbook, due to Jakub T. Jankiewicz} -body {
    pep "(define remove (lambda (fn lst)
  (let loop ((lst lst) (result '()))
    (if (null? lst)
        (reverse result)
        (let ((item (car lst)))
          (loop (cdr lst)
                (if (fn item) result (cons item result))))))))"
    pep "(remove >10 '(1 2 3 4 10 11 12 13 14))"
} -output "(1 2 3 4 10)\n"

::tcltest::test cons-14.6 {Scheme cookbook, due to Lassi Kortela} -body {
    pep {(define group (lambda (n lst)
  (if (< n 1)
      (error "group: n must be positive")
      (let loop ((lst lst) (m n) (g '()) (gs '()))
        (cond ((and (null? lst) (null? g))
               (reverse gs))
              ((or (null? lst) (zero? m))
               (loop lst n '() (cons (reverse g) gs)))
              (else
               (loop (cdr lst) (- m 1) (cons (car lst) g) gs)))))))}
    pep "(group 3 (in-range 10))"
} -output "((0 1 2) (3 4 5) (6 7 8) (9))\n"

::tcltest::test cons-14.7 {Scheme cookbook, due to Lassi Kortela} -body {
    pep {(define group-by (lambda (f lst)
  (if (null? lst) '()
      (let ((first (car lst)))
        (let loop ((lst (cdr lst))
                   (key (f first))
                   (group (list first))
                   (groups '()))
          (if (null? lst)
              (reverse (cons (reverse group) groups))
              (let ((newkey (f (car lst))))
                (if (equal? key newkey)
                    (loop (cdr lst) key
                          (cons (car lst) group)
                          groups)
                    (loop (cdr lst) newkey
                          (list (car lst))
                          (cons (reverse group) groups))))))))))}
    pep "(group-by odd? '(1 3 5 2 1 6 4 1 7))"
} -output "((1 3 5) (2) (1) (6 4) (1 7))\n"


::tcltest::test global_env-1.0 {check for a symbol} -body {
    pep "pi"
} -output 3.1415926535897931\n

::tcltest::test global_env-2.0 {dereference an unbound symbol} -body {
    pep "foo"
} -returnCodes error -result "Unbound variable: foo"

::tcltest::test global_env-2.1 {dereference an unbound symbol: procedure} -body {
    pep "(foo)"
} -returnCodes error -result "Unbound variable: foo"


::tcltest::cleanupTests
