package require tcltest
source constcl.tcl

::tcltest::test parse-1.0 {try parse in ConsTcl} -body {
  pew {(parse "42")}
} -output "42\n"

::tcltest::test parse-1.1 {try parse with StringInputPort buffer} -body {
  pw [::constcl::StringInputPort new "42"]
} -output "42\n"

::tcltest::test parse-1.1 {try parse with string} -body {
  pw "42"
} -output "42\n"


::tcltest::test parse-2.0 {try reading a string} {
    set expr [p {"foo bar"}]
    $expr value
} "foo bar"

::tcltest::test parse-2.1 {try reading a string} {
    set expr [p {"\"foo\" \\ bar"}]
    $expr value
} {"foo" \ bar}



::tcltest::test parse-3.0 {try reading quoted symbol} -body {
    pw "'foo"
} -output "(quote foo)\n"


::tcltest::test parse-4.0 {try reading an improper list} -body {
    pw "(a . b)"
} -output "(a . b)\n"

::tcltest::test parse-4.1 {try reading an improper list} -body {
    pw "(a b . c)"
} -output "(a b . c)\n"

::tcltest::test parse-4.2 {try reading a list} -body {
    set expr [p "(a (b))"]
    [::constcl::caadr $expr] name
} -result "b"

::tcltest::test parse-4.3 {try reading a list} -body {
    pw "(a)"
} -output "(a)\n"

::tcltest::test parse-4.4 {try reading a list} -body {
    pw "(a b)"
} -output "(a b)\n"

::tcltest::test parse-4.5 {try reading a list} -body {
    pw "(a b c)"
} -output "(a b c)\n"

::tcltest::test parse-4.6 {try reading a list} -body {
    pw "(a b c d)"
} -output "(a b c d)\n"

::tcltest::test parse-4.7 {try reading a list} -body {
    pw "(a b c d e)"
} -output "(a b c d e)\n"

::tcltest::test parse-4.8 {try reading a list} -body {
    pw "(a (b) )"
} -output "(a (b))\n"

::tcltest::test parse-4.9 {try reading a list} -body {
    pw "(a (b))"
} -output "(a (b))\n"



::tcltest::test parse-5.0 {try reading unquoted symbol} -body {
    pw ",foo"
} -output "(unquote foo)\n"



::tcltest::test parse-6.0 {try reading unquoted symbol} -body {
    pw "`(list 1 2 ,@foo)"
} -output "(quasiquote (list 1 2 (unquote-splicing foo)))\n"


::tcltest::test parse-7.0 {try reading a number} {
    set obj [::constcl::parse "99.99"]
    $obj value
} "99.99"

::tcltest::test parse-7.1 {try reading a number} {
    set obj [::constcl::parse "     99.99"]
    $obj value
} "99.99"

::tcltest::test parse-7.2 {try reading a number} {
    set obj [::constcl::parse "     9"]
    $obj value
} "9"

::tcltest::test parse-7.3 {try reading a number} {
    set obj [::constcl::parse "     +9"]
    $obj value
} "9"

::tcltest::test parse-7.4 {try reading a number} {
    set obj [::constcl::parse "     -9"]
    $obj value
} "-9"

::tcltest::test parse-7.5 {try reading a number} {
    set obj [::constcl::parse "     - "]
    $obj name
} "-"

::tcltest::test parse-7.6 {try reading a number} {
    set obj [::constcl::parse "     + "]
    $obj name
} "+"



::tcltest::test parse-9.0 {try reading a character} {
    set expr [p {#\A}]
    $expr char
} "A"

::tcltest::test parse-9.1 {try reading a character} {
    set expr [p "#\\space"]
    $expr char
} " "

::tcltest::test parse-9.2 {try reading a character} {
    set expr [p "#\\newline"]
    $expr char
} "\n"

::tcltest::test parse-9.3 {try reading a character} -body {
    set expr [p "#\\foobar"]
    $expr char
} -returnCodes error -result "Invalid character constant #\\foobar"



::tcltest::test parse-10.0 {try reading a vector} -body {
    pew "#(1 2 3)"
} -output "#(1 2 3)\n"

::tcltest::test parse-10.1 {try reading a vector, with non-normal expression} -body {
    pew "#(1 2 (+ 1 2))"
} -output "#(1 2 (+ 1 2))\n"



::tcltest::test parse-8.0 {try reading an identifier} {
    set expr [p "foo"]
    $expr name
} "foo"

::tcltest::test parse-8.1 {try reading an identifier} -body {
    set ib [::constcl::IB new "+foo"]
    set expr [::constcl::parse-identifier-expr]
    $expr name
} -returnCodes error -result "Identifier expected (+foo)"

::tcltest::test parse-8.2 {try reading an identifier} -body {
    set expr [p "let"]
    ::constcl::varcheck [$expr name]
} -returnCodes error -result "Variable name is reserved: let"


::tcltest::test read-1.0 {try read-expr on a string} -setup {
    ::tcltest::makeFile {"foo bar"  } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "\"foo bar\"\n"

::tcltest::test read-1.1 {try read-expr on a string/eof} -setup {
    ::tcltest::makeFile {"foo } testrr.lsp ; #"
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -returnCodes error -result {bad string (no ending double quote)}

::tcltest::test read-1.2 {try read-expr on a couple of vectors} -setup {
    ::tcltest::makeFile {  #(1 2 3)  #(11 22 33)} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "#(1 2 3)\n#(11 22 33)\n"

::tcltest::test read-1.3 {try read-expr on booleans} -setup {
    ::tcltest::makeFile {  #t  #f} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "#t\n#f\n"

::tcltest::test read-1.4 {try read-expr on characters} -setup {
    ::tcltest::makeFile {  #\A  #\space} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "#\\A\n#\\space\n"

::tcltest::test read-1.5 {try read-expr on quoted expr} -setup {
    ::tcltest::makeFile {  'foo } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "(quote foo)\n"

::tcltest::test read-1.6 {try read-expr on pair expr} -setup {
    ::tcltest::makeFile {  (a b c)  ((a b) c)} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "(a b c)\n"

::tcltest::test read-1.7 {try read-expr on pair expr} -setup {
    ::tcltest::makeFile {  ([d e] f)} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "((d e) f)\n"

::tcltest::test read-1.8 {try read-expr on pair expr} -setup {
    ::tcltest::makeFile {  (def ghi (jkl mno))} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "(def ghi (jkl mno))\n"

::tcltest::test read-1.9 {try read-expr on plus/minus} -setup {
    ::tcltest::makeFile {  +  -  -99} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "+\n-\n-99\n"

::tcltest::test read-1.10 {try read-expr on unquoted expr} -setup {
    ::tcltest::makeFile {  ,foo ,@bar} testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "(unquote foo)\n(unquote-splicing bar)\n"

::tcltest::test read-1.11 {try read-expr on dot expr} -setup {
    ::tcltest::makeFile {  a . b } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "a\n.\nb\n"

::tcltest::test read-1.12 {try read-expr on quasiquoted expr} -setup {
    ::tcltest::makeFile {  `(a b) } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "(quasiquote (a b))\n"

::tcltest::test read-1.13 {try read-expr on numeric expr} -setup {
    ::tcltest::makeFile {  99 } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "99\n"

::tcltest::test read-1.14 {try read-expr on identifiers} -setup {
    ::tcltest::makeFile {  foo    bar } testrr.lsp
    set p [pe {(open-input-file "testrr.lsp")}]
} -body {
    rw $p
    rw $p
} -cleanup {
    ::constcl::close-input-port $p
    ::tcltest::removeFile testrr.lsp
} -output "foo\nbar\n"

::tcltest::test eval-1.0 {try triggering a check} -body {
    ::constcl::invoke #NIL [list #NIL #NIL]
} -returnCodes error -result "PROCEDURE expected\n(() val ...)"


::tcltest::test eval-2.0 {lambda parameter lists} -body {
    pew {((lambda (x y z) (list x y z)) 3 4 5)}
    pew {((lambda x x) 3 4 5 6)}
    pew {((lambda (x y . z) (list x y)) 3 4 5 6)}
    pew {((lambda (x y . z) z) 3 4 5 6)}
} -output "(3 4 5)\n(3 4 5 6)\n(3 4)\n(5 6)\n"


::tcltest::test eval-3.0 {conditional: does internal if accept a #t? Yes, b/c of the ne in condition handling} -body {
    pew "(if (zero? 0) (* 4 4) (- 5 5))"
} -output "16\n"





::tcltest::cleanupTests
