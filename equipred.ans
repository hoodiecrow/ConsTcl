H2 Built-in procedures

H3 Equivalence predicates

MD(
Of the three equivalence predicates, K{eq} generally tests for identity (with
exception for numbers), K{eqv} tests for value equality (except for booleans and
procedures, where it tests for identity), and K{equal} tests for whether the
output strings are equal.

B{eq?} procedure
MD)

PR(
eq?, eqv?, equal? (public);expr1 expr expr2 expr -> bool
PR)

IX eq?
CB(
reg eq?

proc ::constcl::eq? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq symbol? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq char? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq null? $expr1 $expr2]} {
    return #t
  } elseif {[teq pair? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq string? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq vector? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } else {
    return #f
  }
}
CB)

MD(
B{teq} procedure

K{teq} tests for type equality, i.e. that the expressions have the same type.
MD)

PR(
teq (internal);typep proc expr1 expr expr2 expr -> tbool
PR)

CB(
proc ::constcl::teq {typep expr1 expr2} {
    return [expr {[$typep $expr1] ne "#f" &&
      [$typep $expr2] ne "#f"}]
}
CB)

MD(
B{veq} procedure

K{veq} tests for value equality, i.e. that the expressions have the same value.
MD)

PR(
veq (internal);expr1 expr expr2 expr -> tbool
PR)

CB(
proc ::constcl::veq {expr1 expr2} {
    return [expr {[$expr1 value] eq [$expr2 value]}]
}
CB)

TT(
::tcltest::test equipred-1.0 {try comparing a boolean and a symbol} -body {
    pew "(eq? #t 'a)"
} -output "#f\n"

::tcltest::test equipred-1.1 {try comparing two booleans} -body {
    pew "(eq? #t #t)"
} -output "#t\n"
TT)

MD(
B{eqv?} procedure
MD)

IX eqv?
CB(
reg eqv?

proc ::constcl::eqv? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq symbol? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq char? $expr1 $expr2] &&
      [veq $expr1 eq $expr2]} {
    return #t
  } elseif {[teq null? $expr1 $expr2]} {
    return #t
  } elseif {[pair? $expr1] ne "#f" &&
      [pair? $expr2] ne "#f" &&
      [$expr1 car] eq [$expr2 car] &&
      [$expr1 cdr] eq [$expr2 cdr]} {
    return #t
  } elseif {[teq string? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq vector? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } else {
    return #f
  }
}
CB)

MD(
B{equal?} procedure
MD)

IX equal?
CB(
reg equal?

proc ::constcl::equal? {expr1 expr2} {
  if {[$expr1 show] eq [$expr2 show]} {
    return #t
  } else {
    return #f
  }
  # TODO
}
CB)

# vim: ft=tcl tw=80 ts=2 sw=2 sts=2 et 
