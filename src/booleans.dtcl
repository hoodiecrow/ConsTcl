#
#  [H2 Booleans]
#
#[*text]
#  Booleans are logic values, either true (\verb|#t|) or false (\verb|#f|).  All predicates
#  (procedures whose name end with -?) return boolean values. 
#[/text]
#
#  [H3 Pseudo-booleans]
#
#[*text]
#  All values can be tested for truth (in a conditional form or as arguments to
#  E{and}, E{or}, or E{not}), though. Any value of any type is considered to be
#  true except for \verb|#f|.
#[/text]
#
#[chunk booleans {Boolean classes (True and False)}]
#
#[*text]
#  The Boolean classes are singleton classes with R{one value
#  each}{a-set-of-source-code-constants} (the global values \verb|${::#t}| and \verb|${::#f}|,
#  respectively). 
#[/text]
#
#[*code]
oo::singleton create ::constcl::True {
    superclass ::constcl::Base
}
#[/code]
#
#[chunk booleans {tstr method}]
#
#[*text]
#  The \verb|tstr| method yields the value \verb|#t| as a
#  Tcl string.
#[/text]
#
#[prototype {(True instance) tstr;-> etrue}]
#
#[*code]
method tstr {} {
    return "${::#t}"
}
#}
#[/code]
#
#[*code]
oo::singleton create ::constcl::False {
    superclass ::constcl::Base
}
#[/code]
#
#[*text]
#  The \verb|tstr| method yields the value \verb|#f| as a
#  Tcl string.
#[/text]
#
#[prototype {(False instance) tstr;-> efalse}]
#
#[*code]
method tstr {} {
    return "#f"
}
#[/code]
#
#[chunk booleans {MkBoolean generator}]
#
#[*text]
#  Given a string (either \verb|"#t"| or \verb|"#f"|),
#  \verb|MkBoolean| generates a boolean.
#[/text]
#
#[prototype {MkBoolean;bool ebool -> bool}]
#PR)
#
#[*code]
proc ::constcl::MkBoolean {bool} {
  switch $bool {
    "#t" { return ${::#t} }
    "#f" { return ${::#f} }
    default { ::error "invalid boolean ($bool)" }
  }
}
#[/code]
#
#[*test]
#
#::tcltest::test $::chunkid.0 {evaluate boolean values} -body {
#        pew "#t"
#} -output "#t\n"
#
#::tcltest::test $::chunkid.1 {evaluate boolean values} -body {
#        pew "#f"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.2 {evaluate boolean values} -body {
#        pew "'#f"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.3 {equivalence of instance and constant} -body {
#        expr {[::constcl::MkBoolean "#t"] == ${#t}}
#} -result 1
#
#::tcltest::test $::chunkid.5 {equivalence of instance and constant} -body {
#        expr {[pe "(> 3 2)"] == ${#t}}
#} -result 1
#
#::tcltest::test $::chunkid.6 {equivalence of instance and constant} -body {
#        expr {[pe "#t"] == ${#t}}
#} -result 1
#
#[/test]
#
#H4 boolean? procedure
#
#The \verb|boolean?| predicate recognizes a boolean by object identity (i.e. is it
#the true or false constant? If yes, then it is a boolean).
#
#[prototype {boolean?;val val -> bool}]
#
#[*code]
reg boolean?

proc ::constcl::boolean? {val} {
  if {$val eq ${::#t} || $val eq ${::#f}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
#[/code]
#
#[*test]
#
#::tcltest::test $::chunkid.0 {evaluate boolean values} -body {
#        pew "(boolean? #f)"
#} -output "#t\n"
#
#::tcltest::test $::chunkid.1 {evaluate boolean values} -body {
#        pew "(boolean? 0)"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.2 {evaluate boolean values} -body {
#        pew "(boolean? '())"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.3 {evaluate boolean values} -body {
#        pew "(boolean? nil)"
#} -output "#f\n"
#
#[/test]
#
#H4 not procedure
#
#The only operations on booleans are the macros E{and} and S{or}{macros}, and E{not} (logical negation).
#
#Example:
#
#VB(
#(not #f)    ==>  #t   ; #f yields #t, all others #f
#(not nil)   ==>  #f   ; see?
#VB)
#
#[prototype {not;val val -> bool}]
#
#[*code]
reg not

proc ::constcl::not {val} {
    if {$val eq ${::#f}} {
        return ${::#t}
    } else {
        return ${::#f}
    }
}
#[/code]
#
#[*test]
#
#::tcltest::test $::chunkid.0 {not procedure} -body {
#        pew "(not #t)"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.1 {not procedure} -body {
#        pew "(not #f)"
#} -output "#t\n"
#
#::tcltest::test $::chunkid.2 {not procedure} -body {
#        pew "(not nil)"
#} -output "#f\n"
#
#::tcltest::test $::chunkid.3 {not procedure} -body {
#        pew "(not (list 3))"
#} -output "#f\n"
#
#[/test]
#
## vim: ft=tcl tw=60 ts=4 sw=4 sts=4 et 
