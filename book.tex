\documentclass[a5paper,final]{memoir}
%\usepackage[a5paper]{geometry}
\usepackage{mathpazo}
%\usepackage{newpxmath}
\usepackage[final]{graphicx}
\usepackage[final]{listings}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{imakeidx}
%\usepackage{marginnote}
\usepackage[table]{xcolor}
\usepackage{caption}
\usepackage{float}
  \floatstyle{boxed}
  \newfloat{pulledtext}{tbp}{pulledtext}
\lstset{
  showstringspaces=false,
  language=tcl,
  frame=lines,
  aboveskip=\bigskipamount,
  belowskip=\bigskipamount,
  numbers=left,
  numberstyle=\tiny,
  firstnumber=last,
  basicstyle=\footnotesize\ttfamily,
}
%\renewcommand{\thesection}{\arabic{section}}
\title{Into the Interpreter\\with ConsTcl}
\author{Peter Lewerin}
\date{\today}
\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
    {\parindent \z@ \raggedright \normalfont
      \ifnum \c@secnumdepth >\m@ne
        %\if@mainmatter
          %\huge\bfseries \@chapapp\space \thechapter
          \Huge\bfseries \thechapter.\space%
          %\par\nobreak
          %\vskip 20\p@
        %\fi
      \fi
      \interlinepenalty\@M
      \Huge \bfseries #1\par\nobreak
      \vskip 40\p@
   }}
\makeatother
\makeindex[intoc]
\counterwithout{footnote}{chapter}
\setcounter{secnumdepth}{1}
\hyphenation{Cons-Tcl}
\hyphenation{ins-tan-ce}
\hyphenation{na-me-spa-ce}
\hyphenation{need-ed}
\hyphenation{back-slash}
\hyphenation{ta-kes}
\hyphenation{look-up}
\hyphenation{bool-ean}
\hyphenation{search-es}
\hyphenation{expres-sion}

\begin{document}

\frontmatter
\pagestyle{empty}
\begin{flushright}
{Into the Interpreter}
\end{flushright}
\cleardoublepage

\begin{center}
{\Huge\sffamily\thetitle}

\vspace{0.7in}
\theauthor

\end{center}
\clearpage

\begin{center}
{\small

Automatiserad teknik vilken används för att analysera text och data i digital
form i syfte att generera information, enligt 15a, 15b och 15c \S\S\ 
upphovsrättslagen (text- och datautvinning), är förbjuden.

\textcopyright\ 2025 Peter J Lewerin\\
($\phi$) Funktion förlag, Tidaholm
}
\end{center}
\clearpage

\pagestyle{plain}

\renewcommand*{\contentsname}{Short contents}
\setcounter{tocdepth}{0}% chapters and above
\tableofcontents
\clearpage
\renewcommand*{\contentsname}{Contents}
\setcounter{tocdepth}{2}% subsections and above
\tableofcontents

\addcontentsline{toc}{section}{Introduction}
\chapter*{Introduction}
\label{introduction}
\addcontentsline{toc}{section}{To run the software}
\section*{To run the software}
\label{to-run-the-software}


First things first. To run the software, source the file \textbf{constcl.tcl}
(with \textbf{schemebase.scm} in the directory) in a Tcl console (I use
\textbf{tkcon}) and use the command \textbf{repl} for a primitive command
dialog. Source \textbf{all.tcl} to run the test suite (you need
\textbf{constcl.test} for that). The files can be found on
GitHub/ConsTcl\footnote{See \texttt{https://github.com/hoodiecrow/ConsTcl}}.

The following license holds for the software, not the book:

\noindent\hrulefill
\subsection{MIT License}
\label{mit-license}
\index{MIT License}

Copyright (c) 2025 Peter Lewerin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT\@. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

\noindent\hrulefill

The software is pretty much harmless, but there is a potential danger if anyone
were to use it to write and run Scheme code that uses the output functions and
in the process were careless enough to let the code overwrite existing files. I
have put safeguards in the output functions that need to be removed before they
work.

The software works for me, but there might still be problems that I haven't
noticed. Contact me at

\indent \texttt{constcl1000@gmail.com}

with any queries or error reports. I intend to keep updating the software to
include bug fixes and interesting additions, within reason.

\addcontentsline{toc}{section}{Background}
\section*{Background}
\label{background}

It all started with Peter Norvig's\index{Norvig, Peter} Lisp emulator
Lispy\footnote{See \texttt{https://norvig.com/lispy.html}}. In January 2025 I
was inspired to port it to Tcl. The result was Thtcl\footnote{See
\texttt{https://github.com/hoodiecrow/thtcl}}. It had the same features and
limitations as Lispy, plus a couple of limitations that were due to
shortcomings of Tcl, and I came out of the experience feeling a bit
dissatisfied. In the latter part of January I embarked on a new project,
ConsTcl, a true Lisp interpreter. In Tcl.

\subsection{About Lisp}
\label{about-lisp}

ConsTcl is a \emph{Lisp interpreter}, specifically a \emph{Scheme interpreter}.
Lisp is a family of programming languages that share the same basic form, and
Scheme is one of those languages. Where some other languages use braces to
structure code, and Python uses indents, Lisp instead uses parentheses. This
Python snippet:

\begin{verbatim}
x = 1
if x == 1:
    print("x is 1.")
\end{verbatim}

\noindent looks like this in Scheme:

\begin{verbatim}
(let ((x 1))
  (if (= x 1)
    (write "x is 1.")))
\end{verbatim}

In Lisp, everything is either an \emph{atom}, an indivisible value, like
\texttt{x} and \texttt{1} (and e.g. \texttt{let} and \texttt{write} too) or
else it is a \emph{list expression}, starting and ending with parentheses and
having an operator at the front of the list, with the rest of the parts being
operands. If the operator is a keyword like \texttt{let} or \texttt{if}, then
the expression is a \emph{special form}. If not, like \texttt{=} or
\texttt{write}, then it's a \emph{function call}.

A full description of Lisp is beyond the scope of this introduction, but Lisp
will be explained from the inside out in the rest of this book. If you want to
learn Scheme right away, there are good tutorials in
different\footnote{See \texttt{https://docs.scheme.org/schintro/}}
places\footnote{See \texttt{https://www.scheme.com/tspl4/}} on the
web\footnote{See
\texttt{https://files.spritely.institute/papers/scheme-primer.html}}.

\subsection{About ConsTcl}
\label{about-constcl}

Compared to Lispy/Thtcl, ConsTcl has, (quote from Lispy), ``comments, quote and
quasiquote notation, \# literals, the derived expression types (such as cond,
derived from if, or let, derived from lambda), and dotted list notation.''
Again compared to Lispy/Thtcl, ConsTcl has the data types, quote, ``strings,
characters, booleans, ports, vectors.'' And pairs and procedures too. The
number of missing primitive procedures is in the tens, not the 100s. 

The completeness comes with a price: due to the sheer number of calls for each
action, ConsTcl is is fairly slow. On my cheap computer, the following code
(which calculates the factorial of 100) takes 0.04 seconds to run. That is thirteen
times slower than Lispy assuming that Norvig's computer is as slow as mine,
which is unlikely.

\begin{verbatim}
time {pe "(fact 100)"} 10
\end{verbatim}

ConsTcl is of course still limited. It doesn't come close to having call/cc or
tail recursion. It doesn't have exact/inexact numbers, or most of the numerical
tower. There is no memory management. Error reporting is spotty, and there is no
error recovery.

\subsection{About the book}
\label{about-the-book}


I like writing documentation, and occasionally I'm good at it. I like to
annotate the source code with bits of documentation, which I then extract and
put together using tools like \texttt{awk}. It looks like this:

\includegraphics{images/document.png}

In the middle are a bunch of \texttt{.ans} files (ANnotated Source). These are
written with Vim. From the TT tags of those, I extract a \texttt{.test} file.
From the CB tags I extract \texttt{.tcl} source (or Scheme or C source, as the
case might be). From all the tags except TT I extract formatted documentation
in Markdown and \LaTeX{} format. All these extractions are automated using
\texttt{make}.  Figures are made with Inkscape.  I create a PDF document from
the \LaTeX{} source using TeXworks. On finishing up ConsTcl, it struck me that
the documentation for this piece of software was fit for a book.

ConsTcl is at least 97\% my own work, but I have ported one part (see page
\pageref{resolving-local-defines}) from ``Scheme 9 from Empty
Space''\footnote{See \texttt{https://t3x.org/s9book/index.html}}\index{Scheme 9
from Empty Space}\index{S9fES} by Nils M Holm\index{Holm, Nils M}, a Lisp
interpreter written in C and commented in a similar manner to this book.

One source which I spent a lot more time with was R5RS\footnote{Revised${}^{5}$
Report on the Algorithmic Language Scheme, Scheme's standardization document},
\emph{the} authoritative manual on Scheme. It says nothing about the
implementation of the interpreter, but a lot on what features the language has
and how they are supposed to work.

Another source of guidance and inspiration was ``Lisp in Small Pieces'' by
Christian Queinnec. Yet another source was ``An Introduction to Scheme and its
Implementation''\footnote{See \texttt{https://docs.scheme.org/schintro/}}.

\subsection{About the program listings}
\label{about-the-program-listings}

I have tried to write clear, readable code, but the page format forces me to
shorten lines. I have used two-space indents instead of four-space, a smaller
font, and broken off long lines with a \textbackslash\  at the end of the first
line (a so-called `tucked-in tail'). Neither of these measures improve
readability, but the alternative is overwriting the margins. Not all broken
lines have the \textbackslash: some are broken inside a
\texttt{\{}\ldots\texttt{\}} block, and some right after a \texttt{^^5b}.

\subsection{About me}
\label{about-me}

I'm a 60 year old former system manager who has been active in programming
since 1979. Currently, and for some time, my language of choice is the
rather marginal Tcl\footnote{See \texttt{https://www.tcl-lang.org/}} (it's not
even in the 100 most used languages). Tcl suits me, and there are things that
one can do in Tcl that one can't easily do in other languages. Lisp is a
runner-up in my affections, a language that fascinates me but doesn't fit my
brain very well (though I have written one large piece of software in AutoLisp,
a CAD subsystem for designing drilling boxes).

In addition to my terms as programmer and system manager, I have worked as a
teacher (teaching C/C++ in upper secondary school) and for a short while I
wrote manuals for the department for information technology at
the University of Skövde. I've also been active writing answers at
question-and-answer sites on the web, mainly Stack Overflow.

\subsection{About time}
\label{about-time}

I'd like to thank

\begin{itemize}
\item my children and their lifemates for being awesome.

\item my mother and my ex-wife for supporting the printing of the book financially.

\item my sister and brother-in-law for being supportive.
\end{itemize}

\vspace{1in}\noindent And now let's journey into the Interpreter.

\mainmatter
\pagestyle{headings}


\part{The interpreter}
\label{the-interpreter}

\chapter{Initial declarations}
\label{initial-declarations}

In this chapter there is mostly things I need to start working on the interpreter. Feel free to skim it, maybe coming back later to check up on things here.

First, I need to create the namespace that I will use for most identifiers:

\begin{lstlisting}
namespace eval ::constcl {}
\end{lstlisting}

\section{Utility commands}
\label{utility-commands}
\index{utility commands}

Next, some procedures that make my life as developer somewhat easier.

\subsection{reg procedure}
\label{reg-procedure}
\index{reg procedure}

\texttt{reg} registers built-in procedures, special forms, and macros in the definitions register\index{definitions register}. That way I don't need to manually keep track of and list procedures. The definitions register's contents will eventually get tranferred into the standard library (see page \pageref{environment-startup}).

You can call \texttt{reg} with one parameter: \emph{name}. \emph{name} is a string that will eventually become the lookup symbol in the standard library. If you give two parameters, the first one is the \emph{binding type}, either \texttt{special} or \texttt{macro}. The former registers special forms like \texttt{if} and \texttt{define}, and the latter registers macros like \texttt{and} or \texttt{when}. The second one is still the \emph{name}.

There is also \texttt{regvar}, which registers variables. You pass \emph{name} and \emph{value} to it. There are only a couple of variables registered this way.

\texttt{reg} and \texttt{regvar} start out by checking if the definitions register (\texttt{defreg}) exists, and if not, they create it. Then they construct a \emph{val}(ue) by concatenating a keyword (\texttt{VARIABLE}, \texttt{SPECIAL}, or \texttt{SYNTAX}) with a variation on \emph{name} (or, in \texttt{regvar}'s case, \emph{value}). Then they set an \emph{index number} based on the current size of the \texttt{defreg}. Finally they insert the Tcl list of \emph{name} and \emph{val} under \emph{index}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{reg (internal)}} \\
?btype? & either 'special' or 'macro' \\
name & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{regvar (internal)}} \\
name & a Tcl string \\
value & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

(This kind of box explains a few things about a procedure. The last line shows what kind of value the procedure returns, if any. Above that are a number of lines that describe the parameters of the procedure, in order, by name and expected value type. If a parameter name is enclosed in ?\ldots ?, it means that the parameter is optional and can be left out.)
\index{regvar procedure}

\begin{lstlisting}
unset -nocomplain ::constcl::defreg

proc reg {args} {
  if {[llength $args] == 2} {
    lassign $args btype name
  } elseif {[llength $args] == 1} {
    lassign $args name
    set btype {}
  } else {
    error "wrong number of parameters\n([pn])"
  }
  if {![info exists ::constcl::defreg]} {
    set ::constcl::defreg [dict create]
  }
  switch $btype {
    special {
      set val [::list SPECIAL ::constcl::special-$name]
    }
    macro {
      set val [::list SYNTAX ::constcl::expand-$name]
    }
    default {
      set val [::list VARIABLE ::constcl::$name]
    }
  }
  set idx [dict size $::constcl::defreg]
  dict set ::constcl::defreg $idx [::list $name $val]
  return
}

proc regvar {name value} {
  if {![info exists ::constcl::defreg]} {
    set ::constcl::defreg [dict create]
  }
  set val [::list VARIABLE $value]
  set idx [dict size $::constcl::defreg]
  dict set ::constcl::defreg $idx [::list $name $val]
  return
}
\end{lstlisting}

\begin{pulledtext}

\subsubsection{Procedures, functions, and commands}
\label{procedures-functions-and-commands}
\index{procedures, functions, and commands}

I use all of these terms for the subroutines in ConsTcl. I try to stick with \emph{procedure}, because that's the standard term in R5RS. Still, they usually pass useful values back to the caller, so technically they're \emph{functions}. Lastly, I'm programming in Tcl here, and the usual term for these things is \emph{commands} in Tcl.

And the \emph{internal}/\emph{public} distinction is possibly a misnomer. What it means is that \emph{public} procedures can be called from Lisp code being interpreted, and the others cannot. They are for use in the infrastructure around the interpreter, including in implementing the \emph{public} procedures. Another way to put it is that procedures registered by \texttt{reg} are \emph{public} and those who aren't are \emph{internal}.
\end{pulledtext}

\subsection{atom? procedure}
\label{atom-procedure}
\index{atom? procedure}

This one isn't just for my convenience: it's a standard procedure in Scheme. There are two kinds of data in Lisp: lists\index{lists} and atoms\index{atoms}. Lists are collections of lists and atoms. Atoms are instances of types such as booleans, characters, numbers, ports, strings, symbols, and vectors. \texttt{Atom?} recognizes an atom by checking for membership in any one of the atomic types. It returns \texttt{\#t} (true) if it is an atom, and \texttt{\#f} (false) if not.

\begin{pulledtext}

\subsubsection{Predicates}
\label{predicates}
\index{predicates}

By Scheme convention, predicates (procedures that return either \texttt{\#t} or \texttt{\#f}) have '?' at the end of their name. Some care is necessary when calling Scheme predicates from Tcl code (the Tcl \texttt{if} command expects 1 or 0 as truth values). Example:

\texttt{if \{[atom? \$x]\} \ldots }

will not do, but

\texttt{if \{[atom? \$x] ne \$\{::\#f\}\} \ldots }

(``[atom? \$x] not equal to false'') works. Or see the \texttt{T} procedure.
\end{pulledtext}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{atom? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg atom?

proc ::constcl::atom? {val} {
  foreach type {symbol number string
      char boolean vector port eof} {
    if {[$type? $val] eq ${::#t}} {
      return ${::#t}
    }
  }
  return ${::#f}
}
\end{lstlisting}

\subsection{T procedure}
\label{t-procedure}
\index{T procedure}

The \texttt{T} procedure is intended to reduce the hassle of trying to make Lisp booleans work with Tcl conditions. The idea is to line the Tcl condition with \texttt{[T \ldots ]} and have the Lisp expression inside \texttt{T}. \texttt{T} returns 0 if and only if the value passed to it is \texttt{\#f}, and 1 otherwise. The procedure's name stands for `truth of'.

Example:

\begin{verbatim}
if {[T [atom? $x]]} ...
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{T (internal)}} \\
val & a value \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::T {val} {
  if {$val eq ${::#f}} {
    return 0
  } else {
    return 1
  }
}
\end{lstlisting}

\subsection{assert procedure}
\label{assert-procedure}
\index{assert procedure}

\texttt{assert} signals an error if an assertion fails.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{assert (internal)}} \\
expr & a Tcl expression \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc assert {expr} {
  if {![uplevel [list expr $expr]]} {
    error "Failed assertion [
      uplevel [list subst $expr]]"
  }
}
\end{lstlisting}

\subsection{pairlis-tcl procedure}
\label{pairlistcl-procedure}
\index{pairlis-tcl procedure}

A Tcl version of the procedure in the Scheme base (see page \pageref{pairlis-procedure}).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pairlis-tcl (internal)}} \\
lvals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::pairlis-tcl {a b} {
  if {[T [null? $a]]} {
    parse {'()}
  } else {
    cons \
      [cons [car $a] [car $b]] \
      [pairlis-tcl [cdr $a] [cdr $b]]
  }
}
\end{lstlisting}

\subsection{usage procedure}
\label{usage-procedure}
\index{usage procedure}

\texttt{usage} is a simple procedure to compare a Lisp list with the expected format of the expression. Mostly it just compares lengths.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{usage (internal)}} \\
usage & an expression \\
expr & an expression \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::usage {usage expr} {
  set u $usage
  set e $expr
  if {[[length $usage] numval] !=
      [[length $expr] numval]} {
    while {$u ne ${::#NIL} && $e ne ${::#NIL}} {
      set u [cdr $u]
      set e [cdr $e]
    }
    if {$e eq ${::#NIL} && $u ne ${::#NIL} &&
      [regexp {\?.*\?} [[car $u] name]]} {
      return
    }
    ::error "usage error\n[
      $usage tstr] not [$expr tstr]"
  }
}
\end{lstlisting}

\subsection{pn procedure}
\label{pn-procedure}
\index{pn procedure}

\texttt{pn} stands for 'procedure name'. When called, tells the caller the name of its command. I use it for error messages so the error message can automagically tell the user which command failed.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pn (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pn {} {
  namespace tail [lindex [info level -1] 0]
}
\end{lstlisting}

\subsection{unbind procedure}
\label{unbind-procedure}
\index{unbind procedure}

\texttt{unbind} removes bindings from the environment they are bound in.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{unbind (internal)}} \\
syms & some symbols \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::unbind {args} {
\end{lstlisting}

Try reading the value of \texttt{env} in the caller's context. If it succeeds, use that environment value; if it fails, use the global environment.

\begin{lstlisting}
  try {
    uplevel [list subst \$env]
  } on ok env {
  } on error {} {
    set env ::constcl::global_env
  }
\end{lstlisting}

For each symbol given, check if it is bound in \texttt{env} or any of its linked environments except the null environment. If it is, unbind it there.

\begin{lstlisting}
  set syms $args
  foreach sym $syms {
    set e [$env find $sym]
    if {$e ne "::constcl::null_env"} {
      $e unbind $sym
    }
  }
}
\end{lstlisting}

\subsection{typeof? procedure}
\label{typeof-procedure}
\index{typeof? procedure}

\texttt{typeof?} looks at a value's type and reports if it is the same as the given type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{typeof? (internal)}} \\
val & a value \\
type & a Tcl string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::typeof? {val type} {
  if {[info object isa typeof $val $type]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{splitlist procedure}
\label{splitlist-procedure}
\index{splitlist procedure}

\texttt{splitlist} converts a Lisp list to a Tcl list with Lisp objects.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{splitlist (internal)}} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}
\index{splitlist procedure}

\begin{lstlisting}
proc ::constcl::splitlist {vals} {
  set result {}
  while {[T [pair? $vals]]} {
    lappend result [car $vals]
    set vals [cdr $vals]
  }
  return $result
}
\end{lstlisting}

\subsection{in-range procedure}
\label{inrange-procedure}
\index{in-range procedure}

This one is a little bit of both, a utility function that is also among the builtins in the library (it's not standard, though). It started out as a one-liner by Donal K Fellows\index{Fellows, Donal}, but has grown a bit since then to suit my needs.

The plan is to arrange a sequence of numbers, given one, two or three ConsTcl Number objects. If one is passed to the procedure, it is used as the end of the sequence: the sequence will end just before it. If two numbers are passed, the first one becomes the start of the sequence: the first number in it. The second number will become the end of the sequence. If three numbers are passed, they become start, end, and step, i.e. how much is added to the current number to find next number in the sequence.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{in-range (public)}} \\
x & a number \\
?e? & a number \\
?t? & a number \\
\textit{Returns:} & a Lisp list of numbers \\
\hline
\end{tabular}

\begin{lstlisting}
reg in-range

proc ::constcl::in-range {x args} {
  set start 0
  set step 1
  switch [llength $args] {
    0 {
      set e $x
      set end [$e numval]
    }
    1 {
      set s $x
      lassign $args e
      set start [$s numval]
      set end [$e numval]
    }
    2 {
      set s $x
      lassign $args e t
      set start [$s numval]
      set end [$e numval]
      set step [$t numval]
    }
  }
  set res $start
  while {$step > 0 && $end > [incr start $step] ||
      $step < 0 && $end < [incr start $step]} {
    lappend res $start
  }
  return [list {*}[lmap r $res {MkNumber $r}]]
}
\end{lstlisting}

\subsection{error procedure}
\label{error-procedure}
\index{error procedure}

\texttt{error} is used to signal an error, with \emph{msg} being a message string and the optional arguments being values to show after the message.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{error (public)}} \\
msg & a message string \\
?exprs? & some expressions \\
\textit{Returns:} & -don't care- \\
\hline
\end{tabular}

\begin{lstlisting}
reg error

proc ::constcl::error {msg args} {
  set exprs $args
  if {[llength $exprs]} {
    set res [lmap expr $exprs {
      $expr tstr
    }]
    ::append msg " (" [join $res] ")"
  }
  ::error $msg
}
\end{lstlisting}

\subsection{check procedure}
\label{check-procedure}
\index{check procedure}

\texttt{check} does a check (typically a type check) on something and throws an error if it fails.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{check (internal)}} \\
cond & an expression \\
msg & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::check {cond msg} {
  if {[uplevel $cond] eq ${::#f}} {
    ::error [
      uplevel [
        ::list subst [
          ::string trim $msg]]]
  }
}
\end{lstlisting}

\section{Testing commands}
\label{testing-commands}
\index{Testing commands}

Testing gets easier if you have the software tools to manipulate and pick apart the testing data and actions. Short names reduce clutter in the test cases, at the cost of some readability.

\subsection{pew procedure}
\label{pew-procedure}
\index{pew procedure}

\texttt{pew} was originally named \texttt{pep} after the sequence parse-eval-print. Now it's named for parse-eval-write. It reads and evals an expression, and writes the result. It's the most common command in the test cases, since it allows me to write code directly in Scheme, get it evaled, and get to see proper Lisp output from it.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pew (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pew {str {env ::constcl::global_env}} {
  ::constcl::write [
    ::constcl::eval [
      ::constcl::parse $str] $env]
}
\end{lstlisting}

\subsection{rew procedure}
\label{rew-procedure}
\index{rew procedure}

\texttt{rew} is the reading variant of \texttt{pew}. Instead of taking string input it takes a regular input port. It mattered more while the input library was being written.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rew (internal)}} \\
port & an input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::rew {port {env ::constcl::global_env}} {
  ::constcl::write [
    ::constcl::eval [
      ::constcl::read $port] $env]
}
\end{lstlisting}

\subsection{pw procedure}
\label{pw-procedure}
\index{pw procedure}

\texttt{pw} is a similar command, except it doesn't eval the expression. It just writes what is parsed. It is useful for tests when the evaluator can't (yet) evaluate the form, but I can still check if it gets read and written correctly.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pw (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pw {str} {
  ::constcl::write [::constcl::parse $str]
}
\end{lstlisting}

\subsection{rw procedure}
\label{rw-procedure}
\index{rw procedure}

\texttt{rw} is the reading variant of \texttt{pw}. Instead of taking string input it takes a regular input port. The procedure just writes what is read.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rw (internal)}} \\
?port? & an input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::rw {args} {
  ::constcl::write [::constcl::read {*}$args]
}
\end{lstlisting}

\subsection{pe procedure}
\label{pe-procedure}
\index{pe procedure}

\texttt{pe} is also similar, but it doesn't write the expression. It just evaluates what is read. That way I get a value object which I can pass to another command, or pick apart in different ways.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pe (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pe {str {env ::constcl::global_env}} {
  ::constcl::eval [::constcl::parse $str] $env
}
\end{lstlisting}

\subsection{re procedure}
\label{re-procedure}
\index{re procedure}

\texttt{re} is like \texttt{pe}, but it reads from a regular port instead of an string input port or a string. It evaluates what is read.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{re (internal)}} \\
port & an input port \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::re {port {env ::constcl::global_env}} {
  ::constcl::eval [::constcl::read $port] $env
}
\end{lstlisting}

\subsection{p procedure}
\label{p-procedure}
\index{p procedure}

\texttt{p} only parses the input, returning an expression object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{p (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::p {str} {
  ::constcl::parse $str
}
\end{lstlisting}

\subsection{e procedure}
\label{e-procedure}
\index{e procedure}

\texttt{e} is another single-action procedure, evaluating an expression and returning a value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{e (internal)}} \\
expr & an expression \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::e {expr {env ::constcl::global_env}} {
  ::constcl::eval $expr $env
}
\end{lstlisting}

\subsection{w procedure}
\label{w-procedure}
\index{w procedure}

\texttt{w} is the third single-action procedure, printing a value and that's all.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{w (internal)}} \\
val & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::w {val} {
  ::constcl::write $val
}
\end{lstlisting}

\subsection{r procedure}
\label{r-procedure}
\index{r procedure}

\texttt{r} is an extra single-action procedure, reading from default input or from a port and returning an expression object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{r (internal)}} \\
?port? & an input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::r {args} {
  ::constcl::read {*}$args
}
\end{lstlisting}

\subsection{prw procedure}
\label{prw-procedure}
\index{prw procedure}

\texttt{prw} reads an expression, resolves defines, and writes the result. It was handy during the time I was porting the `resolve local defines' section.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{prw (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::prw {str} {
  set expr [::constcl::parse $str]
  set expr [::constcl::resolve-local-defines \
    [::constcl::cdr $expr]]
  ::constcl::write $expr
}
\end{lstlisting}

\subsection{pxw procedure}
\label{pxw-procedure}
\index{pxw procedure}

\texttt{pxw} attempts to macro-expand whatever it reads, and writes the result.\footnote{I do know that 'expand' doesn't start with an 'x'.} Again, this command's heyday was when I was developing the macro facility.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pxw (internal)}} \\
str & a Tcl string, a Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pxw {str {env ::constcl::global_env}} {
  set expr [::constcl::parse $str]
  set op [::constcl::car $expr]
  lassign [::constcl::binding-info $op $env] btype hinfo
  if {$btype eq "SYNTAX"} {
    set expr [$hinfo $expr $env]
    ::constcl::write $expr
  } else {
    ::error "not a macro"
  }
}
\end{lstlisting}

\section{Some small classes}
\label{some-small-classes}
\index{some small classes}

\subsection{Base class}
\label{base-class}
\index{Base class}

The \texttt{Base} class is base class for most of the type classes.

\begin{lstlisting}
catch { ::constcl::Base destroy }

oo::abstract create ::constcl::Base {
\end{lstlisting}

The \texttt{mkconstant} method is a dummy method that can be called when the instance is part of an immutable structure. Classes that change their state when this method is called will override it.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) mkconstant (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method mkconstant {} {}
\end{lstlisting}

The \texttt{write} method is used by the \texttt{write} standard procedure to print the external representation of an instance.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) write (internal)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method write {port} {
    $port put [my tstr]
  }
\end{lstlisting}

The \texttt{display} method is used by the \texttt{display} standard procedure to print the external representation or a human-readable version of an instance. In the latter case the method will be overridden.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) display (internal)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method display {port} {
    my write $port
  }
\end{lstlisting}

The \texttt{show} method yields the external representation of the instance as a string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) show (internal)}} \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method show {} {
    ::constcl::MkString [my tstr]
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the instance as a Tcl string. It is used by error messages and the \texttt{write} method. Should be overridden by a concrete class.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return "#<base>"
  }
\end{lstlisting}

The \texttt{unknown} method responds to calls to undefined methods. It produces a suitable error message.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) unknown (internal)}} \\
name & a Tcl string \\
args & some arguments \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method unknown {name args} {
    switch $name {
      car - cdr - set-car! -
      set-cdr {
        ::error "PAIR expected"
      }
      numval {
        ::error "NUMBER expected"
      }
    }
  }
}
\end{lstlisting}

\subsection{Dot class}
\label{dot-class}
\index{Dot class}

The \texttt{Dot} class is a helper class for the parser.

\begin{lstlisting}
oo::class create ::constcl::Dot {
  superclass ::constcl::Base
  method tstr {} {
    format "."
  }
}
\end{lstlisting}

\subsection{dot? procedure}
\label{dot-procedure}
\index{dot? procedure}

\texttt{dot?} is a type predicate that checks for membership in the type \texttt{Dot}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{dot? (internal)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::dot? {val} {
  typeof? $val "Dot"
}
\end{lstlisting}

\subsection{EndOfFile class}
\label{endoffile-class}
\index{EndOfFile class}

The \texttt{EndOfFile} class is for end-of-file\index{end of file} conditions.

\begin{lstlisting}
oo::singleton create ::constcl::EndOfFile {
  superclass ::constcl::Base
  method tstr {} {
    format "#<end-of-file>"
  }
}
\end{lstlisting}

\subsection{eof? procedure}
\label{eof-procedure}
\index{eof? procedure}

\texttt{eof?} is a type predicate that recognizes the end-of-file object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{eof? (internal)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc eof? {val} {
  if {$val eq ${::#EOF}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{NIL class}
\label{nil-class}
\index{NIL class}

The \texttt{NIL} class has one instance: the empty list called \texttt{\#NIL}.

\begin{lstlisting}
oo::singleton create ::constcl::NIL {
  superclass ::constcl::Base
  method tstr {} {
    return "()"
  }
}
\end{lstlisting}

\subsection{null? procedure}
\label{null-procedure}
\index{null? procedure}

The \texttt{null?} standard predicate recognizes the empty list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{null? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg null?

proc ::constcl::null? {val} {
  if {$val eq ${::#NIL}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{Undefined class}
\label{undefined-class}
\index{Undefined class}

The \texttt{Undefined} class is for undefined things. It was created to facilitate porting of code from `Scheme 9 from Empty Space'\index{S9fES}.

\begin{lstlisting}
oo::singleton create ::constcl::Undefined {
  superclass ::constcl::Base
  method tstr {} {
    format "#<undefined>"
  }
}
\end{lstlisting}

\subsection{Unspecified class}
\label{unspecified-class}
\index{Unspecified class}

The \texttt{Unspecified} class is for unspecified things. Also a S9fES support class.

\begin{lstlisting}
oo::singleton create ::constcl::Unspecified {
  superclass ::constcl::Base
  method tstr {} {
    format "#<unspecified>"
  }
}
\end{lstlisting}

\chapter{Input}
\label{input}

The first thing an interpreter must be able to do is to take in the user's code and data input\index{input}, whether from the keyboard or from a source file. The procedure \texttt{read} represents the interpreter's main input facility. \texttt{read} and its sub-procedures read from standard input, or--if a port is provided--from the port's channel.

The main input procedures, \texttt{read} and the non-standard \texttt{parse}, do more than just read in the text of code and data: they also \emph{parse} the input into an \emph{internal representation} that the evaluator can use.

\section{The parsing process}
\label{the-parsing-process}
\index{the parsing process}

Parsing\footnote{See \texttt{https://en.wikipedia.org/wiki/Parsing}}\index{parsing}, or syntactic analysis, is analyzing a sequence of letters, digits, and other characters, a piece of text conforming to the rules of \emph{external representation}\index{external representation}. The result of parsing is an \emph{expression}\index{expression} in \emph{internal representation}.

\subsection{External representation}
\label{external-representation}
\index{external representation}

The external representation is a 'recipe' for an expression that expresses it in a unique way.

For example, the external representation for a vector is a pound sign (\texttt{\#}), a left parenthesis (\texttt{(}), the external representation for some values, and a right parenthesis (\texttt{)}). When the reader/parser is working its way through input, a \texttt{\#(} symbol signals that a vector structure is being read. A number of subexpressions for the elements of the vector follow, and then a closing parenthesis \texttt{)} signals that the vector is done. The elements are saved in vector memory and the vector gets the address to the first element and the number of elements.

\includegraphics{images/vector-representation.png}

The \texttt{parse} or \texttt{read} procedure takes in input character by character, matching each character against a fitting external representation. When done, it creates a ConsTcl object, which is the internal representation of an expression. The object can then be passed to the evaluator.

Example:

\begin{verbatim}
% ::constcl::parse "(+ 2 3)"
::oo::Obj491
\end{verbatim}

Here, \texttt{parse} parsed the external representation of a list with three elements, +, 2, and 3. It produced the expression that has an internal representation labeled \texttt{::oo::Obj491}. I will now reach briefly into the following chapters and present procedures like \texttt{eval}, which transforms an expression into a value, and \texttt{write}, which writes a printed external representation of expressions and values. Putting them together we can see

\begin{verbatim}
% ::constcl::write ::oo::Obj491
(+ 2 3)
% ::constcl::eval ::oo::Obj491
::oo::Obj494
% ::constcl::write ::oo::Obj494
5
\end{verbatim}

Fortunately, we don't \emph{have} to work at such a low level. We can use the \texttt{repl}\index{repl} instead:

\begin{verbatim}
ConsTcl> (+ 2 3)
5
\end{verbatim}

Then, parsing and evaluation and writing goes on in the background and the internal representations of expressions and values are hidden.

Anyway, the figure shows what it really looks like. \texttt{::oo::Obj491} was just the head of the list.

\begin{figure}[h!]\includegraphics{images/intreplist.png}\captionsetup{labelformat=empty}\caption{The internal structure of the expression}\label{fig:the-internal-structure-of-the-expression}\end{figure}

\section{Input procedures}
\label{input-procedures}
\index{input procedures}

\begin{pulledtext}

\subsubsection{Ports}
\label{ports}
\index{Ports}

Ports are an abstraction of the input or output mechanism. An input port can be connected to standard input (the keyboard) or a file opened for input or a string input buffer where the complete available input is laid out before reading starts. Regardless of what kind of input port it is, one can read characters from it until it runs out and signals end-of-file. Likewise, an output port, regardless of whether it's the standard output--the screen--or a file opened for output, will receive characters sent to it.
\end{pulledtext}

\subsection{parse procedure}
\label{parse-procedure}
\index{parse procedure}

\texttt{parse} can be called with either a string input port or a Tcl or ConsTcl string (which it uses to open a string input port). Once the input port is established, \texttt{parse} leaves control to \texttt{read-expr} (see page \pageref{readexpr-procedure}).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{parse (internal)}} \\
inp & a Tcl string, a Lisp string, or a string input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg parse

proc ::constcl::parse {inp} {
  set c {}
  set unget {}
  if {[info object isa object $inp]} {
    if {[T [typeof? $inp StringInputPort]]} {
      set port $inp
    } elseif {[T [typeof? $inp String]]} {
      set port [MkStringInputPort [$inp value]]
    } else {
      ::error "Unknown object [$inp tstr]"
    }
  } else {
    # It's a Tcl string, we hope
    set port [MkStringInputPort $inp]
  }
  set oldport $::constcl::Input_port
  set ::constcl::Input_port $port
  set expr [read-expr]
  set ::constcl::Input_port $oldport
  return $expr
}
\end{lstlisting}

\subsection{read procedure}
\label{read-procedure}
\index{read procedure}

The standard builtin \texttt{read} reads an input port the same way that \texttt{parse} does, but one can't pass a string to it.

One can pass a port to \texttt{read} (including a string input port) in which case \texttt{read} sets the standard input port temporarily to the provided port. If not, \texttt{read} uses the default standard input port (usually the keyboard\footnote{which doesn't work in a Windows windowing environment, e.g. wish or tkcon. repl does work in those, though. Input works in tclsh on Windows.}).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read (public)}} \\
?port? & an input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg read

proc ::constcl::read {args} {
  set c {}
  set unget {}
  set oldport $::constcl::Input_port
  if {[llength $args]} {
    lassign $args port
    set ::constcl::Input_port $port
  }
  set expr [read-expr]
  set ::constcl::Input_port $oldport
  return $expr
}
\end{lstlisting}

\section{Input helper procedures}
\label{input-helper-procedures}
\index{input helper procedures}

Some utility procedures which are used by the reader/parser procedures.

\subsection{make-constant procedure}
\label{makeconstant-procedure}
\index{make-constant procedure}

The \texttt{make-constant} helper procedure is called to set expressions to constants when read as a literal.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-constant (internal)}} \\
val & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-constant {val} {
  if {[T [pair? $val]]} {
    $val mkconstant
    make-constant [car $val]
    make-constant [cdr $val]
  } elseif {[T [null? $val]]} {
    return
  } else {
    $val mkconstant
    return
  }
}
\end{lstlisting}

\subsection{interspace? procedure}
\label{interspace-procedure}
\index{interspace? procedure}

The \texttt{interspace?} helper procedure recognizes whitespace between value representations.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{interspace? (internal)}} \\
c & a Tcl character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::interspace? {c} {
  if {[::string is space $c]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{delimiter? procedure}
\label{delimiter-procedure}
\index{delimiter? procedure}

The \texttt{delimiter?} helper procedure recognizes delimiter characters between value representations.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{delimiter? (internal)}} \\
c & a Tcl character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::delimiter? {c} {
  if {$c in {( ) ; \" ' ` | [ ] \{ \}}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{valid-char? procedure}
\label{validchar-procedure}
\index{valid-char? procedure}

The \texttt{valid-char?} helper procedure compares a potential character constant to the valid kinds.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{valid-char? (internal)}} \\
name & a Tcl string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::valid-char? {name} {
  if {[regexp {(?i)^#\\([[:graph:]]|space|newline)$} \
      $name]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{readchar procedure}
\label{readchar-procedure}
\index{readchar procedure}

\texttt{readchar} reads one character from the \texttt{unget} store if it isn't empty or else from the input port. If the input is at end-of-file, an \texttt{\#EOF} object is returned. Shares the variable \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{readchar (internal)}} \\
\textit{Returns:} & a Tcl character or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::readchar {} {
  upvar unget unget
  if {$unget ne {}} {
    set c $unget
    set unget {}
  } else {
    set c [$::constcl::Input_port get]
    if {[$::constcl::Input_port eof]} {
      return #EOF
    }
  }
  return $c
}
\end{lstlisting}

\subsection{find-char? procedure}
\label{findchar-procedure}
\index{find-char? procedure}

\texttt{find-char?} reads ahead through whitespace to find a given character. It returns \texttt{\#t} if it has found the character, and \texttt{\#f} if it has stopped at some other character. Sets \texttt{unget} to the character it stopped at. Returns end of file if eof is encountered. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{find-char? (internal)}} \\
char & a Tcl character \\
\textit{Returns:} & a boolean or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::find-char? {char} {
  upvar c c unget unget
  # start with stored c
  while {[::string is space -strict $c]} {
    # this order seems strange but works
    set c [readchar]
    read-eof $c
    set unget $c
  }
  expr {($c eq $char) ? ${::#t} : ${::#f}}
}
\end{lstlisting}

\subsection{read-end? procedure}
\label{readend-procedure}
\index{read-end? procedure}

\texttt{read-end?} reads one character and returns \texttt{\#t} if it is an interspace character or a delimiter character, or \texttt{\#EOF} if at end of file. Otherwise it returns \texttt{\#f}. It ungets the character before returning, unless the character was interspace or end-of-file. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-end? (internal)}} \\
\textit{Returns:} & a boolean or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-end? {} {
  upvar c c unget unget
  set c [readchar]
  if {[T [interspace? $c]]} {
    return ${::#t}
  } elseif {[T [delimiter? $c]]} {
    set unget $c
    return ${::#t}
  } elseif {$c eq "#EOF"} {
    return #EOF
  } else {
    set unget $c
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{skip-ws procedure}
\label{skipws-procedure}
\index{skip-ws procedure}

\texttt{skip-ws} skips whitespace and comments (the \texttt{;} to end of line kind). It leaves the first character not to be skipped in \texttt{c} and also ungets it. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{skip-ws (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::skip-ws {} {
  upvar c c unget unget
  while true {
    switch -regexp $c {
      {[[:space:]]} {
        set c [readchar]
      }
      {;} {
        while {$c ne "\n" && $c ne "#EOF"}  {
          set c [readchar]
        }
      }
      default {
        set unget $c
        return
      }
    }
  }
}
\end{lstlisting}

\subsection{read-eof procedure}
\label{readeof-procedure}
\index{read-eof procedure}

\texttt{read-eof} checks a number of presumed characters for possible end-of-file objects. If it finds one, it returns \emph{from its caller} with the EOF value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-eof (internal)}} \\
chars & some characters \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-eof {args} {
  set chars $args
  foreach char $chars {
    if {$char eq "#EOF"} {
      return -level 1 -code return #EOF
    }
  }
}
\end{lstlisting}

\section{Reader procedures}
\label{reader-procedures}
\index{reader procedures}

The \texttt{read-} procedures parse their input and produce ConsTcl objects.

Reader procedures specialize in reading a certain kind of input, except for \texttt{read-expr} which reads them all (with a little help).

\subsection{read-expr procedure}
\label{readexpr-procedure}
\index{read-expr procedure}

The \texttt{read-expr} procedure reads the first available character from the input port. Based on that character it delegates to one of the more detailed readers, producing an expression of the corresponding kind. A Tcl character value can be passed to it: that character will be used first before reading from the input. If end of file is encountered before an expression can be read in full, the procedure returns end of file (\texttt{\#EOF})\index{end of file}. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-expr (internal)}} \\
?char? & a Tcl character \\
\textit{Returns:} & an expression or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-expr {args} {
  upvar c c unget unget
  if {[llength $args]} {
    lassign $args c
  } else {
    set c [readchar]
  }
  set unget {}
  read-eof $c
  if {[::string is space $c] || $c eq ";"} {
    skip-ws
    read-eof $c
  }
  switch -regexp $c {
    {\"}          { read-string-expr }
    {\#}          { read-pound }
    {\'}          { read-quoted-expr }
    {\(}          { read-pair-expr ")" }
    {\+} - {\-}   { read-plus-minus $c }
    {\,}          { read-unquoted-expr }
    {\.} {
        set x [Dot new]; set c [readchar]; set x
    }
    {\:}          { read-object-expr }
    {\[}          { read-pair-expr "\]" }
    {\`}          { read-quasiquoted-expr }
    {\d}          { read-number-expr $c }
    {^$}          { return #EOF }
    {[[:graph:]]} { read-identifier-expr $c }
    default {
      read-eof $c
      ::error "unexpected character ($c)"
    }
  }
}
\end{lstlisting}

\subsection{read-character-expr procedure}
\label{readcharacterexpr-procedure}
\index{read-character-expr procedure}

\texttt{read-character-expr} is activated by \texttt{read-pound} when that procedure finds a backslash in the input stream (pound-backslash is the external representation prefix for characters). It reads one or more characters to produce a character expression and return a Char object (see page \pageref{characters}). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-character-expr (internal)}} \\
\textit{Returns:} & a character or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-character-expr {} {
  upvar c c unget unget
  set name "#\\"
\end{lstlisting}

A character name can be one or more characters long. Accept the first character if it is a graphic character.

\begin{lstlisting}
  set c [readchar]
  read-eof $c
  if {[::string is graph $c]} {
    ::append name $c
\end{lstlisting}

Keep adding to the name as long as the input is an alphabetic character.

\begin{lstlisting}
    set c [readchar]
    while {[::string is alpha $c]} {
      ::append name $c
      set c [readchar]
    }
  }
\end{lstlisting}

Check if we have a valid character name.

\begin{lstlisting}
  check {valid-char? $name} {
      Invalid character constant $name
  }
\end{lstlisting}

Make and return a character object.

\begin{lstlisting}
  set expr [MkChar $name]
  read-eof $expr
  return $expr
}
\end{lstlisting}

\subsection{read-identifier-expr procedure}
\label{readidentifierexpr-procedure}
\index{read-identifier-expr procedure}

\texttt{read-identifier-expr} is activated for 'anything else', and takes in characters until it finds whitespace or a delimiter character. If it is passed one or more characters it will use them before consuming any from input. It checks the input against the rules for identifiers, accepting or rejecting it with an error message. It returns a Symbol object (see page \pageref{symbols}). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-identifier-expr (internal)}} \\
?chars? & some Tcl characters \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-identifier-expr {args} {
  upvar c c unget unget
  set unget {}
\end{lstlisting}

If one or more characters have been passed to the procedure, join them together and store them in \texttt{c}. Otherwise, read a character from input.

\begin{lstlisting}
  if {[llength $args]} {
    set c [join $args {}]
  } else {
    set c [readchar]
  }
  read-eof $c
  set name {}
\end{lstlisting}

Add the contents of \texttt{c} to \texttt{name} as long as the character is graphic and not a delimiter or \texttt{\#EOF}.

\begin{lstlisting}
  while {[::string is graph -strict $c]} {
    if {$c eq "#EOF" || [T [delimiter? $c]]} {
      break
    }
    ::append name $c
    set c [readchar]
    # do not check for EOF here
  }
\end{lstlisting}

If the last character read is a delimiter, unget it.

\begin{lstlisting}
  if {[T [delimiter? $c]]} {
    set unget $c
  }
\end{lstlisting}

Check if the name is a valid identifier, and create and return a symbol object.

\begin{lstlisting}
  # idcheck throws error if invalid identifier
  idcheck $name
  return [S $name]
}
\end{lstlisting}

\subsection{read-number-expr procedure}
\label{readnumberexpr-procedure}
\index{read-number-expr procedure}

\texttt{read-number-expr} reads numerical input, both integers and floating point numbers. It is activated by \texttt{read-expr} or \texttt{read-plus-minus} if they encounter digits, and it actually takes in anything that at least starts out like a number. It stops at whitespace or a delimiter character, and then it accepts or rejects the input by comparing it to a Tcl double. It returns a Number object (see page \pageref{numbers}). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-number-expr (internal)}} \\
?char? & a Tcl character \\
\textit{Returns:} & a number or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-number-expr {args} {
  upvar c c unget unget
  set unget {}
\end{lstlisting}

If a character has been passed to the procedure, store it in \texttt{c}. Otherwise, read a character from input.

\begin{lstlisting}
  if {[llength $args]} {
    lassign $args c
  } else {
    set c [readchar]
  }
  read-eof $c
\end{lstlisting}

Add the contents of \texttt{c} to \texttt{num} as long as the character isn't space, \texttt{\#EOF}, or a delimiter.

\begin{lstlisting}
  while {![T [interspace? $c]] && $c ne "#EOF" &&
      ![T [delimiter? $c]]} {
    ::append num $c
    set c [readchar]
  }
\end{lstlisting}

If the last character read is a delimiter, unget it.

\begin{lstlisting}
  if {[T [delimiter? $c]]} {
    set unget $c
  }
\end{lstlisting}

Check if the contents of \texttt{num} is a valid number, and create and return a number object.

\begin{lstlisting}
  check {::string is double -strict $num} {
      Invalid numeric constant $num
  }
  set expr [N $num]
  return $expr
}
\end{lstlisting}

\subsection{read-object-expr procedure}
\label{readobjectexpr-procedure}
\index{read-object-expr procedure}

A non-standard extension, \texttt{read-object-expr} reads a ConsTcl object of any kind and passes its name along. It is activated when \texttt{read-expr} finds a colon in the input. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-object-expr (internal)}} \\
\textit{Returns:} & a ConsTcl object or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-object-expr {} {
  upvar c c unget unget
  # first colon has already been read
  foreach ch [split ":oo::Obj" {}] {
    set c [readchar]
    read-eof $c
    if {$c ne $ch} {
      error "bad object name"
    }
  }
  set res "::oo::Obj"
  set c [readchar]
  read-eof $c
  while {[::string is digit $c]} {
    ::append res $c
    set c [readchar]
    read-eof $c
  }
  set unget $c
  return $res
}
\end{lstlisting}

\subsection{read-pair-expr procedure}
\label{readpairexpr-procedure}
\index{read-pair-expr procedure}

The \texttt{read-pair-expr} procedure reads everything between two matching parentheses, or, as the case might be, brackets. It produces either an empty list, or a possibly recursive structure of Pair objects (see page \pageref{pairs-and-lists}), either a proper list (one that ends in \texttt{NIL}), or an improper one (one that has an atom as its last member). Note that \texttt{read-pair-expr} can't read a cyclic improper list. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\begin{figure}[h!]\includegraphics{images/prop-improp.png}\captionsetup{labelformat=empty}\caption{A proper list and two improper ones.}\label{fig:a-proper-list-and-two-improper-ones}\end{figure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-pair-expr (internal)}} \\
char & the terminating paren or bracket \\
\textit{Returns:} & a structure of pair expressions or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-pair-expr {char} {
  upvar c c unget unget
  set unget {}
  set expr [read-pair $char]
  read-eof $expr
  if {$c ne $char} {
    if {$char eq ")"} {
      ::error \
        "Missing right paren. ($c)."
    } else {
      ::error \
        "Missing right bracket ($c)."
    }
  } else {
    set unget {}
    set c [readchar]
  }
  return $expr
}
\end{lstlisting}

\textbf{read-pair} procedure

\texttt{read-pair} is a helper procedure that does the heavy lifting in reading a pair structure. First it checks if the list is empty, returning \texttt{NIL} in that case. Otherwise it reads the first element in the list and then repeatedly the rest of them. If it reads a Dot object, the following element to be read is the tail end of an improper list. When \texttt{read-pair} has reached the ending parenthesis or bracket, it ``conses up'' the elements starting from the last, and returns the head of the list. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-pair (internal)}} \\
char & the terminating paren or bracket \\
\textit{Returns:} & a structure of pair expressions or end of file \\
\hline
\end{tabular}
\index{read-pair}

\begin{lstlisting}
proc ::constcl::read-pair {char} {
  upvar c c unget unget
\end{lstlisting}

If the first non-space character is the ending parenthesis or bracket, return an empty list.

\begin{lstlisting}
  set c [readchar]
  read-eof $c
  if {[T [find-char? $char]]} {
    return ${::#NIL}
  }
\end{lstlisting}

Read an expression and put it in the result list. Tentatively set the end of the list to \texttt{\#NIL}.

\begin{lstlisting}
  set a [read-expr $c]
  set res $a
  skip-ws
  set prev ${::#NIL}
\end{lstlisting}

As long as the ending parenthesis or bracket isn't found, read an expression into \texttt{x}. If it is a dot, read another expression and set the end of the list to it. Otherwise, append the expression in \texttt{x} to the result list.

\begin{lstlisting}
  while {![T [find-char? $char]]} {
    set x [read-expr $c]
    skip-ws
    read-eof $c
    if {[T [dot? $x]]} {
      set prev [read-expr $c]
      skip-ws
      read-eof $c
    } else {
      lappend res $x
    }
  }
\end{lstlisting}

Reverse the result list and construct pairs from each item and the current end of the list. Return the final end of the list.

\begin{lstlisting}
  foreach r [lreverse $res] {
    set prev [cons $r $prev]
  }
  return $prev
}
\end{lstlisting}

\subsection{read-plus-minus procedure}
\label{readplusminus-procedure}
\index{read-plus-minus procedure}

\texttt{read-plus-minus} is called when a plus or minus is found in the input stream. The plus or minus character is passed to it. If the next character is a digit, it delegates to the number reader. If it is a space character or a delimiter, it returns a \texttt{+} or \texttt{-} symbol. Otherwise, it delegates to the identifier reader. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-plus-minus (internal)}} \\
char & a Tcl character \\
\textit{Returns:} & either the symbols + or - or a number or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-plus-minus {char} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
\end{lstlisting}

If the first character read is a digit, read a number. If the character passed to the procedure was a minus sign, make the number negative.

\begin{lstlisting}
  if {[::string is digit -strict $c]} {
    set expr [read-number-expr $c]
    read-eof $expr
    if {$char eq "-"} {
      set expr [- $expr]
    }
    return $expr
\end{lstlisting}

If the first character read is a space or delimiter character, return a \texttt{+} or \texttt{-} symbol, depending on the character passed to the procedure.

\begin{lstlisting}
  } elseif {[T [interspace? $c]] ||
      [T [delimiter? $c]]} {
    if {$char eq "+"} {
      return [S "+"]
    } else {
      return [S "-"]
    }
\end{lstlisting}

Otherwise, read an identifier.

\begin{lstlisting}
  } else {
    set expr [read-identifier-expr $char $c]
    read-eof $expr
    return $expr
  }
}
\end{lstlisting}

\subsection{read-pound procedure}
\label{readpound-procedure}
\index{read-pound procedure}

\texttt{read-pound} is activated by \texttt{read-expr} when it reads a pound sign (\texttt{\#}). It in turn either delegates to the vector or character reader, or returns boolean literals. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-pound (internal)}} \\
\textit{Returns:} & a vector, boolean, or character value or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-pound {} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
  switch $c {
    (    { set expr [read-vector-expr] }
    t    { if {[T [read-end?]]} {set expr ${::#t}} }
    f    { if {[T [read-end?]]} {set expr ${::#f}} }
    "\\" { set expr [read-character-expr] }
    default {
      ::error "Illegal #-literal: #$c"
    }
  }
  return $expr
}
\end{lstlisting}

\subsection{read-quasiquoted-expr procedure}
\label{readquasiquotedexpr-procedure}
\index{read-quasiquoted-expr procedure}

\texttt{read-quasiquoted-expr} is activated when there is a backquote (\texttt{`}) in the input stream. It reads an entire expression and returns it wrapped in \texttt{quasiquote}. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-quasiquoted-expr (internal)}} \\
\textit{Returns:} & an expr. wr. in the quasiquote symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-quasiquoted-expr {} {
  upvar c c unget unget
  set unget {}
  set expr [read-expr]
  read-eof $expr
  make-constant $expr
  return [list [S quasiquote] $expr]
}
\end{lstlisting}

\subsection{read-quoted-expr procedure}
\label{readquotedexpr-procedure}
\index{read-quoted-expr procedure}

\texttt{read-quoted-expr} is activated by \texttt{read-expr} when reading a single quote ('). It then reads an entire expression beyond that, returning it wrapped in a list with \texttt{quote}. The quoted expression is made constant. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-quoted-expr (internal)}} \\
\textit{Returns:} & an expression wrapped in the quote symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-quoted-expr {} {
  upvar c c unget unget
  set unget {}
  set expr [read-expr]
  read-eof $expr
  make-constant $expr
  return [list [S quote] $expr]
}
\end{lstlisting}

\subsection{read-string-expr procedure}
\label{readstringexpr-procedure}
\index{read-string-expr procedure}

\texttt{read-string-expr} is activated by \texttt{read-expr} when it reads a double quote. It collects characters until it reaches another (unescaped) double quote. To have double quotes in the string, escape them with backslash (which also means that backslashes have to be escaped with backslash). A backslash+n pair of characters denotes a newline (this is an extension). It then returns a string expression--an immutable String object (see page \pageref{strings}). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-string-expr (internal)}} \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-string-expr {} {
  upvar c c unget unget
  set str {}
  set c [readchar]
  read-eof $c
\end{lstlisting}

As long as the input isn't a double quote or end-of-file, add it to \texttt{str}.

\begin{lstlisting}
  while {$c ne "\"" && $c ne "#EOF"} {
\end{lstlisting}

If the input is a backslash, add it to \texttt{str} and read another character. In this way escaped double quotes are bypassed.

\begin{lstlisting}
    if {$c eq "\\"} {
      ::append str $c
      set c [readchar]
      read-eof $c
    }
    ::append str $c
    set c [readchar]
  }
\end{lstlisting}

If the last read character is end-of-file, the ending double quote was missing.

\begin{lstlisting}
  if {$c eq "#EOF"} {
    error "bad string (no ending double quote)"
  }
  set c [readchar]
\end{lstlisting}

Create and return an immutable string object.

\begin{lstlisting}
  set expr [MkString $str]
  make-constant $expr
  return $expr
}
\end{lstlisting}

\subsection{read-unquoted-expr procedure}
\label{readunquotedexpr-procedure}
\index{read-unquoted-expr procedure}

When a comma is found in the input stream, \texttt{read-unquoted-expr} is activated. If it reads an at-sign (\texttt{@}) it selects the symbol \texttt{unquote-splicing}, otherwise it selects the symbol \texttt{unquote}. Then it reads an entire expression and returns it wrapped in the selected symbol. Both of these expressions are only supposed to occur inside a quasiquoted expression. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-unquoted-expr (internal)}} \\
\textit{Returns:} & an expr. wr. in the unquote/-splicing symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-unquoted-expr {} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
  if {$c eq "@"} {
    set symbol "unquote-splicing"
    set expr [read-expr]
  } else {
    set symbol "unquote"
    set expr [read-expr $c]
  }
  read-eof $expr
  return [list [S $symbol] $expr]
}
\end{lstlisting}

\subsection{read-vector-expr procedure}
\label{readvectorexpr-procedure}
\index{read-vector-expr procedure}

\texttt{read-vector-expr} is activated by \texttt{read-pound}. It reads a number of expressions until it finds an ending parenthesis. It produces a vector expression and returns a Vector object (see page \pageref{vectors}). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{read-vector-expr (internal)}} \\
\textit{Returns:} & a vector or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-vector-expr {} {
  upvar c c unget unget
  set res {}
  set last {}
  set c [readchar]
  while {$c ne "#EOF" && $c ne ")"} {
\end{lstlisting}

Read an expression, put it in an element constructed as a pair with the expression and \texttt{\#NIL}, and affix the element to the result list.

\begin{lstlisting}
    set e [read-expr $c]
    read-eof $e
    set elem [cons $e ${::#NIL}]
    if {$res eq {}} {
      set res $elem
    } else {
      set-cdr! $last $elem
    }
    set last $elem
    skip-ws
    read-eof $c
  }
\end{lstlisting}

Report missing ending parenthesis.

\begin{lstlisting}
  if {$c ne ")"} {
    ::error "Missing right paren. ($c)."
  }
  set unget {}
  set c [readchar]
\end{lstlisting}

Create and return an immutable vector object.

\begin{lstlisting}
  set expr [MkVector $res]
  $expr mkconstant
  return $expr
}
\end{lstlisting}

\chapter{Evaluation}
\label{evaluation}

The second thing an interpreter must be able to do is to \emph{evaluate}\index{eval}\index{evaluate} expressions, that is reduce them to \emph{normal form}. As an example, 2 + 6 and 8 are two expressions that have the same value, but the latter is in normal form (can't be reduced further) and the former is not.

To be able to evaluate every kind of expression, a structured approach is needed. Lisp has nine syntactic forms, each with its own syntax, and each with its own process of evaluation.

\begin{description}
\item[variable reference] Syntax: a symbol. Process: variable lookup (see page \pageref{variable-reference}).
\item[constant literal] Syntax: a string, character, boolean, or number. Process: take the value (see page \pageref{constant-literal}).
\item[quotation] Syntax: \texttt{(quote datum)}. Process: take the datum (see page \pageref{quotation}).
\item[conditional] Syntax: \texttt{if}, \texttt{case}, or \texttt{cond} expression. Process: depends on which syntax (see page \pageref{conditional}).
\item[sequence] Syntax: \texttt{(begin expression \ldots )}. Process: evaluate all expressions, take value of the last (see page \pageref{sequence}).
\item[definition] Syntax: \texttt{(define var val)}. Process: bind a variable to a location, store the value there (see page \pageref{definition}).
\item[assignment] Syntax: \texttt{(set! var val)}. Process: take a bound variable, store the value to its location (see page \pageref{assignment}).
\item[procedure definition] Syntax: \texttt{(lambda formals body)}. Process: take formals and body and apply lambda to get a procedure value (see page \pageref{procedure-definition}).
\item[procedure call] Syntax: \texttt{(operator operand \ldots )}. Process: invoke operator on operands (see page \pageref{procedure-call}).
\end{description}

The evaluator recognizes the syntax of the expression and chooses the appropriate process to evaluate it. How this happens for the nine syntactic forms will be described in the following sections.

A word about \emph{environments}: an environment is where evaluating code keeps track of things. This is why most of the procedures in this chapter get a reference to an environment when they are called. More about environments very soon (see page \pageref{environments}).

\section{Variable reference}
\label{variable-reference}
\index{variable reference}

\emph{Example: \texttt{r} $\Rightarrow$ 10 (a symbol \texttt{r} is evaluated to what it's bound to)}

A variable\index{variable} is about a symbol, a location in the environment, and a value. The symbol is \emph{bound}\index{bound symbol} to the location, and the value is stored there. When an expression consists of the symbol, the evaluator does \emph{lookup} and finds the value.

This is handled by the helper procedure \texttt{lookup}. It (or rather, the helper function \texttt{binding-info}, which it calls) searches the environment chain (see page \pageref{environments}) for the symbol, and returns the value stored in the location it is bound to. It is an error to do lookup on an unbound symbol, or a symbol that is bound for some other purpose, such as being a keyword or a macro.

Syntax: \emph{symbol}

\subsection{lookup procedure}
\label{lookup-procedure}
\index{lookup procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{lookup (internal)}} \\
sym & a symbol \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::lookup {sym env} {
  lassign [binding-info $sym $env] type value
  if {$type eq "VARIABLE"} {
    return $value
  } else {
    error "not a variable name" $sym
  }
}
\end{lstlisting}

\section{Constant literal}
\label{constant-literal}
\index{constant literal}

\emph{Example: \texttt{99} $\Rightarrow$ 99 (a number evaluates to itself)}

Not just numbers but booleans, characters, and strings evaluate to themselves, to their innate value. Because of this, they are called self-evaluating or autoquoting types (see next section).

Syntax: \emph{number} | \emph{string} | \emph{character} | \emph{boolean}

\textbf{self-evaluating?} procedure

Only numeric, string, character, and boolean constants evaluate to themselves. This procedure returns \texttt{\#t} if the given value is a self-evaluating value, and \texttt{\#f} otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{self-evaluating? (internal)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{self-evaluating? procedure}

\begin{lstlisting}
proc ::constcl::self-evaluating? {val} {
  if {[T [number? $val]] ||
    [T [string? $val]] ||
    [T [char? $val]] ||
    [T [boolean? $val]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\section{Quotation}
\label{quotation}
\index{quotation}

\emph{Example: \texttt{(quote r)} $\Rightarrow$ \texttt{r} (quotation makes the symbol evaluate to itself, like a constant)}

According to the rules of variable reference, a symbol evaluates to its stored value. Sometimes one wishes to use the symbol itself as a value. That is partly what quotation\index{quotation} is for. \texttt{(quote x)} evaluates to the symbol \texttt{x} itself and not to any value that might be stored under it. This is so common that there is a shorthand notation for it: \texttt{'x} is interpreted as \texttt{(quote x)} by the Lisp reader (see page \pageref{reader-procedures}). The argument of \texttt{quote} may be any external representation (see page \pageref{external-representation}) of a Lisp object. In this way, for instance a vector or list constant can be introduced in the program text.

\subsection{quote special form}
\label{quote-special-form}
\index{quote special form}

Syntax: (\textbf{quote} \emph{datum})

The \texttt{quote} special form is expanded by \texttt{special-quote}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-quote (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special quote

proc ::constcl::special-quote {expr env} {
  cadr $expr
}
\end{lstlisting}

\section{Conditional}
\label{conditional}
\index{conditional}

\emph{Example: \texttt{(if (> 99 100) (* 2 2) (+ 2 4))} $\Rightarrow$ 6}

The conditional form \texttt{if} takes three expressions. The first, the \emph{condition}, is evaluated first. If it evaluates to true, i.e. anything other than the value \texttt{\#f} (false), the second expression (the \emph{consequent}) is evaluated and the value returned. Otherwise, the third expression (the \emph{alternate}) is evaluated and the value returned. One of the two latter expressions will be evaluated, and the other will remain unevaluated. The \emph{alternate} can be omitted.

\subsection{if special form}
\label{if-special-form}
\index{if special form}

Syntax: (\textbf{if} \emph{condition} \emph{consequent} ?\emph{alternate}?)

The \texttt{if} special form is expanded by \texttt{special-if}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-if (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special if

proc ::constcl::special-if {expr env} {
  set args [cdr $expr]
  if {[T [null? [cddr $args]]]} {
    if {[T [eval [car $args] $env]]} \
      {eval [cadr $args] $env}
  } else {
    if {[T [eval [car $args] $env]]} \
      {eval [cadr $args] $env} \
      {eval [caddr $args] $env}
  }
}
\end{lstlisting}

\subsection{case special form}
\label{case-special-form}
\index{case special form}

\texttt{case} is another conditional form. It implements a multi-choice where a single expression selects between alternatives. The body of the \texttt{case} form consists of a key-expression and a number of clauses. Each clause has a list of values and a body. If the key-expression evaluates to a value that occurs in one of the value-lists (considered in order), that clause's body is evaluated and all other clauses are ignored.

Syntax: (\textbf{case} \emph{key} \emph{clause} \ldots )

where each \emph{clause} has the form

((\emph{datum} \ldots ) \emph{expression} \ldots )

The last clause may have the form

(\textbf{else} \emph{expression} \ldots )

Example:

\begin{verbatim}
(case 'c
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))     ==> consonant
\end{verbatim}

The \texttt{case} special form is expanded by \texttt{special-case}. It expands to \texttt{'()} if there are no clauses (left), and to nested \texttt{if} constructs if there are some.

\textbf{special-case} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-case (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special case

proc ::constcl::special-case {expr env} {
  set tail [cdr $expr]
  set expr [do-case [car $tail] [cdr $tail] $env]
  eval $expr $env
}
\end{lstlisting}

\begin{pulledtext}

\subsubsection{caar, cadr, cdar, and the rest}
\label{caar-cadr-cdar-and-the-rest}
\index{caar, cadr, cdar, and the rest}

The \texttt{do-case} procedure uses extensions of the \texttt{car}/\texttt{cdr} operators like \texttt{caar} and \texttt{cdar}\index{car/cdr operators}. \texttt{car}/\texttt{cdr} notation gets really powerful when combined to form operators from \texttt{caar} to \texttt{cddddr}. One can read \texttt{caar L} as `the first element of the first element of L', implying that the first element of \texttt{L} is a list. \texttt{cdar L} is `the rest of the elements of the first element of L', and \texttt{cadr L} is `the first element of the rest of the elements of L' or in layman's terms, the second element of L.
\end{pulledtext}

\begin{pulledtext}

\subsubsection{Quasiquote}
\label{quasiquote}
\index{quasiquote}

In this and many other special form and macro expanders I use a quasiquote\index{quasiquote} construct to lay out how the form is to be expanded. A quasiquote starts with a backquote (\texttt{`}) instead of the single quote that precedes regular quoted material. A quasiquote allows for `unquoting' of selected parts: this is notated with a comma (\texttt{,}). \texttt{`(foo ,bar baz)} is very nearly the same as \texttt{('foo bar 'baz)}. In both cases \texttt{foo} and \texttt{baz} are constants while \texttt{bar} is a variable which will be evaluated. Like in \texttt{do-case} here, a quasiquote serves well as a templating mechanism. The variables in the quasiquote need to be a part of the environment in which the quasiquote is expanded: I use \texttt{/define} to bind them in a temporary environment.
\end{pulledtext}

\textbf{do-case} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{do-case (internal)}} \\
keyexpr & an expression \\
clauses & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-case procedure}

\begin{lstlisting}
proc ::constcl::do-case {keyexpr clauses env} {
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
\end{lstlisting}

If the length of the \emph{clauses} is greater than 0, extract a \emph{datumlist} and a \emph{body} from the first clause. Then build a \emph{predicate} of the form \texttt{(memv keyexpr (quote datumlist))}.

\begin{lstlisting}
    set datumlist [caar $clauses]
    set body [cdar $clauses]
    set predicate [list [S memv] $keyexpr \
        [list [S quote] $datumlist]]
\end{lstlisting}

If the length of the \emph{clauses} is 1, meaning that this is the last clause, and an \texttt{else} is found instead of a datumlist, set the predicate to \texttt{\#t}.

\begin{lstlisting}
    if {[T [eq? [length $clauses] [N 1]]]} {
      if {[T [eq? [caar $clauses] [S else]]]} {
        set predicate ${::#t}
      }
    }
\end{lstlisting}

Finally, build a quasiquote structure and expand it to get the expansion of the \texttt{case} expression.

\begin{lstlisting}
    set env [MkEnv $env]
    /define [S predicate] $predicate $env
    /define [S body] $body $env
    /define [S rest] [
      do-case $keyexpr [cdr $clauses] $env] $env
    set qq "`(if ,predicate
               (begin ,@body)
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{cond special form}
\label{cond-special-form}
\index{cond special form}

\texttt{cond} is the third conditional form. The \texttt{cond} form has a list of clauses, each with a predicate and a body. The clauses is considered in order, and if a predicate evaluates to something other than \texttt{\#f} the body is evaluated and the remaining clauses are ignored.

Syntax: (\textbf{cond} \emph{clause} \ldots )

where each \emph{clause} has the form

(\emph{test} \emph{expression} \ldots )

or

(\emph{test} \textbf{=>} \emph{recipient})

where \emph{recipient} is a procedure that accepts one argument, which is evaluated with the result of the predicate as argument if the predicate returns a true value.

The last clause may have the form

(\textbf{else} \emph{expression} \ldots )

Example:

\begin{verbatim}
(let ((a 3))
  (cond ((> a 3) 'greater)
        ((< a 3) 'less)
        (else 'equal)))      ==> equal
\end{verbatim}

The \texttt{cond} special form is expanded by \texttt{special-cond}. It expands to \texttt{'()} if there are no clauses (left), and to nested \texttt{if} constructs if there are some.

\textbf{special-cond} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-cond (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special cond

proc ::constcl::special-cond {expr env} {
  set expr [do-cond [cdr $expr] $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{do-cond} procedure

\texttt{do-cond} is called recursively for every clause of the \texttt{cond} form. It chops up the clause into predicate and body. In the last clause, the predicate is allowed to be \texttt{else} (which gets translated to \texttt{\#t}). If there is no body, the body is set to the predicate. The form is expanded to a recursive \texttt{if} form.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{do-cond (internal)}} \\
tail & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-cond procedure}

\begin{lstlisting}
proc ::constcl::do-cond {tail env} {
  set clauses $tail
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
\end{lstlisting}

If the length of the \emph{clauses} is greater than 0, extract a \emph{predicate} and a \emph{body} from the first clause.

\begin{lstlisting}
    set predicate [caar $clauses]
    set body [cdar $clauses]
\end{lstlisting}

If the length of the \emph{clauses} is 1, meaning that this is the last clause, and an \texttt{else} is found instead of a predicate, set the predicate to \texttt{\#t}.

\begin{lstlisting}
    if {[T [eq? [length $clauses] [N 1]]]} {
      if {[T [eq? $predicate [S else]]]} {
        set predicate ${::#t}
      }
    }
\end{lstlisting}

If there is a \texttt{=>} between the \emph{predicate} and the \emph{body}, rewrite the \emph{body} to call the \texttt{caddar} of the \emph{clauses} with the result of \emph{predicate} as argument.

\begin{lstlisting}
    if {[T [symbol? [car $body]]] &&
        [[car $body] name] eq "=>"} {
      set body [list [caddar $clauses] $predicate]
\end{lstlisting}

Otherwise, if the \emph{body} is empty, set \emph{body} to \emph{predicate}. If \emph{body} has one or more expressions, wrap them in \texttt{begin}.

\begin{lstlisting}
    } else {
      if {[[length $body] numval] == 0} {
        set body $predicate
      } else {
        set body [cons [S begin] $body]
      }
    }
\end{lstlisting}

Finally, build a quasiquote structure and expand it to get the expansion of the \texttt{cond} expression.

\begin{lstlisting}
    set env [MkEnv $env]
    /define [S predicate] $predicate $env
    /define [S body] $body $env
    /define [S rest] [
      do-cond [cdr $clauses] $env] $env
    set qq "`(if ,predicate
               ,body
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\section{Sequence}
\label{sequence}
\index{sequence}

\emph{Example: \texttt{(begin (define r 10) (* r r))} $\Rightarrow$ 100}

There are times when one wants to treat a number of expressions as if they were one single expression (e.g. in the consequent or alternate of an \texttt{if} form). The \texttt{begin} special form bundles up expressions as an aggregate form. Internally, it sees to it that all the expressions are evaluated in order and that the resulting value of the last one is returned as the aggregate's result.

As part of the processing of sequences, \emph{local defines} are resolved (see page \pageref{resolving-local-defines}), acting on expressions of the form \texttt{(begin (define \ldots } when in a local environment.

The following forms have an implicit \texttt{begin} in their bodies and the use of \texttt{begin} is therefore unnecessary with them:

\texttt{case}, \texttt{cond}, \texttt{define} (“procedure define” only), \texttt{lambda}, \texttt{let}, \texttt{let*}, \texttt{letrec}.

\subsection{begin special form}
\label{begin-special-form}
\index{begin special form}

Syntax: (\textbf{begin} \emph{expression} \ldots )

The \texttt{begin} special form is expanded by \texttt{special-begin}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-begin (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special begin

proc ::constcl::special-begin {expr env} {
  if {$env ne "::constcl::global_env" &&
    [T [pair? [cadr $expr]]] &&
    [T [eq? [caadr $expr] [S define]]]
  } then {
    set expr [resolve-local-defines $expr]
    eval $expr $env
  } else {
    /begin [cdr $expr] $env
  }
}
\end{lstlisting}

\textbf{/begin} procedure

The \texttt{/begin} helper procedure takes a Lisp list of expressions and evaluates them in sequence, returning the value of the last one.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{/begin (internal)}} \\
exps & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}
\index{/begin procedure}

\begin{lstlisting}
proc ::constcl::/begin {exps env} {
  if {[T [pair? $exps]]} {
    if {[T [pair? [cdr $exps]]]} {
      eval [car $exps] $env
      return [/begin [cdr $exps] $env]
    } else {
      return [eval [car $exps] $env]
    }
  } else {
    return [parse "'()"]
  }
}
\end{lstlisting}

\section{Definition}
\label{definition}
\index{definition}

\emph{Example: \texttt{(define r 10)} $\Rightarrow$ \ldots  (a definition doesn't evaluate to anything)}

We've already seen the relationship between symbols and values. Through (variable) definition\index{variable definition}\index{definition}, a symbol is bound to a value (or rather to the location the value is in), creating a variable. The \texttt{/define} helper procedure adds a variable to the current environment. It first checks that the symbol name is a valid identifier and that it isn't already bound in the current environment. Then it updates the environment with the new binding.

The syntaxes with \texttt{lambda} in them refer to the eight syntactic form, procedure definition (see page \pageref{procedure-definition}).

\subsection{define special form}
\label{define-special-form}
\index{define special form}

Syntax: either

(\textbf{define} \emph{variable} \emph{expression})

(\textbf{define} (\emph{variable} \emph{formals}) \emph{body})

where \emph{formals} is a proper or dotted list of identifiers; equivalent form:

(\textbf{define} \emph{variable} (\textbf{lambda} (\emph{formals}) \emph{body})).

or

(\textbf{define} (\emph{variable} . \emph{formal}) \emph{body})

where \emph{formal} is a single identifier; equivalent form:

(\textbf{define} \emph{variable} (\textbf{lambda} \emph{formal} \emph{body}))

\emph{body} should be one or more expressions.

The \texttt{define} special form is expanded by \texttt{special-define}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-define (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg special define

proc ::constcl::special-define {expr env} {
  set expr [rewrite-define $expr $env]
  set sym [cadr $expr]
  set val [eval [caddr $expr] $env]
  /define $sym $val $env
}
\end{lstlisting}

\textbf{rewrite-define} procedure

\texttt{rewrite-define} rewrites ``procedural define'' syntaxes to their equivalent forms with \texttt{lambda}, which unifies the syntaxes with (\textbf{define} \emph{variable} \emph{expression}). That syntax passes through \texttt{rewrite-define} unchanged.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rewrite-define (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-define procedure}

\begin{lstlisting}
proc ::constcl::rewrite-define {expr env} {
  if {[T [pair? [cadr $expr]]]} {
    set tail [cdr $expr]
    set env [::constcl::MkEnv $env]
    /define [S tail] $tail $env
    set qq "`(define ,(caar tail)
               (lambda ,(cdar tail) ,@(cdr tail)))"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
  }
  return $expr
}
\end{lstlisting}

\textbf{/define} procedure

The \texttt{/define} helper procedure carries out the binding of a symbol in a given environment, and stores the value in the location of binding.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{/define (internal)}} \\
sym & a symbol \\
val & a value \\
env & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}
\index{/define procedure}

\begin{lstlisting}
proc ::constcl::/define {sym val env} {
  varcheck [idcheck [$sym name]]
  # will throw an error if $sym is bound
  $env bind $sym VARIABLE $val
  return
}
\end{lstlisting}

\section{Assignment}
\label{assignment}
\index{assignment}

\emph{Example: \texttt{(set! r 20)} $\Rightarrow$ 20 (\texttt{r} is a bound symbol, so it's allowed to assign to it)}

Once again we consider the relationship of a symbol, an environment, and a value. Once a symbol is bound to a location in the environment, the value at that location can be changed with reference to the symbol, altering the value of the variable. The process is called assignment.

It is carried out by the \texttt{set!} special form. Given a symbol and a value, it finds the symbol's binding environment and updates the location with the value. It returns the value, so calls to \texttt{set!} can be chained: \texttt{(set! foo (set! bar 99))} sets both variables to 99. By Scheme convention, procedures that modify variables have `!' at the end of their name.

It is an error to do assignment on an unbound symbol.

\subsection{set! special form}
\label{set-special-form}
\index{set"! special form}

Syntax: (\textbf{set!} \emph{variable} \emph{expression})

The \texttt{set!} special form is expanded by \texttt{special-set!}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-set! (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special set!

proc ::constcl::special-set! {expr env} {
  set args [cdr $expr]
  set var [car $args]
  set val [eval [cadr $args] $env]
  [$env find $var] assign $var VARIABLE $val
  set val
}
\end{lstlisting}

\section{Procedure definition}
\label{procedure-definition}
\index{procedure definition}

\emph{Example: \texttt{(lambda (r) (* r r))} $\Rightarrow$ \texttt{::oo::Obj3601} (it will be a different object each time)}

In Lisp, procedures are values just like numbers or characters. They can be defined\index{procedure definition} as the value of a variable, passed to other procedures, and returned from procedures. One difference from most values is that procedures need to be specified. Two questions must answered: what is the procedure meant to do? The code that does that will form the \emph{body} of the procedure. Also, which, if any, items of data (\emph{parameters}) will have to be provided to the procedure to make it possible to calculate its result?

As an example, imagine that we want to have a procedure that calculates the square (\texttt{x * x}) of a given number. In Lisp, expressions are written with the operator first and then the operands\index{operator operand order}: \texttt{(* x x)}. That is the body of the procedure. Now, what data will we have to provide to the procedure to make it work? A value stored in the variable \texttt{x} will do. It's only a single parameter, but by custom we need to put it in a list: \texttt{(x)}. The operator that creates procedures is called \texttt{lambda}\index{lambda}, and we create the function with \texttt{(lambda (x) (* x x))}.

One more step is needed before we can use the procedure. It must have a name. We could define it like this: \texttt{(define square (lambda (x) (* x x)))} but there is actually a shortcut notation for it: \texttt{(define (square x) (* x x))}.

Now, \texttt{square} is pretty tame. How about the \texttt{hypotenuse} procedure? \texttt{(define (hypotenuse a b) (sqrt (+ (square a) (square b))))}. It calculates the square root of the sum of two squares.

The \texttt{lambda} special form makes a Procedure object (see page \pageref{control}). First it needs to wrap \texttt{body} inside a \texttt{begin} (\texttt{S begin} stands for `the symbol begin'). The Lisp list \texttt{formals} (for \emph{formal parameters}) is passed on as it is.

\begin{pulledtext}

\subsubsection{Scheme formal parameters lists}
\label{scheme-formal-parameters-lists}
\index{Scheme formal parameters lists}

A Scheme formals list\index{formals list} is either:

\begin{itemize}
\item An \emph{empty list}, \texttt{()}, meaning that no arguments are accepted,
\item A \emph{proper list}, \texttt{(a b c)}, meaning it accepts three arguments, one in each symbol,
\item A \emph{symbol}, \texttt{a}, meaning that all arguments go into \texttt{a}, or
\item A \emph{dotted list}, \texttt{(a b . c)}, meaning that two arguments go into \texttt{a} and \texttt{b}, and the rest into \texttt{c}.
\end{itemize}
\end{pulledtext}

\subsection{lambda special form}
\label{lambda-special-form}
\index{lambda special form}

Syntax: (\textbf{lambda} \emph{formals} \emph{body})

where \emph{body} is one or more expressions.

The \texttt{lambda} special form is expanded by \texttt{special-lambda}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-lambda (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a procedure \\
\hline
\end{tabular}

\begin{lstlisting}
reg special lambda

proc ::constcl::special-lambda {expr env} {
  set args [cdr $expr]
  set formals [car $args]
  set body [cons [S begin] [cdr $args]]
  return [MkProcedure $formals $body $env]
}
\end{lstlisting}

\section{Procedure call}
\label{procedure-call}
\index{procedure call}

\emph{Example: \texttt{(+ 1 6)} $\Rightarrow$ 7}

Once we have procedures, we can \emph{call} them to have their calculations performed and yield results. The procedure name is put in the operator position at the front of a list, and the operands follow in the rest of the list. Our \texttt{square} procedure would be called for instance like this: \texttt{(square 11)}, and it would return 121.

\texttt{invoke} arranges for a procedure to be called with each of the values in the \emph{argument list} (the list of operands). It checks if \emph{pr} really is a procedure, and determines whether to call \emph{pr} as an object or as a Tcl command. Before \texttt{invoke} is called, the argument list should be evaluated with \texttt{eval-list} (see page \pageref{evallist-procedure}).

\subsection{invoke procedure}
\label{invoke-procedure}
\index{invoke procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{invoke (internal)}} \\
pr & a procedure \\
vals & a Lisp list of values \\
\textit{Returns:} & what pr returns \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::invoke {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([$pr tstr] val ...)
  }
  if {[info object isa object $pr]} {
    $pr call {*}[splitlist $vals]
  } else {
    $pr {*}[splitlist $vals]
  }
}
\end{lstlisting}

\section{Binding forms}
\label{binding-forms}
\index{Binding forms}

The binding forms are not fundamental the way the earlier nine forms are. They are an application of a combination of forms eight and nine, the procedure definition form and the procedure call form. But their use is sufficiently distinguished to earn them their own heading.

\subsection{let special form}
\label{let-special-form}
\index{let special form}

Syntax: (\textbf{let} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

or (``named let'')

(\textbf{let} \emph{variable} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{let} special form (both forms) is expanded by \texttt{special-let}. They are ultimately rewritten to calls to \texttt{lambda} constructs and evaluated as such.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-let (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special let

proc ::constcl::special-let {expr env} {
  if {[T [symbol? [cadr $expr]]]} {
    set expr [rewrite-named-let $expr $env]
  }
  set expr [rewrite-let $expr $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-named-let} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rewrite-named-let (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-named-let procedure}

\begin{lstlisting}
proc ::constcl::rewrite-named-let {expr env} {
\end{lstlisting}

The rewriter for named \texttt{let} chops up the expression into \emph{variable}, \emph{bindings}, and \emph{body}.

\begin{lstlisting}
  set variable [cadr $expr]
  set bindings [caddr $expr]
  set body [cdddr $expr]
\end{lstlisting}

It creates a dictionary with the \emph{variable} as key and \texttt{\#f} as value. Then it fills up the dictionary with variable/value pairs from the \emph{bindings}.

\begin{lstlisting}
  set vars [dict create $variable ${::#f}]
  parse-bindings vars $bindings
\end{lstlisting}

It uses the dictionary to build a declaration list for a \texttt{let} form, a variable list for a \texttt{lambda} form, and a procedure call. Then it assembles a \texttt{let} form with the declaration list and a body consisting of an assignment and the procedure call. The assignment binds the variable to a \texttt{lambda} form with the varlist and the original \emph{body}. The \texttt{let} form is returned, meaning that the primary expansion of the named \texttt{let} is a regular \texttt{let} form.

\begin{lstlisting}
  set env [MkEnv $env]
  /define [S decl] [list {*}[dict values [
    dict map {k v} $vars {list $k $v}]]] $env
  /define [S variable] $variable $env
  /define [S varlist] [list {*}[lrange [
    dict keys $vars] 1 end]] $env
  /define [S body] $body $env
  /define [S call] [list {*}[
    dict keys $vars]] $env
  set qq "`(let ,decl
             (set!
               ,variable
                 (lambda ,varlist ,@body)) ,call)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\textbf{rewrite-let} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rewrite-let (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-let procedure}

\begin{lstlisting}
proc ::constcl::rewrite-let {expr env} {
\end{lstlisting}

The rewriter for regular \texttt{let} chops up the original expression into \emph{bindings} and \emph{body}.

\begin{lstlisting}
  set bindings [cadr $expr]
  set body [cddr $expr]
\end{lstlisting}

It creates an empty dictionary and fills it up with variable/value pairs from the \emph{bindings}.

\begin{lstlisting}
  set vars [dict create]
  parse-bindings vars $bindings
\end{lstlisting}

Then it builds a \texttt{lambda} operator form with the variable list, the \emph{body}, and the value list. The \texttt{lambda} call is returned as the expansion of the regular \texttt{let} form.

\begin{lstlisting}
  set env [MkEnv $env]
  /define [S varlist] [list {*}[
    dict keys $vars]] $env
  /define [S body] $body $env
  /define [S vallist] [list {*}[
    dict values $vars]] $env
  set qq "`((lambda ,varlist ,@body)
             ,@vallist)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\textbf{parse-bindings} procedure

\texttt{parse-bindings} is a helper procedure that traverses a \texttt{let} bindings list and extracts variables and values, which it puts in a dictionary. It throws an error if a variable occurs more than once.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{parse-bindings (internal)}} \\
name & a call-by-name name \\
bindings & a Lisp list of values \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}
\index{parse-bindings procedure}

\begin{lstlisting}
proc ::constcl::parse-bindings {name bindings} {
  upvar $name vars
  foreach binding [splitlist $bindings] {
    set var [car $binding]
    set val [cadr $binding]
    if {$var in [dict keys $vars]} {
        ::error "'[$var name]' occurs more than once"
    }
    dict set vars $var $val
  }
  return
}
\end{lstlisting}

\subsection{letrec special form}
\label{letrec-special-form}
\index{letrec special form}

The \texttt{letrec} form is similar to \texttt{let}, but the bindings are created before the values for them are calculated. This means that one can define mutually recursive procedures.

Syntax: (\textbf{letrec} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{letrec} special form is expanded by \texttt{special-letrec}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-letrec (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special letrec

proc ::constcl::special-letrec {expr env} {
  set expr [rewrite-letrec $expr $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-letrec} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rewrite-letrec (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-letrec procedure}

\begin{lstlisting}
proc ::constcl::rewrite-letrec {expr env} {
\end{lstlisting}

The rewriter for \texttt{letrec} chops up the original expression into \emph{bindings} and \emph{body}.

\begin{lstlisting}
  set bindings [cadr $expr]
  set body [cddr $expr]
\end{lstlisting}

It creates an empty dictionary and fills it up with variable/value pairs from the \emph{bindings}.

\begin{lstlisting}
  set vars [dict create]
  parse-bindings vars $bindings
\end{lstlisting}

The keys and values in the dictionary are used to create three dictionaries: one for the outer lambda, one for the inner lambda, and one for the assignments.

\begin{lstlisting}
  foreach {key val} $vars {
    dict set outer $key [list [S quote] ${::#UND}]
    dict set inner [set g [gensym "g"]] $val
    dict set assigns $key $g
  }
\end{lstlisting}

The three dictionaries are used to populate a double lambda construct in a quasiquote structure, which is expanded and returned.

\begin{lstlisting}
  set env [MkEnv $env]
  # outer vars
  /define [S ovars] [
    list {*}[dict keys $outer]] $env
  # outer vals
  /define [S ovals] [
    list {*}[dict values $outer]] $env
  # inner vars
  /define [S ivars] [
    list {*}[dict keys $inner]] $env
  # inner vals
  /define [S ivals] [
    list {*}[dict values $inner]] $env
  /define [S assigns] [list {*}[lmap {k v} $assigns {
      list [S set!] $k $v
    }]] $env
  /define [S body] $body $env
  set qq "`((lambda ,ovars
             ((lambda ,ivars ,@assigns) ,@ivals)
             ,@body) ,@ovals)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{let* special form}
\label{let-special-form1}
\index{let* special form}

The \texttt{let*} form is similar to \texttt{let}, but the items in the binding list are considered sequentially, so the initializer in the second or later binding can reference the first binding, etc.

Syntax: (\textbf{let*} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{let*} special form is expanded by \texttt{special-let*}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{special-let* (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special let*

proc ::constcl::special-let* {expr env} {
  set expr [rewrite-let* [cadr $expr] [cddr $expr] $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-let*} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{rewrite-let* (internal)}} \\
bindings & a Lisp list of values \\
body & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-let* procedure}

\begin{lstlisting}
proc ::constcl::rewrite-let* {bindings body env} {
  set env [MkEnv $env]
  if {$bindings eq ${::#NIL}} {
\end{lstlisting}

If there are no more bindings, wrap the \emph{body} in a \texttt{begin} and return it.

\begin{lstlisting}
    /define [S body] $body $env
    set qq "`(begin ,@body)"
    set expr [expand-quasiquote [parse $qq] $env]
  } else {
\end{lstlisting}

Otherwise, create a quasiquote structure with a lambda call and put a variable and a value at a time in it. The body of the lambda is the rewriter itself called recursively.

Return the lambda call.

\begin{lstlisting}
    /define [S var] [caar $bindings] $env
    /define [S val] [cadar $bindings] $env
    /define [S rest] [rewrite-let* [cdr $bindings] \
      $body $env] $env
    set qq "`((lambda (,var)
               ,rest) ,val)"
    set expr [expand-quasiquote [parse $qq] $env]
  }
  $env destroy
  return $expr
}
\end{lstlisting}

\section{Environments}
\label{environments}
\index{environments}

Before I can talk about the evaluator, I need to spend some time on environments. To simplify, an environment can be seen as a table--or spreadsheet, if you will--that connects (binds) names to cells, which contain values. The evaluator looks up values in the environment that way. But there's more to an environment than just a name-value coupling. The environment also contains references to the procedures that make up the Lisp library. And their bindings aren't just a simple connection: there are several kinds of bindings, from variable binding, the most common one, to special-form bindings for the fundamental operations of the interpreter, and syntax bindings for the macros that get expanded to `normal' code.

There isn't just one environment, either. Every time a non-primitive procedure is called, a new environment is created, one which has bindings for the procedure formal parameters and which links to the environment that was current when the procedure was defined (which in turn links backwards all the way to the original global environment). The evaluator follows into the new environment to evaluate the body of the procedure there, and then as the evaluator goes back along the call stack, it sheds environment references.

Not only procedures but binding forms (such as \texttt{let}) create new environments for the evaluator to work in. As they do that, they also bind variables to values. Just like with procedures, the added local bindings can shadow bindings in underlying environments but does not affect them: once the local environment has been forgotten by the evaluator, the underlying bindings are once more visible. The other side of the coin is that temporary environments don't have to be complete: every binding that the evaluator can't find in a temporary environment it looks for in the parent environment, or its parent and so on.

Environments make up the world the evaluator lives in and are the source of its values and procedures. The ability of procedure calls and execution of binding forms to temporarily change the current environment is a powerful one.

From the evaluator's perspective it uses the environment to keep track of changes in the state of the evaluation. In this way, the evaluator uses the environment for continuity and a progress record.

\begin{figure}[h!]\includegraphics{images/environments.png}\captionsetup{labelformat=empty}\caption{Two sample environments}\label{fig:two-sample-environments}\end{figure}

I will talk some more about the implementation of environments in a later section.

\section{The evaluator}
\label{the-evaluator}
\index{the evaluator}

Now that all nine syntactic forms are in place and we have a basic understanding of the environment, we can start assembling the evaluator.

\subsection{eval procedure}
\label{eval-procedure}
\index{eval procedure}

The heart of the Lisp interpreter, \texttt{eval} takes a Lisp expression and processes it according to its form. Variable reference and constant literals are handled here, but the other seven syntactic forms are delegated to \texttt{eval-form}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{eval (public)}} \\
expr & an expression \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg eval

proc ::constcl::eval \
  {expr {env ::constcl::global_env}} {
  if {[T [symbol? $expr]]} {
    lookup $expr $env
  } elseif {[T [self-evaluating? $expr]]} {
    set expr
  } elseif {[T [pair? $expr]]} {
    eval-form $expr $env
  } else {
    error "unknown expression type [$expr tstr]"
  }
}
\end{lstlisting}

\subsection{eval-form procedure}
\label{evalform-procedure}
\index{eval-form procedure}

If the \texttt{car} of the expression (the operator) is a symbol, \texttt{eval-form} looks at the \emph{binding information} (which the \texttt{reg} procedure (see page \pageref{reg-procedure}) puts into the standard library and thereby the global environment) for the symbol. The \emph{binding type} tells in general how the expression should be treated: as a special form, a variable, or a macro (see page \pageref{macros}). The \emph{handling info} gives the exact procedure that will take care of the expression. If the operator isn't a symbol, it is evaluated and applied to the evaluated rest of the expression.

The seven remaining syntactic forms (and the binding forms) are implemented as one or more special forms and handled when the relevant symbol appears in the \texttt{car} of the expression. Their \emph{binding type} is \texttt{SPECIAL} and the \emph{handling info} consists of the name of the procedure expanding the special form. The procedure is called with the expression and the environment as arguments.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{eval-form (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::eval-form {expr env} {
  set op [car $expr]
  set args [cdr $expr]
  if {[T [symbol? $op]]} {
    lassign [binding-info $op $env] btype hinfo
    switch $btype {
      UNBOUND {
        error "unbound symbol" $op
      }
      SPECIAL {
        $hinfo $expr $env
      }
      VARIABLE {
        invoke $hinfo [eval-list $args $env]
      }
      SYNTAX {
        eval [$hinfo $expr $env] $env
      }
      default {
        error "unrecognized binding type" $btype
      }
    }
  } else {
    invoke [eval $op $env] [eval-list $args $env]
  }
}
\end{lstlisting}

\textbf{binding-info} procedure

The \texttt{binding-info} procedure takes a symbol and returns a list of two items: 1) the binding type of the symbol, and 2) the handling info that \texttt{eval-form} uses to handle this symbol.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{binding-info (internal)}} \\
op & a symbol \\
env & an environment \\
\textit{Returns:} & binding info \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::binding-info {op env} {
  set actual_env [$env find $op]
  if {$actual_env eq "::constcl::null_env"} {
    return [::list UNBOUND {}]
  } else {
    return [$actual_env get $op]
  }
}
\end{lstlisting}

\textbf{eval-list} procedure \label{evallist-procedure}

\texttt{eval-list} successively evaluates the elements of a Lisp list and returns the collected results as a Lisp list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{eval-list (internal)}} \\
exps & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}
\index{eval-list procedure}

\begin{lstlisting}
proc ::constcl::eval-list {exps env} {
  if {[T [pair? $exps]]} {
    return [cons [eval [car $exps] $env] \
      [eval-list [cdr $exps] $env]]
  } else {
    return ${::#NIL}
  }
}
\end{lstlisting}

\section{Macros}
\label{macros}
\index{Macros}

One of Lisp's strong points is macros that allow concise, abstract expressions that are automatically rewritten into other, more concrete but also more verbose expressions. This interpreter does macro expansion, but the user can't define new macros--the ones available are hardcoded in the code below.

A macro expander procedure takes an expression and an environment as parameters. In the end, the expanded expression is passed back to \texttt{eval}.

\subsection{expand-and procedure}
\label{expandand-procedure}
\index{expand-and procedure}

\texttt{expand-and} expands the \texttt{and} macro. It returns a \texttt{begin}-expression if the macro has 0 or 1 elements, and a nested \texttt{if} construct otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-and (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro and

proc ::constcl::expand-and {expr env} {
  set tail [cdr $expr]
  if {[[length $tail] numval] == 0} {
    list [S begin] ${::#t}
  } elseif {[[length $tail] numval] == 1} {
    cons [S begin] $tail
  } else {
    do-and $tail ${::#t} $env
  }
}
\end{lstlisting}

\textbf{do-and} procedure

\texttt{do-and} is called recursively for every argument of \texttt{expand-and} if there is more than one.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{do-and (internal)}} \\
tail & an expression tail \\
prev & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-and procedure}

\begin{lstlisting}
proc ::constcl::do-and {tail prev env} {
  if {[T [null? $tail]]} {
    return $prev
  } else {
    set env [MkEnv $env]
    /define [S first] [car $tail] $env
    /define [S rest] [do-and [cdr $tail] \
        [car $tail] $env] $env
    set qq "`(if ,first ,rest #f)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{expand-del! procedure}
\label{expanddel-procedure}
\index{expand-del"! procedure}

The macro \texttt{del!} updates a property list. It removes a key-value pair if the key is present, or leaves the list untouched if it isn't.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-del! (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro del!

proc ::constcl::expand-del! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
    ::error "too few arguments, 0 of 2"
  }
  /define [S listname] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
    ::error "too few arguments, 1 of 2"
  }
  /define [S key] [cadr $tail] $env
  set qq "`(set! ,listname
             (delete! ,listname ,key))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-for procedure}
\label{expandfor-procedure}
\index{expand-for procedure}

The \texttt{expand-for} procedure expands the \texttt{for} macro. It returns a \texttt{begin} construct containing the iterations of each clause (multiple clauses weren't implemented for the longest time, but I brought up my strongest brain cells and they did it).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-for (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for

proc ::constcl::expand-for {expr env} {
  set res [do-for [cdr $expr] $env]
  lappend res [parse "'()"]
  return [list [S begin] {*}$res]
}
\end{lstlisting}

\textbf{for-seq} procedure

\texttt{for-seq} is a helper procedure that sets up the sequence of values that the iteration is based on. First it evaluates the code that generates the sequence, and then it converts it to a Tcl list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{for-seq (internal)}} \\
seq & an expression \\
env & an environment \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}
\index{for-seq procedure}

\begin{lstlisting}
proc ::constcl::for-seq {seq env} {
\end{lstlisting}

If \emph{seq} is a number, call the \texttt{in-range} procedure to get a sequence. Otherwise, evaluate \emph{seq}.

\begin{lstlisting}
  if {[T [number? $seq]]} {
    set seq [in-range $seq]
  } else {
    set seq [eval $seq $env]
  }
\end{lstlisting}

Make the sequence a Tcl list, one way or another.

\begin{lstlisting}
  if {[T [list? $seq]]} {
    set seq [splitlist $seq]
  } elseif {[T [string? $seq]]} {
    set seq [lmap c [split [$seq value] {}] {
      switch $c {
        " "  { MkChar #\\space }
        "\n" { MkChar #\\newline }
        default {
          MkChar #\\$c
        }
      }
    }]
  } elseif {[T [vector? $seq]]} {
    set seq [$seq value]
  } else {
    ::error "unknown sequence type [$seq tstr]"
  }
  return $seq
}
\end{lstlisting}

\textbf{do-for} procedure

\texttt{do-for} is another helper procedure which does most of the work in the \texttt{for/*} forms. It iterates over the clauses, extracting and preparing the sequence for each, and stores each of the sequence steps in a dictionary under a double key: the identifier and the ordinal of the step.

Then it creates a \texttt{let} construct for each step, in which each of the clauses' identifiers is bound to the step's value. The Tcl list of \texttt{let} constructs is returned.

Each clause's sequence is supposed to be the same length as the others. One weakness of this implementation is that it doesn't ensure this, just hopes that the user does the right thing.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{do-for (internal)}} \\
tail & an expression tail \\
env & an environment \\
\textit{Returns:} & a Tcl list of expressions \\
\hline
\end{tabular}
\index{do-for procedure}

\begin{lstlisting}
proc ::constcl::do-for {tail env} {
  # make clauses a Tcl list
  set clauses [splitlist [car $tail]]
  set body [cdr $tail]
  set data [dict create]
  set length 0
  foreach clause $clauses {
    set id [car $clause]
    set sequence [for-seq [cadr $clause] $env]
    set length [llength $sequence]
    # save every id and step of the iteration
    for {set i 0} {$i < $length} {incr i} {
        dict set data $id $i [lindex $sequence $i]
    }
  }
  set res {}
  # for every step of the iteration...
  for {set i 0} {$i < $length} {incr i} {
    set decl {}
    # retrieve the ids
    foreach id [dict keys $data] {
      # list the id and the step
      lappend decl [
        list $id [dict get $data $id $i]]
    }
    # add to the structure of let constructs
    lappend res [list [S let] [
        list {*}$decl] {*}[splitlist $body]]
  }
  return $res
}
\end{lstlisting}

\subsection{expand-for/and procedure}
\label{expandforand-procedure}
\index{expand-for/and procedure}

The \texttt{expand-for/and} procedure expands the \texttt{for/and} macro. It returns an \texttt{and} construct containing the iterations of the clauses.

The only differences from \texttt{expand-for} is that it doesn't add \texttt{(quote ())} and that it wraps the list of iterations in \texttt{and} instead of \texttt{begin}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-for/and (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/and

proc ::constcl::expand-for/and {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S and] {*}$res]
}
\end{lstlisting}

\subsection{expand-for/list procedure}
\label{expandforlist-procedure}
\index{expand-for/list procedure}

The \texttt{expand-for/list} procedure expands the \texttt{for/list} macro. It returns a \texttt{list} construct containing the iterations of each clause.

The only difference from \texttt{expand-for/and} is that it wraps the list of iterations in \texttt{list} instead of \texttt{and}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand for/list (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/list

proc ::constcl::expand-for/list {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S list] {*}$res]
}
\end{lstlisting}

\subsection{expand-for/or procedure}
\label{expandforor-procedure}
\index{expand-for/or procedure}

The \texttt{expand-for/or} procedure expands the \texttt{for/or} macro. It returns an \texttt{or} construct containing the iterations of each clause.

The only difference from \texttt{expand-for/list} is that it wraps the list of iterations in \texttt{or} instead of \texttt{list}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-for/or (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/or

proc ::constcl::expand-for/or {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S or] {*}$res]
}
\end{lstlisting}

\subsection{expand-or procedure}
\label{expandor-procedure}
\index{expand-or procedure}

\texttt{expand-or} expands the \texttt{or} macro. It returns a \texttt{begin}-expression if the macro has 0 or 1 elements, and a nested \texttt{if} construct otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-or (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro or

proc ::constcl::expand-or {expr env} {
  set tail [cdr $expr]
  if {[[length $tail] numval] == 0} {
    return [list [S begin] ${::#f}]
  } elseif {[[length $tail] numval] == 1} {
    return [cons [S begin] $tail]
  } else {
    return [do-or $tail $env]
  }
}
\end{lstlisting}

\textbf{do-or} procedure

\texttt{do-or} is called recursively for each argument to \texttt{expand-or} if there is more than one argument.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{do-or (internal)}} \\
tail & an expression tail \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-or procedure}

\begin{lstlisting}
proc ::constcl::do-or {tail env} {
  if {[T [null? $tail]]} {
    return ${::#f}
  } else {
    set env [MkEnv $env]
    /define [S first] [car $tail] $env
    /define [S rest] [do-or [cdr $tail] $env] $env
    set qq "`(let ((x ,first)) (if x x ,rest))"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{expand-pop! procedure}
\label{expandpop-procedure}
\index{expand-pop"! procedure}

The macro \texttt{pop!} updates a list. It removes the first element.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-pop! (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro pop!

proc ::constcl::expand-pop! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
      ::error "too few arguments:\n(pop! listname)"
  }
  if {[symbol? [car $tail]] eq ${::#f}} {
      ::error "SYMBOL expected:\n(pop! listname)"
  }
  /define [S listname] [car $tail] $env
  set qq "`(set! ,listname (cdr ,listname))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-push! procedure}
\label{expandpush-procedure}
\index{expand-push"! procedure}

The macro \texttt{push!} updates a list. It adds a new element as the new first element. The \texttt{push!} and \texttt{pop!} macros together implement a stack on a list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-push! (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro push!

proc ::constcl::expand-push! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
    ::error \
      "too few arguments:\n(push! obj listname)"
  }
  /define [S obj] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
    ::error \
      "too few arguments:\n(push! obj listname)"
  }
  if {[symbol? [cadr $tail]] eq ${::#f}} {
    ::error \
      "SYMBOL expected:\n(push! obj listname)"
  }
  /define [S listname] [cadr $tail] $env
  set qq "`(set!
             ,listname
             (cons ,obj ,listname))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-put! procedure}
\label{expandput-procedure}
\index{expand-put"! procedure}

The macro \texttt{put!} updates a property list. It adds a key-value pair if the key isn't present, or changes the value in place if it is.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-put! (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro put!

proc ::constcl::expand-put! {expr env} {
  set tail [cdr $expr]
  set env [::constcl::MkEnv $env]
  if {[T [null? $tail]]} {
      ::error "too few arguments, 0 of 3"
  }
  /define [S name] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
      ::error "too few arguments, 1 of 3"
  }
  /define [S key] [cadr $tail] $env
  if {[T [null? [cddr $tail]]]} {
      ::error "too few arguments, 2 of 3"
  }
  /define [S val] [caddr $tail] $env
  set qq "`(let ((idx (list-find-key ,name ,key)))
             (if (< idx 0)
               (set!
                 ,name
                 (append (list ,key ,val) ,name))
               (begin
                 (list-set! ,name (+ idx 1) ,val)
                 ,name)))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-quasiquote procedure}
\label{expandquasiquote-procedure}
\index{expand-quasiquote procedure}

A quasi-quote isn't a macro, but we will deal with it in this section anyway. \texttt{expand-quasiquote} traverses a quasi-quoted structure searching for \texttt{unquote} and \texttt{unquote-splicing}. This code is brittle and sprawling and I barely understand it myself, but it works (and is the basis for a lot of the special form/macro expanders).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-quasiquote (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro quasiquote

proc ::constcl::expand-quasiquote {expr env} {
  set tail [cdr $expr]
  set qqlevel 0
  if {[T [list? [car $tail]]]} {
    set node [car $tail]
    return [qq-visit-child $node 0 $env]
  } elseif {[T [vector? [car $tail]]]} {
    set vect [car $tail]
    set res {}
    for {set i 0} {$i < [
        [vector-length $vect] numval]} {incr i} {
      set idx [MkNumber $i]
      set vecref [vector-ref $vect $idx]
      if {[T [pair? $vecref]] &&
          [T [eq? [car $vecref] [
            S unquote]]]} {
        if {$qqlevel == 0} {
          lappend res [eval [cadr $vecref] $env]
        }
      } elseif {[T [pair? $vecref]] &&
          [T [eq? [car $vecref] [
            S unquote-splicing]]]} {
        if {$qqlevel == 0} {
          lappend res {*}[splitlist [
            eval [cadr $vecref] $env]]
        }
      } elseif {[T [atom? $vecref]]} {
        lappend res $vecref
      } else {
      }
    }
    return [list [S "vector"] {*}$res]
  }
}
\end{lstlisting}

\textbf{qq-visit-child} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{qq-visit-child (internal)}} \\
node & a Lisp list of expressions \\
qqlevel & a Tcl number \\
env & an environment \\
\textit{Returns:} & a Lisp list of expressions \\
\hline
\end{tabular}
\index{qq-visit-child procedure}

\begin{lstlisting}
proc ::constcl::qq-visit-child {node qqlevel env} {
  if {$qqlevel < 0} {
    set qqlevel 0
  }
  if {[T [list? $node]]} {
    set res {}
    foreach child [splitlist $node] {
      if {[T [pair? $child]] &&
          [T [eq? [car $child] [S unquote]]]} {
        if {$qqlevel == 0} {
          lappend res [eval [cadr $child] $env]
        } else {
          lappend res [list [S unquote] [
            qq-visit-child [cadr $child] [
            expr {$qqlevel - 1}] $env]]
        }
      } elseif {[T [pair? $child]] &&
          [T [eq? [car $child] [
          S unquote-splicing]]]} {
        if {$qqlevel == 0} {
          lappend res {*}[splitlist [
            eval [cadr $child] $env]]
        }
      } elseif {[T [pair? $child]] &&
          [T [eq? [car $child] [S quasiquote]]]} {
        lappend res [list [S quasiquote] [car [
          qq-visit-child [cdr $child] [
            expr {$qqlevel + 1}] $env]]]
      } elseif {[T [atom? $child]]} {
        lappend res $child
      } else {
        lappend res [
          qq-visit-child $child $qqlevel $env]
      }
    }
  }
  return [list {*}$res]
}
\end{lstlisting}

\subsection{expand-unless procedure}
\label{expandunless-procedure}
\index{expand-unless procedure}

\texttt{unless} is a conditional like \texttt{if}, but it takes a number of expressions. It executes them on a false outcome of \texttt{car \$tail}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-unless (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro unless

proc ::constcl::expand-unless {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  /define [S tail] $tail $env
  set qq "`(if ,(car tail)
             '()
             (begin ,@(cdr tail)))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-when procedure}
\label{expandwhen-procedure}
\index{expand-when procedure}

\texttt{when} is a conditional like \texttt{if}, but it takes a number of expressions. It executes them on a true outcome of \texttt{car \$tail}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expand-when (internal)}} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro when

proc ::constcl::expand-when {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  /define [S tail] $tail $env
  set qq "`(if ,(car tail)
             (begin ,@(cdr tail))
             '())"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\section{Resolving local defines}
\label{resolving-local-defines}
\index{Resolving local defines}

This section is ported from 'Scheme 9 from Empty Space'\index{S9fES}. It rewrites local defines as a \texttt{letrec} form. \texttt{resolve-local-defines} takes a list of expressions and extracts variables and values from the defines in the beginning of the list. It builds a double lambda expression with the variables and values, and the rest of the expressions from the original list as body.

\subsection{resolve-local-defines procedure}
\label{resolvelocaldefines-procedure}
\index{resolve-local-defines procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{resolve-local-defines}} \\
expr & an expression \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::resolve-local-defines {expr} {
  set exps [cdr $expr]
  set rest [lassign [
    extract-from-defines $exps VALS] a error]
  if {[T $error]} {
    return ${::#NIL}
  }
  set rest [lassign [
    extract-from-defines $exps VARS] v error]
  if {[T $error]} {
    return ${::#NIL}
  }
  if {$rest eq ${::#NIL}} {
    set rest [cons #UNS ${::#NIL}]
  }
  return [make-lambdas $v $a $rest]
}
\end{lstlisting}

\subsection{extract-from-defines procedure}
\label{extractfromdefines-procedure}
\index{extract-from-defines procedure}

\texttt{extract-from-defines} visits every define in the given list of expressions and extracts either a variable name or a value, depending on the state of the \emph{part} flag, from each one of them. A Tcl list of 1) the resulting list of names or values, 2) error state, and 3) the rest of the expressions in the original list is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{extract-from-defines (internal)}} \\
exps & a Lisp list of expressions \\
part & a flag, VARS or VALS \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::extract-from-defines {exps part} {
  set a ${::#NIL}
  while {$exps ne ${::#NIL}} {
    if {[T [atom? $exps]] ||
        [T [atom? [car $exps]]] ||
        ![T [eq? [caar $exps] [S define]]]} {
      break
    }
    set n [car $exps]
    set k [length $n]
    if {![T [list? $n]] ||
        [$k numval] < 3 ||
        ![T [argument-list? [cadr $n]]] ||
        ([T [symbol? [cadr $n]]] &&
        [$k numval] > 3)} {
        return [::list ${::#NIL} ${::#t} ${::#NIL}]
      }
      if {[T [pair? [cadr $n]]]} {
        if {$part eq "VARS"} {
          set a [cons [caadr $n] $a]
        } else {
          set a [cons ${::#NIL} $a]
          set new [cons [cdadr $n] [cddr $n]]
          set new [cons [S lambda] $new]
          set-car! $a $new
        }
      } else {
        if {$part eq "VARS"} {
          set a [cons [cadr $n] $a]
        } else {
          set a [cons [caddr $n] $a]
        }
      }
      set exps [cdr $exps]
    }
    return [::list $a ${::#f} $exps]
}
\end{lstlisting}

\subsection{argument-list? procedure}
\label{argumentlist-procedure}
\index{argument-list? procedure}

\texttt{argument-list?} accepts a Scheme formals list and rejects other values.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{argument-list? (internal)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::argument-list? {val} {
  if {$val eq ${::#NIL}} {
    return ${::#t}
  } elseif {[T [symbol? $val]]} {
    return ${::#t}
  } elseif {[T [atom? $val]]} {
    return ${::#f}
  }
  while {[T [pair? $val]]} {
    if {[symbol? [car $val]] eq ${::#f}} {
      return ${::#f}
    }
    set val [cdr $val]
  }
  if {$val eq ${::#NIL}} {
    return ${::#t}
  } elseif {[T [symbol? $val]]} {
    return ${::#t}
  }
}
\end{lstlisting}

\subsection{make-lambdas procedure}
\label{makelambdas-procedure}
\index{make-lambdas procedure}

\texttt{make-lambdas} builds the \texttt{letrec} structure.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-lambdas (internal)}} \\
vars & a Lisp list of symbols \\
args & a Lisp list of expressions \\
body & a Lisp list of expressions \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-lambdas {vars args body} {
  set tmps [make-temporaries $vars]
  set body [append-b [
    make-assignments $vars $tmps] $body]
  set body [cons $body ${::#NIL}]
  set n [cons $tmps $body]
  set n [cons [S lambda] $n]
  set n [cons $n $args]
  set n [cons $n ${::#NIL}]
  set n [cons $vars $n]
  set n [cons [S lambda] $n]
  set n [cons $n [make-undefineds $vars]]
  return $n
}
\end{lstlisting}

\subsection{make-temporaries procedure}
\label{maketemporaries-procedure}
\index{make-temporaries procedure}

\texttt{make-temporaries} creates the symbols that will act as middlemen in transferring the values to the variables.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-temporaries (internal)}} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-temporaries {vals} {
  set res ${::#NIL}
  while {$vals ne ${::#NIL}} {
    set res [cons [gensym "g"] $res]
    set vals [cdr $vals]
  }
  return $res
}
\end{lstlisting}

\subsection{gensym procedure}
\label{gensym-procedure}
\index{gensym procedure}

\texttt{gensym} generates a unique symbol. The candidate symbol is compared to all the symbols in the symbol table to avoid collisions.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{gensym (internal)}} \\
prefix & a string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::gensym {prefix} {
  set symbolnames [
    dict keys $::constcl::symbolTable]
  set s $prefix<[incr ::constcl::gensymnum]>
  while {$s in $symbolnames} {
    set s $prefix<[incr ::constcl::gensymnum]>
  }
  return [S $s]
}
\end{lstlisting}

\subsection{append-b procedure}
\label{appendb-procedure}
\index{append-b procedure}

\texttt{append-b} joins two lists together.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{append-b (internal)}} \\
a & a Lisp list of values \\
b & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::append-b {a b} {
  if {$a eq ${::#NIL}} {
    return $b
  }
  set p $a
  while {$p ne ${::#NIL}} {
    if {[T [atom? $p]]} {
      ::error "append: improper list"
    }
    set last $p
    set p [cdr $p]
  }
  set-cdr! $last $b
  return $a
}
\end{lstlisting}

\subsection{make-assignments procedure}
\label{makeassignments-procedure}
\index{make-assignments procedure}

\texttt{make-assignments} creates the structure that holds the assignment statements. Later on, it will be joined to the body of the finished expression.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-assignments (internal)}} \\
vars & a Lisp list of symbols \\
tmps & a Lisp list of symbols \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-assignments {vars tmps} {
  set res ${::#NIL}
  while {$vars ne ${::#NIL}} {
    set asg [cons [car $tmps] ${::#NIL}]
    set asg [cons [car $vars] $asg]
    set asg [cons [S set!] $asg]
    set res [cons $asg $res]
    set vars [cdr $vars]
    set tmps [cdr $tmps]
  }
  return [cons [S begin] $res]
}
\end{lstlisting}

\subsection{make-undefineds procedure}
\label{makeundefineds-procedure}
\index{make-undefineds procedure}

\texttt{make-undefineds} creates a list of quoted undefined values.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-undefineds (internal)}} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of nil values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-undefineds {vals} {
  set res ${::#NIL}
  while {$vals ne ${::#NIL}} {
    set res [cons [list [S quote] ${::#UND}] $res]
    set vals [cdr $vals]
  }
  return $res
}
\end{lstlisting}

\chapter{Output}
\label{output}

The third thing an interpreter must be able to do is to present the resulting code and data so that the user can know what the outcome of the evaluation was.

\subsection{write procedure}
\label{write-procedure}
\index{write procedure}

As long as the object given to \texttt{write} isn't the empty string, \texttt{write} calls the object's \texttt{write} method and then writes a newline.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{write (public)}} \\
val & a value \\
?port? & a port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg write

proc ::constcl::write {val args} {
  if {$val ne ""} {
    set oldport $::constcl::Output_port
    if {[llength $args]} {
      lassign $args port
      set ::constcl::Output_port $port
    }
    $val write $::constcl::Output_port
    $::constcl::Output_port newline
    set ::constcl::Output_port $oldport
  }
  return
}
\end{lstlisting}

\subsection{display procedure}
\label{display-procedure}
\index{display procedure}

The \texttt{display} procedure is like \texttt{write} but it calls the object's \texttt{display} method and doesn't print a newline afterwards.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{display (public)}} \\
val & a value \\
?port? & a port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg display

proc ::constcl::display {val args} {
  if {$val ne ""} {
    set oldport $::constcl::Output_port
    if {[llength $args]} {
      lassign $args port
      set ::constcl::Output_port $port
    }
    $val display $::constcl::Output_port
    $::constcl::Output_port flush
    set ::constcl::Output_port $oldport
  }
  return
}
\end{lstlisting}

\subsection{write-pair procedure}
\label{writepair-procedure}
\index{write-pair procedure}

The \texttt{write-pair} procedure prints a Pair object except for the beginning and ending parentheses.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{write-pair (internal)}} \\
port & an output port \\
pair & a pair \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::write-pair {port pair} {
  # take an object and print the car
  # and the cdr of the stored value
  set a [car $pair]
  set d [cdr $pair]
  # print car
  $a write $port
  if {[T [pair? $d]]} {
    # cdr is a cons pair
    $port put " "
    write-pair $port $d
  } elseif {[T [null? $d]]} {
    # cdr is nil
    return
  } else {
    # it is an atom
    $port put " . "
    $d write $port
  }
  return
}
\end{lstlisting}

\chapter{Identifier validation}
\label{identifier-validation}

\textbf{idcheckinit} procedure

\noindent \textbf{idchecksubs} procedure

\noindent \textbf{idcheck} procedure

\noindent \textbf{varcheck} procedure

Some routines for checking if a string is a valid identifier. \texttt{idcheckinit} checks the first character, \texttt{idchecksubs} checks the rest. \texttt{idcheck} calls the others and raises an error if they fail. A valid symbol is still an invalid identifier if has the name of some keyword, which \texttt{varcheck} checks, for a set of keywords given in the standard.
\index{idcheckinit procedure}

\begin{lstlisting}
proc ::constcl::idcheckinit {init} {
  if {[::string is alpha -strict $init] ||
    $init in {! $ % & * / : < = > ? ^ _ ~}} {
    return true
  } else {
    return false
  }
}
\end{lstlisting}
\index{idchecksubs procedure}

\begin{lstlisting}
proc ::constcl::idchecksubs {subs} {
  foreach c [split $subs {}] {
    if {!([::string is alnum -strict $c] ||
      $c in {! $ % & * / : < = > ? ^ _ ~ + - . @})} {
      return false
    }
  }
  return true
}
\end{lstlisting}
\index{idcheck procedure}

\begin{lstlisting}
proc ::constcl::idcheck {sym} {
  if {$sym eq {}} {return $sym}
  if {(![idcheckinit [::string index $sym 0]] ||
    ![idchecksubs [::string range $sym 1 end]]) &&
    $sym ni {+ - ...}} {
    ::error "Identifier expected ($sym)"
  }
  set sym
}
\end{lstlisting}
\index{varcheck procedure}

\begin{lstlisting}
proc ::constcl::varcheck {sym} {
  if {$sym in {
    else => define unquote unquote-splicing
    quote lambda if set! begin cond and or
    case let let* letrec do delay quasiquote
  }} {
    ::error "Variable name is reserved: $sym"
  }
  return $sym
}
\end{lstlisting}

\chapter{Environment class and objects}
\label{environment-class-and-objects}

The class for environments is called \texttt{Environment}. It is mostly a wrapper around a dictionary, with the added finesse of keeping a link to the outer environment. In this way, there is a chain connecting the latest environment all the way to the global environment and then stopping at the null environment. This chain can be traversed by the \texttt{find} method to find which innermost environment a given symbol is bound in.

Using a dictionary means that name lookup is by hash table lookup. In a typical Lisp implementation, large environments are served by hash lookup, while small ones have name lookup by linear search.

The long and complex constructor is to accommodate the variations of Scheme formal parameters lists, which can be an empty list, a proper list, a symbol, or a dotted list.

Names are stored as Lisp symbols, while values are stored as they are, as Lisp or Tcl values. This means that a name might have to be converted to a symbol before lookup, and the result of lookup may have to be converted afterwards. Note that in the two cases where a number of values are stored under one name (a formals list of a single symbol or a dotted list), then the values are stored as a Lisp list of values.

\subsection{Environment class}
\label{environment-class}
\index{Environment class}

\begin{lstlisting}
oo::class create ::constcl::Environment {
  superclass ::constcl::Base
  variable bindings outer_env
  constructor {syms vals {outer {}}} {
    set bindings [dict create]
\end{lstlisting}

If the formals list (\texttt{syms}) is the empty list, then no arguments are accepted.

\begin{lstlisting}
    if {[T [::constcl::null? $syms]]} {
      if {[llength $vals]} {
        error "too many arguments"
      }
\end{lstlisting}

If the formals list is a proper list, there should be one argument per list item.

\begin{lstlisting}
    } elseif {[T [::constcl::list? $syms]]} {
      set syms [::constcl::splitlist $syms]
      set symsn [llength $syms]
      set valsn [llength $vals]
      if {$symsn != $valsn} {
        error [
          ::append --> "wrong # of arguments, " \
            "$valsn instead of $symsn"]
      }
      foreach sym $syms val $vals {
        my bind $sym [lindex $val 0] [lindex $val 1]
      }
\end{lstlisting}

If the formals list is actually a single symbol, it takes all the arguments as a list.

\begin{lstlisting}
    } elseif {[T [::constcl::symbol? $syms]]} {
      my bind $syms VARIABLE [
        ::constcl::list {*}[lmap v $vals {
          lindex $v 1
        }]]
\end{lstlisting}

Otherwise, bind an argument to the first item in the formals lists and cdr the formals list until the dotted end comes up. Bind all the remaining arguments to it.

\begin{lstlisting}
    } else {
      while true {
        if {[llength $vals] < 1} {
          error "too few arguments"
        }
        my bind [::constcl::car $syms] \
          [lindex $vals 0 0] [lindex $vals 0 1]
        set vals [lrange $vals 1 end]
        if {[T [
          ::constcl::symbol? [
            ::constcl::cdr $syms]]]} {
          my bind [::constcl::cdr $syms] \
            VARIABLE [
              ::constcl::list {*}[lmap v $vals {
                lindex $v 1
              }]]
          set vals {}
          break
        } else {
          set syms [::constcl::cdr $syms]
        }
      }
    }
\end{lstlisting}

Set the link to the outer environment.

\begin{lstlisting}
    set outer_env $outer
  }
\end{lstlisting}

The \texttt{find} method searches the environment chain for bindings for a given symbol. The search starts with the current environment instance and ends at the innermost occurrence of a binding for \emph{sym}. The environment containing the binding is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) find (internal)}} \\
sym & a symbol \\
\textit{Returns:} & an environment \\
\hline
\end{tabular}

\begin{lstlisting}
  method find {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment find"
    }
    if {[dict exists $bindings $sym]} {
      self
    } else {
      $outer_env find $sym
    }
  }
\end{lstlisting}

The \texttt{get} method returns the binding type and handling info for \emph{sym} as a tuple.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) get (internal)}} \\
sym & a symbol \\
\textit{Returns:} & binding info \\
\hline
\end{tabular}

\begin{lstlisting}
  method get {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment get"
    }
    dict get $bindings $sym
  }
\end{lstlisting}

The \texttt{unbind} method unsets a binding in the current environment instance. Fails silently if no such binding exists.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) unbind (internal)}} \\
sym & a symbol \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method unbind {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment unbind"
    }
    dict unset bindings $sym
    return
  }
\end{lstlisting}

The \texttt{bind} method binds a symbol in the current environment instance. It is an error to attempt to bind a symbol that is already bound in the environment.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) bind (internal)}} \\
sym & a symbol \\
type & binding type \\
info & handling info \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method bind {sym type info} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment bind"
    }
    if {[dict exists $bindings $sym]} {
      set bi [my get $sym]
      lassign $bi bt in
      if {$bt in {SPECIAL VARIABLE SYNTAX}} {
        error "[$sym name] is already bound"
      }
    }
    dict set bindings $sym [::list $type $info]
    return
  }
\end{lstlisting}

The \texttt{assign} method updates the location that \emph{sym} is bound to with a new binding type and handling info / value. \emph{Sym} must be bound, and the old binding type must be VARIABLE.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) assign (internal)}} \\
sym & a symbol \\
type & binding type \\
info & handling info \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method assign {sym type info} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment assign"
    }
    if {![dict exists $bindings $sym]} {
      error "[$sym name] is not bound"
    }
    set bi [my get $sym]
    lassign $bi bt in
    if {$bt ne "VARIABLE"} {
      error "[$sym name] is not assignable"
    }
    dict set bindings $sym [::list $type $info]
    return
  }
\end{lstlisting}

The \texttt{parent} method yields the current environment instance's linked outer environment.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) parent (internal)}} \\
\textit{Returns:} & an environment \\
\hline
\end{tabular}

\begin{lstlisting}
  method parent {} {
    set outer_env
  }
\end{lstlisting}

The \texttt{names} method returns a Tcl list of all the symbols bound in the current environment instance.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) names (internal)}} \\
\textit{Returns:} & a Tcl list of symbols \\
\hline
\end{tabular}

\begin{lstlisting}
  method names {} {
    dict keys $bindings
  }
\end{lstlisting}

The \texttt{values} method returns a Tcl list of all the binding type/handling info tuples in the current environment instance.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) values (internal)}} \\
\textit{Returns:} & a Tcl list of binding info tuples \\
\hline
\end{tabular}

\begin{lstlisting}
  method values {} {
    dict values $bindings
  }
\end{lstlisting}

The \texttt{tstr} method returns an external representation of the environment instance as a Tcl string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Environment instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    regexp {(\d+)} [self] -> num
    return "#<env-$num>"
  }
}
\end{lstlisting}

\subsection{MkEnv generator}
\label{mkenv-generator}
\index{MkEnv generator}

The \texttt{MkEnv} environment generator can be called with a single argument (the linked-to environment). In that case the parameter and argument lists for the constructor will be empty. If \texttt{MkEnv} is called with three arguments, they are, in order, parameters, arguments, and environment.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkEnv (internal)}} \\
?parms? & a Scheme formals list \\
?vals? & a Tcl list of values \\
env & an environment \\
\textit{Returns:} & an environment \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkEnv {args} {
  if {[llength $args] == 1} {
    set parms ${::#NIL}
    set vals {}
    lassign $args env
  } elseif {[llength $args] == 3} {
    lassign $args parms vals env
  } else {
    error "wrong number of arguments"
  }
  Environment new $parms $vals $env
}
\end{lstlisting}

\subsection{environment? procedure}
\label{environment-procedure}
\index{environment? procedure}

Recognizes an environment by type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{environment? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg environment?

proc ::constcl::environment? {val} {
  typeof? $val Environment
}
\end{lstlisting}

\section{Lexical scoping}
\label{lexical-scoping}
\index{Lexical scoping}

Example:

\begin{verbatim}
ConsTcl> (define (circle-area r) (* pi (* r r)))
ConsTcl> (circle-area 10)
314.1592653589793
\end{verbatim}

During a call to the procedure \texttt{circle-area}, the symbol \texttt{r} is bound to the value 10. But we don't want the binding to go into the global environment, possibly clobbering an earlier definition of \texttt{r}. The solution is to use separate (but linked) environments, making \texttt{r}'s binding a local variable\footnote{See \texttt{https://en.wikipedia.org/wiki/Local\_variable}}\index{local variable} in its own environment, which the procedure will be evaluated in. The symbols \texttt{*} and \texttt{pi} will still be available through the local environment's link to the outer global environment. This is all part of lexical scoping\footnote{See \texttt{https://en.wikipedia.org/wiki/Scope\_(computer\_science)\#Lexical\_scope}}\index{lexical scope}.

In the first image, we see the global environment before we call \texttt{circle-area} (and also the empty null environment which the global environment links to):

\includegraphics{images/env1.png}

During the call. Note how the global \texttt{r} is shadowed by the local one, and how the local environment links to the global one to find \texttt{*} and \texttt{pi}.

\includegraphics{images/env2.png}

After the call, we are back to the first state again.

\includegraphics{images/env1.png}

\chapter{The REPL}
\label{the-repl}

The REPL (read-eval-print loop) is a loop that repeatedly \emph{reads} a Scheme source string from the user through the command \texttt{::constcl::input} (breaking the loop if given an empty line) and \texttt{::constcl::parse}, \emph{evaluates} it using \texttt{::constcl::eval}, and \emph{prints} using \texttt{::constcl::write}.

\textbf{input}

\texttt{input} is modelled after the Python 3 function. It displays a prompt and reads a string.
\index{input}

\begin{lstlisting}
proc ::constcl::input {prompt} {
  puts -nonewline $prompt
  flush stdout
  set buf [gets stdin]
  set openpars [regexp -all -inline {\(} $buf]
  set clsepars [regexp -all -inline {\)} $buf]
  set openbrak [regexp -all -inline {\[} $buf]
  set clsebrak [regexp -all -inline {\]} $buf]
  while {[llength $openpars] > [llength $clsepars] ||
         [llength $openbrak] > [llength $clsebrak]} {
    ::append buf [gets stdin]
    set openpars [regexp -all -inline {\(} $buf]
    set clsepars [regexp -all -inline {\)} $buf]
    set openbrak [regexp -all -inline {\[} $buf]
    set clsebrak [regexp -all -inline {\]} $buf]
  }
  return $buf
}
\end{lstlisting}

\textbf{repl}

\texttt{repl} puts the `loop' in the read-eval-print loop. It repeats prompting for a string until given a blank input. Given non-blank input, it parses and evaluates the string, printing the resulting value.
\index{repl}

\begin{lstlisting}
proc ::repl {{prompt "ConsTcl> "}} {
  set cur_env [::constcl::MkEnv ::constcl::global_env]
  set str [::constcl::input $prompt]
  while {$str ne ""} {
    set expr [::constcl::parse $str]
    set val [::constcl::eval $expr $cur_env]
    ::constcl::write $val
    set str [::constcl::input $prompt]
  }
  $cur_env destroy
}
\end{lstlisting}

Well!

After 1816 lines of code, the interpreter is done.

Now for the built-in types and procedures!

\part{Built-in types and procedures}
\label{builtin-types-and-procedures}

\chapter{The standard library}
\label{the-standard-library}

\section{Equivalence predicates}
\label{equivalence-predicates}
\index{equivalence predicates}

One of the fundamental questions in programming is ``is A equal to B?''. Lisp takes the question and adds ``what does it mean to be equal?''

Lisp has a number of equivalence predicates. ConsTcl, like Scheme, has three. Of the three, \texttt{eq?} generally tests for identity (with exception for numbers), \texttt{eqv?} tests for value equality (except for booleans and procedures, where it tests for identity), and \texttt{equal?} tests for whether the output strings are equal.

\subsection{eq? procedure}
\label{eq-procedure}
\index{eq? procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{eq?, eqv?, equal? (public)}} \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg eq?

proc ::constcl::eq? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq symbol? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq char? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq null? $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq pair? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq string? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq vector? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\textbf{teq} procedure

\texttt{teq} tests for type equality, i.e. that the expressions have the same type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{teq (internal)}} \\
typep & a procedure \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}
\index{teq procedure}

\begin{lstlisting}
proc ::constcl::teq {typep expr1 expr2} {
    return [expr {[T [$typep $expr1]] &&
      [T [$typep $expr2]]}]
}
\end{lstlisting}

\textbf{veq} procedure

\texttt{veq} tests for value equality, i.e. that the expressions have the same value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{veq (internal)}} \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}
\index{veq procedure}

\begin{lstlisting}
proc ::constcl::veq {expr1 expr2} {
    return [expr {[$expr1 value] eq [$expr2 value]}]
}
\end{lstlisting}

\subsection{eqv? procedure}
\label{eqv-procedure}
\index{eqv? procedure}

\begin{lstlisting}
reg eqv?

proc ::constcl::eqv? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } elseif {[teq symbol? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq char? $expr1 $expr2] &&
      [veq $expr1 eq $expr2]} {
    return ${::#t}
  } elseif {[teq null? $expr1 $expr2]} {
    return ${::#t}
  } elseif {[T [pair? $expr1]] &&
      [T [pair? $expr2]] &&
      [$expr1 car] eq [$expr2 car] &&
      [$expr1 cdr] eq [$expr2 cdr]} {
    return ${::#t}
  } elseif {[teq string? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq vector? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return ${::#t}
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{equal? procedure}
\label{equal-procedure}
\index{equal? procedure}

\begin{lstlisting}
reg equal?

proc ::constcl::equal? {expr1 expr2} {
  if {[$expr1 tstr] eq [$expr2 tstr]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\section{Numbers}
\label{numbers}
\index{numbers}

The word `computer' suggests numerical calculations. A programming language is almost no use if it doesn't support at least arithmetic. Scheme has a rich numerical library and many number types that support advanced calculations.

I have only implemented a bare-bones version of Scheme's numerical library, though. The following is a reasonably complete framework for operations on integers and floating-point numbers. No rationals, no complex numbers, no \texttt{gcd} or \texttt{lcm}.

\subsection{Number class}
\label{number-class}
\index{Number class}

The Number class defines what capabilities a number has (in addition to those from the Base class), and also defines the internal representation of a number value expression. A number is stored in an instance in Tcl form, and the \texttt{numval} method yields the Tcl number as result.

\begin{lstlisting}
oo::class create ::constcl::Number {
  superclass ::constcl::Base
  variable value
\end{lstlisting}

The constructor tests its argument against the form of a double-precision floating point number, which admits an integer number as well.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Number constructor (internal)}} \\
val & an external representation of a number \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {val} {
    if {[::string is double -strict $val]} {
      set value $val
    } else {
      ::error "NUMBER expected\n$val"
    }
  }
\end{lstlisting}

The \texttt{zero?} method is a predicate that tells if the stored number is equal to 0.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) zero? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method zero? {} {
    if {$value == 0} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{positive?} method is a predicate that tells if the stored number is greater than 0.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) positive? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method positive? {} {
    if {$value > 0} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{negative?} method is a predicate that tells if the stored number is less than 0.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) negative? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method negative? {} {
    if {$value < 0} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{even?} method is a predicate that tells if the stored number is even.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) even? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method even? {} {
    if {$value % 2 == 0} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{odd?} method is a predicate that tells if the stored number is odd.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) odd? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method odd? {} {
    if {$value % 2 == 1} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{value} method returns the stored number.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) value (internal)}} \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    set value
  }
\end{lstlisting}

The \texttt{numval} method is a synonym for \texttt{value}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) numval (internal)}} \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method numval {} {
    set value
  }
\end{lstlisting}

The \texttt{constant} method signals that the number instance isn't mutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Number instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    return 1
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the stored value as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) tstr (internal)}} \\
\textit{Returns:} & an external representation of a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return $value
  }
}
\end{lstlisting}

\subsection{MkNumber generator}
\label{mknumber-generator}
\index{MkNumber generator}

\texttt{MkNumber} generates a Number object. Short form: \texttt{N}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkNumber (internal)}} \\
str & a string \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkNumber \
  {} ::constcl::Number new
interp alias {} N {} ::constcl::Number new
\end{lstlisting}

\subsection{number? procedure}
\label{number-procedure}
\index{number? procedure}

\texttt{number?} recognizes a number by object type, not by content.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{number? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg number?

proc ::constcl::number? {val} {
  return [typeof? $val Number]
}
\end{lstlisting}

\subsection{= procedure}
\label{-procedure}
\index{= procedure}

\noindent \textbf{<} procedure

\noindent \textbf{>} procedure

\noindent \textbf{<=} procedure

\noindent \textbf{>=} procedure

The predicates \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, and \texttt{>=} are implemented.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{=, <, >, <=, >= (public)}} \\
nums & some numbers \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg =

proc ::constcl::= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(= [
      [lindex $args 0] tstr] ...)"
  }
  if {[::tcl::mathop::== {*}$nums]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{< procedure}

\begin{lstlisting}
reg <

proc ::constcl::< {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(< num ...)"
  }
  if {[::tcl::mathop::< {*}$nums]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{> procedure}

\begin{lstlisting}
reg >

proc ::constcl::> {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(> num ...)"
  }
  if {[::tcl::mathop::> {*}$nums]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{<= procedure}

\begin{lstlisting}
reg <=

proc ::constcl::<= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(<= num ...)"
  }
  if {[::tcl::mathop::<= {*}$nums]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{>= procedure}

\begin{lstlisting}
reg >=

proc ::constcl::>= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(>= num ...)"
  }
  if {[::tcl::mathop::>= {*}$nums]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{zero? procedure}
\label{zero-procedure}
\index{zero? procedure}

The \texttt{zero?} predicate tests if a given number is equal to zero.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{zero? (public)}} \\
num & a number \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg zero?

proc ::constcl::zero? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  return [$num zero?]
}
\end{lstlisting}

\subsection{positive? procedure}
\label{positive-procedure}
\index{positive? procedure}

\noindent \textbf{negative?} procedure

\noindent \textbf{even?} procedure

\noindent \textbf{odd?} procedure

The \texttt{positive?}/\texttt{negative?}/\texttt{even?}/\texttt{odd?} predicates test a number for those traits.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{positive?, negative?, even?, odd? (public)}} \\
num & a number \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg positive?

proc ::constcl::positive? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  return [$num positive?]
}
\end{lstlisting}
\index{negative? procedure}

\begin{lstlisting}
reg negative?

proc ::constcl::negative? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  return [$num negative?]
}
\end{lstlisting}
\index{even? procedure}

\begin{lstlisting}
reg even?

proc ::constcl::even? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  return [$num even?]
}
\end{lstlisting}
\index{odd? procedure}

\begin{lstlisting}
reg odd?

proc ::constcl::odd? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  return [$num odd?]
}
\end{lstlisting}

\subsection{max procedure}
\label{max-procedure}
\index{max procedure}

\textbf{min} procedure

The \texttt{max} function selects the largest number, and the \texttt{min} function selects the smallest number.

Example:

\begin{verbatim}
(max 7 1 10 3)   =>  10
(min 7 1 10 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{max, min (public)}} \\
num & a number \\
nums & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg max

proc ::constcl::max {num args} {
  lappend args $num
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(max num...)"
  }
  N [::tcl::mathfunc::max {*}$nums]
}
\end{lstlisting}
\index{min procedure}

\begin{lstlisting}
reg min

proc ::constcl::min {num args} {
  lappend args $num
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(min num...)"
  }
  N [::tcl::mathfunc::min {*}$nums]
}
\end{lstlisting}

\subsection{+ procedure}
\label{-procedure1}
\index{+ procedure}

\noindent \textbf{*} procedure

\noindent \textbf{-} procedure

\noindent \textbf{/} procedure

The operators \texttt{+}, \texttt{*}, \texttt{-}, and \texttt{/} stand for the respective arithmetic operations. They take a number of operands, but at least one for \texttt{-} and \texttt{/}.

Example:

\begin{verbatim}
(list (+ 2 2) (* 2 2) (- 10 6) (/ 20 5))  => (4 4 4 4)
(+ 21 7 3)                                => 31
(* 21 7 3)                                => 441
(- 21 7 3)                                => 11
(/ 21 7 3)                                => 1
(- 5)                                     => -5
(/ 5)                                     => 0.2
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{+, * (public)}} \\
?nums? & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{-, / (public)}} \\
num & a number \\
?nums? & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg +

proc ::constcl::+ {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(+ num ...)"
  }
  N [::tcl::mathop::+ {*}$nums]
}
\end{lstlisting}
\index{* procedure}

\begin{lstlisting}
reg *

proc ::constcl::* {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(* num ...)"
  }
  N [::tcl::mathop::* {*}$nums]
}
\end{lstlisting}
\index{- procedure}

\begin{lstlisting}
reg -

proc ::constcl::- {num args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(- num ...)"
  }
  N [::tcl::mathop::- [$num numval] {*}$nums]
}
\end{lstlisting}
\index{/ procedure}

\begin{lstlisting}
reg /

proc ::constcl::/ {num args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(/ num ...)"
  }
  N [::tcl::mathop::/ [$num numval] {*}$nums]
}
\end{lstlisting}

\subsection{abs procedure}
\label{abs-procedure}
\index{abs procedure}

The \texttt{abs} function yields the absolute value of a number.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{abs (public)}} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg abs

proc ::constcl::abs {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  if {[T [$num negative?]]} {
    return [N [expr {[$num numval] * -1}]]
  } else {
    return $num
  }
}
\end{lstlisting}

\subsection{quotient procedure}
\label{quotient-procedure}
\index{quotient procedure}

\texttt{quotient} calculates the quotient between two numbers.

Example:

\begin{verbatim}
(quotient 7 3)   =>  2.0
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{quotient (public)}} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg quotient

proc ::constcl::quotient {num1 num2} {
  set q [::tcl::mathop::/ [$num1 numval] \
    [$num2 numval]]
  if {$q > 0} {
    return [N [::tcl::mathfunc::floor $q]]
  } elseif {$q < 0} {
    return [N [::tcl::mathfunc::ceil $q]]
  } else {
    return [N 0]
  }
}
\end{lstlisting}

\subsection{remainder procedure}
\label{remainder-procedure}
\index{remainder procedure}

\texttt{remainder} is similar to \texttt{modulo}, but the remainder is calculated using absolute values for \texttt{num1} and \texttt{num2}, and the result is negative if and only if \texttt{num1} was negative.

Example:

\begin{verbatim}
(remainder 7 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{remainder (public)}} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg remainder

proc ::constcl::remainder {num1 num2} {
  set n [::tcl::mathop::% [[abs $num1] numval] \
    [[abs $num2] numval]]
  if {[T [$num1 negative?]]} {
    set n -$n
  }
  return [N $n]
}
\end{lstlisting}

\subsection{modulo procedure}
\label{modulo-procedure}
\index{modulo procedure}

Example:

\begin{verbatim}
(modulo 7 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{modulo (public)}} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg modulo

proc ::constcl::modulo {num1 num2} {
  return [N [::tcl::mathop::% [$num1 numval] \
    [$num2 numval]]]
}
\end{lstlisting}

\subsection{floor procedure}
\label{floor-procedure}
\index{floor procedure}

\noindent \textbf{ceiling} procedure

\noindent \textbf{truncate} procedure

\noindent \textbf{round} procedure

\texttt{floor}, \texttt{ceiling}, \texttt{truncate}, and \texttt{round} are different methods for converting a floating point number to an integer.

Example:

\begin{verbatim}
(floor 7.5)      =>  7.0
(ceiling 7.5)    =>  8.0
(truncate 7.5)   =>  7.0
(round 7.5)      =>  8
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{floor, ceiling, truncate, round (public)}} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg floor

proc ::constcl::floor {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::floor [$num numval]]
}
\end{lstlisting}
\index{ceiling procedure}

\begin{lstlisting}
reg ceiling

proc ::constcl::ceiling {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::ceil [$num numval]]
}
\end{lstlisting}
\index{truncate procedure}

\begin{lstlisting}
reg truncate

proc ::constcl::truncate {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  if {[T [$num negative?]]} {
    N [::tcl::mathfunc::ceil [$num numval]]
  } else {
    N [::tcl::mathfunc::floor [$num numval]]
  }
}
\end{lstlisting}
\index{round procedure}

\begin{lstlisting}
reg round

proc ::constcl::round {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::round [$num numval]]
}
\end{lstlisting}

\subsection{exp procedure}
\label{exp-procedure}
\index{exp procedure}

\noindent \textbf{log} procedure

\noindent \textbf{sin} procedure

\noindent \textbf{cos} procedure

\noindent \textbf{tan} procedure

\noindent \textbf{asin} procedure

\noindent \textbf{acos} procedure

\noindent \textbf{atan} procedure

The mathematical functions ${e}^{x}$, natural logarithm, sine, cosine, tangent, arcsine, arccosine, and arctangent are calculated by \texttt{exp}, \texttt{log}, \texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{asin}, \texttt{acos}, and \texttt{atan}, respectively. \texttt{atan} can be called both as a unary (one argument) function and a binary (two arguments) one.

Example:

\begin{verbatim}
(let ((x (log 2))) (= 2 (exp x)))   =>  #t
(let* ((a (/ pi 3)) (s (sin a)))
  (= a (asin s)))                   =>  #t
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{exp, log, sin, cos, tan, asin, acos, atan (public)}} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(binary) atan (public)}} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg exp

proc ::constcl::exp {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::exp [$num numval]]
}
\end{lstlisting}
\index{log procedure}

\begin{lstlisting}
reg log

proc ::constcl::log {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::log [$num numval]]
}
\end{lstlisting}
\index{sin procedure}

\begin{lstlisting}
reg sin

proc ::constcl::sin {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::sin [$num numval]]
}
\end{lstlisting}
\index{cos procedure}

\begin{lstlisting}
reg cos

proc ::constcl::cos {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::cos [$num numval]]
}
\end{lstlisting}
\index{tan procedure}

\begin{lstlisting}
reg tan

proc ::constcl::tan {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::tan [$num numval]]
}
\end{lstlisting}
\index{asin procedure}

\begin{lstlisting}
reg asin

proc ::constcl::asin {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::asin [$num numval]]
}
\end{lstlisting}
\index{acos procedure}

\begin{lstlisting}
reg acos

proc ::constcl::acos {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::acos [$num numval]]
}
\end{lstlisting}
\index{atan procedure}

\begin{lstlisting}
reg atan

proc ::constcl::atan {args} {
  if {[llength $args] == 1} {
    set num [lindex $args 0]
    check {number? $num} {
        NUMBER expected\n([pn] [$num tstr])
    }
    N [::tcl::mathfunc::atan [$num numval]]
  } else {
    lassign $args num1 num2
    check {number? $num1} {
        NUMBER expected\n([pn] [$num1 tstr])
    }
    check {number? $num2} {
        NUMBER expected\n([pn] [$num2 tstr])
    }
    N [::tcl::mathfunc::atan2 \
      [$num1 numval] [$num2 numval]]
  }
}
\end{lstlisting}

\subsection{sqrt procedure}
\label{sqrt-procedure}
\index{sqrt procedure}

\texttt{sqrt} calculates the square root.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{sqrt (public)}} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg sqrt

proc ::constcl::sqrt {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
  }
  N [::tcl::mathfunc::sqrt [$num numval]]
}
\end{lstlisting}

\subsection{expt procedure}
\label{expt-procedure}
\index{expt procedure}

\texttt{expt} calculates x to the power y, or ${x}^{y}$.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{expt (public)}} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg expt

proc ::constcl::expt {num1 num2} {
  check {number? $num1} {
      NUMBER expected\n([pn] [$num1 tstr] \
        [$num2 tstr])
  }
  check {number? $num2} {
      NUMBER expected\n([pn] [$num1 tstr] \
        [$num2 tstr])
  }
  N [::tcl::mathfunc::pow [$num1 numval] \
    [$num2 numval]]
}
\end{lstlisting}

\subsection{number->string procedure}
\label{numberstring-procedure}
\index{number->string procedure}

The procedures \texttt{number->string} and \texttt{string->number} convert between number and string with optional radix conversion.

Example:

\begin{verbatim}
(number->string 23)      =>  "23"
(number->string 23 2)    =>  "10111"
(number->string 23 8)    =>  "27"
(number->string 23 16)   =>  "17"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{number->string (public)}} \\
num & a number \\
?radix? & a number \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg number->string

proc ::constcl::number->string {num args} {
  if {[llength $args] == 0} {
    check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
    }
    return [MkString [$num numval]]
  } else {
    lassign $args radix
    check {number? $num} {
      NUMBER expected\n([pn] [$num tstr])
    }
    check {number? $radix} {
      NUMBER expected\n([pn] [$num tstr] \
        [$radix tstr])
    }
    set radices [list [N 2] [N 8] [N 10] [N 16]]
    check {memv $radix $radices} {
      Radix not in 2, 8, 10, 16\n([pn] \
        [$num tstr] [$radix tstr])
    }
    if {[$radix numval] == 10} {
      return [MkString [$num numval]]
    } else {
      return [MkString [base [$radix numval] \
        [$num numval]]]
    }
  }
}
\end{lstlisting}

\texttt{base} is due to Richard Suchenwirth\footnote{See \texttt{https://wiki.tcl-lang.org/page/Based+numbers}}\index{Suchenwirth, Richard}.
\index{base procedure}

\begin{lstlisting}
proc base {base number} {
  set negative [regexp ^-(.+) $number -> number]
  set digits {0 1 2 3 4 5 6 7 8 9 A B C D E F}
  set res {}
  while {$number} {
    set digit [expr {$number % $base}]
    set res [lindex $digits $digit]$res
    set number [expr {$number / $base}]
  }
  if $negative {set res -$res}
  set res
}
\end{lstlisting}

\subsection{string->number procedure}
\label{stringnumber-procedure}
\index{string->number procedure}

As with \texttt{number->string}, above.

Example:

\begin{verbatim}
(string->number "23")        =>  23
(string->number "10111" 2)   =>  23
(string->number "27" 8)      =>  23
(string->number "17" 16)     =>  23
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string->number (public)}} \\
str & a string \\
?radix? & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->number

proc ::constcl::string->number {str args} {
  if {[llength $args] == 0} {
    check {string? $str} {
      STRING expected\n([pn] [$str tstr])
    }
    return [N [$str value]]
  } else {
    lassign $args radix
    check {string? $str} {
      STRING expected\n([pn] [$str tstr])
    }
    set radices [list [N 2] [N 8] [N 10] [N 16]]
    check {memv $radix $radices} {
      Radix not in 2, 8, 10, 16\n([pn] [$str tstr] \
        [$radix tstr])
    }
    if {[$radix numval] == 10} {
      return [N [$str value]]
    } else {
      return [N [
        frombase [$radix numval] [$str value]]]
    }
  }
}
\end{lstlisting}

\texttt{frombase} is due to Richard Suchenwirth\footnote{See \texttt{https://wiki.tcl-lang.org/page/Based+numbers}}\index{Suchenwirth, Richard}.
\index{frombase procedure}

\begin{lstlisting}
proc frombase {base number} {
  set digits {0 1 2 3 4 5 6 7 8 9 A B C D E F}
  set negative [regexp ^-(.+) $number -> number]
  set res 0
  foreach digit [split $number {}] {
    # dv = decimal value
    set dv [lsearch $digits $digit]
    if {$dv < 0 || $dv >= $base} {
      ::error "bad digit $dv for base $base"
    }
    set res [expr {$res * $base + $dv}]
  }
  if $negative {set res -$res}
  set res
}
\end{lstlisting}

\section{Booleans}
\label{booleans}
\index{Booleans}

Booleans are logic values, either true (\texttt{\#t}) or false (\texttt{\#f}). All predicates (procedures whose name end with -?) return boolean values.

\subsection{Pseudo-booleans}
\label{pseudobooleans}
\index{Pseudo-booleans}

All values can be tested for truth (in a conditional form or as arguments to \texttt{and}, \texttt{or}, or \texttt{not}), though. Any value of any type is considered to be true except for \texttt{\#f}.

\subsection{Boolean classes (True and False)}
\label{boolean-classes-true-and-false}
\index{Boolean classes (True and False)}

The Boolean classes are singleton classes with one value each (see page \pageref{a-set-of-source-code-constants}) (the global values \texttt{\#t} and \texttt{\#f}, respectively).

\begin{lstlisting}
oo::singleton create ::constcl::True {
  superclass ::constcl::Base
\end{lstlisting}

The \texttt{tstr} method yields the value \texttt{\#t} as a Tcl string. It is used for error messages.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(True instance) tstr (internal)}} \\
\textit{Returns:} & the external representation of true \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return "#t"
  }
}
\end{lstlisting}

\begin{lstlisting}
oo::singleton create ::constcl::False {
  superclass ::constcl::Base
\end{lstlisting}

The \texttt{tstr} method yields the value \texttt{\#f} as a Tcl string. It is used for error messages.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(False instance) tstr (internal)}} \\
\textit{Returns:} & the external representation of false \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return "#f"
  }
}
\end{lstlisting}

\subsection{MkBoolean generator}
\label{mkboolean-generator}
\index{MkBoolean generator}

Given a string (either \texttt{"\#t"} or \texttt{"\#f"}), \texttt{MkBoolean} generates a boolean.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkBoolean (internal)}} \\
bool & an external representation of a bool \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkBoolean {bool} {
  switch $bool {
    "#t" { return ${::#t} }
    "#f" { return ${::#f} }
    default { ::error "invalid boolean ($bool)" }
  }
}
\end{lstlisting}

\subsection{boolean? procedure}
\label{boolean-procedure}
\index{boolean? procedure}

The \texttt{boolean?} predicate recognizes a boolean by object identity (i.e. is it the true or false constant? If yes, then it is a boolean).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{boolean? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg boolean?

proc ::constcl::boolean? {val} {
  if {$val eq ${::#t} || $val eq ${::#f}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{not procedure}
\label{not-procedure}
\index{not procedure}

The only operations on booleans are the macros \texttt{and} and \texttt{or} (see page \pageref{macros}), and \texttt{not} (logical negation).

Example:

\begin{verbatim}
(not #f)    ==>  #t   ; #f yields #t, all others #f
(not nil)   ==>  #f   ; see?
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{not (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg not

proc ::constcl::not {val} {
  if {$val eq ${::#f}} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\section{Characters}
\label{characters}
\index{Characters}

Characters are any Unicode graphic character, and also space and newline space characters. External representation is \texttt{\#\textbackslash A} (A stands for any character) or \texttt{\#\textbackslash space} or \texttt{\#\textbackslash newline}.

\subsection{Char class}
\label{char-class}
\index{Char class}

The Char class defines what capabilities a character has (in addition to those from the Base class), and also defines the internal representation of a character value expression. A character is stored in an instance as a Tcl character, and the \texttt{char} method yields the character as result.

\begin{lstlisting}
oo::class create ::constcl::Char {
  superclass ::constcl::Base
  variable value
\end{lstlisting}

The constructor tests its argument against the three basic forms of external representation for characters, and stores the corresponding Tcl character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Char constructor (internal)}} \\
val & an external representation of a char \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {val} {
    switch -regexp $val {
      {(?i)#\\space} {
        set val " "
      }
      {(?i)#\\newline} {
        set val "\n"
      }
      {#\\[[:graph:]]} {
        set val [::string index $val 2]
      }
      default {
        ::error "CHAR expected\n$val"
      }
    }
    set value $val
  }
\end{lstlisting}

The \texttt{char} method yields the stored character value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) char (internal)}} \\
\textit{Returns:} & a Tcl character \\
\hline
\end{tabular}

\begin{lstlisting}
  method char {} {
    set value
  }
\end{lstlisting}

The \texttt{alphabetic?} method is a predicate which tests if the stored value is an alphabetic character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) alphabetic? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method alphabetic? {} {
    if {[::string is alpha $value]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{numeric?} method is a predicate which tests if the stored value is a numeric character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) numeric? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method numeric? {} {
    if {[::string is digit $value]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{whitespace?} method is a predicate which tests if the stored value is a whitespace character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) whitespace? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method whitespace? {} {
    if {[::string is space $value]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{upper-case?} method is a predicate which tests if the stored value is an uppercase character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) upper-case? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method upper-case? {} {
    if {[::string is upper $value]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{lower-case?} method is a predicate which tests if the stored value is an lowercase character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) lower-case? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method lower-case? {} {
    if {[::string is lower $value]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{constant} method signals that the character instance isn't mutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    return 1
  }
\end{lstlisting}

The \texttt{value} method is another way to yield the stored value

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) value (internal)}} \\
\textit{Returns:} & a Tcl character \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    return $value
  }
\end{lstlisting}

The \texttt{external} method translates the stored value back to external representation.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) external (internal)}} \\
\textit{Returns:} & an external representation of a char \\
\hline
\end{tabular}

\begin{lstlisting}
  method external {} {
    switch $value {
      " " {
        return "#\\space"
      }
      "\n" {
        return "#\\newline"
      }
      default {
        return "#\\$value"
      }
    }
  }
\end{lstlisting}

The \texttt{display} method is used by the \texttt{display} standard procedure to print the stored value as a character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) display (internal)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method display {port} {
    $port put [my char]
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the stored value as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Char instance) tstr (internal)}} \\
\textit{Returns:} & an external representation of a char \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return [my external]
  }
}
\end{lstlisting}

\subsection{MkChar generator}
\label{mkchar-generator}
\index{MkChar generator}

\texttt{MkChar} generates a character object. If a character object with the same name already exists, that character will be returned, otherwise a fresh character will be created.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkChar (internal)}} \\
char & an external representation of a char \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkChar {char} {
  if {[regexp -nocase {space|newline} $char]} {
      set char [::string tolower $char]
  }
  foreach instance [
    info class instances Char] {
    if {[$instance external] eq $char} {
      return $instance
    }
  }
  return [::constcl::Char new $char]
}
\end{lstlisting}

\subsection{char? procedure}
\label{char-procedure}
\index{char? procedure}

\texttt{char?} recognizes Char values by type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char?

proc ::constcl::char? {val} {
  return [typeof? $val Char]
}
\end{lstlisting}

\subsection{char=? procedure}
\label{char-procedure1}
\index{char=? procedure}

\noindent \textbf{char<?} procedure

\noindent \textbf{char>?} procedure

\noindent \textbf{char<=?} procedure

\noindent \textbf{char>=?} procedure

\texttt{char=?}, \texttt{char<?}, \texttt{char>?}, \texttt{char<=?}, and \texttt{char>=?} compare character values. They only compare two characters at a time.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char=?, char<?, char>? (public)}} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char<=?, char>=? (public)}} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char=?

proc ::constcl::char=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[$char1 char] eq [$char2 char]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char<? procedure}

\begin{lstlisting}
reg char<?

proc ::constcl::char<? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[$char1 char] < [$char2 char]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char>? procedure}

\begin{lstlisting}
reg char>?

proc ::constcl::char>? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[$char1 char] > [$char2 char]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char<=? procedure}

\begin{lstlisting}
reg char<=?

proc ::constcl::char<=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[$char1 char] <= [$char2 char]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char>=? procedure}

\begin{lstlisting}
reg char>=?

proc ::constcl::char>=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[$char1 char] >= [$char2 char]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{char-ci=? procedure}
\label{charci-procedure}
\index{char-ci=? procedure}

\noindent \textbf{char-ci<?} procedure

\noindent \textbf{char-ci>?} procedure

\noindent \textbf{char-ci<=?} procedure

\noindent \textbf{char-ci>=?} procedure

\texttt{char-ci=?}, \texttt{char-ci<?}, \texttt{char-ci>?}, \texttt{char-ci<=?}, and \texttt{char-ci>=?} compare character values in a case insensitive manner. They only compare two characters at a time.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-ci=?, char-ci<?, char-ci>? (public)}} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-ci<=?, char-ci>=? (public)}} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-ci=?

proc ::constcl::char-ci=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[::string tolower [$char1 char]] eq
      [::string tolower [$char2 char]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char-ci<? procedure}

\begin{lstlisting}
reg char-ci<?

proc ::constcl::char-ci<? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[::string tolower [$char1 char]] <
      [::string tolower [$char2 char]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char-ci>? procedure}

\begin{lstlisting}
reg char-ci>?

proc ::constcl::char-ci>? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[::string tolower [$char1 char]] >
      [::string tolower [$char2 char]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char-ci<=? procedure}

\begin{lstlisting}
reg char-ci<=?

proc ::constcl::char-ci<=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[::string tolower [$char1 char]] <=
      [::string tolower [$char2 char]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{char-ci>=? procedure}

\begin{lstlisting}
reg char-ci>=?

proc ::constcl::char-ci>=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 tstr] [$char2 tstr])
  }
  if {[::string tolower [$char1 char]] >=
      [::string tolower [$char2 char]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{char-alphabetic? procedure}
\label{charalphabetic-procedure}
\index{char-alphabetic? procedure}

\noindent \textbf{char-numeric?} procedure

\noindent \textbf{char-whitespace?} procedure

\noindent \textbf{char-upper-case?} procedure

\noindent \textbf{char-lower-case?} procedure

The predicate \texttt{char-alphabetic?} tests if a character is alphabetic, \texttt{char-numeric?} tests if a character is numeric, and \texttt{char-whitespace?} tests if a character is whitespace. \texttt{char-upper-case?} and \texttt{char-lower-case?} test if a character is upper- or lower-case.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-alphabetic?, char-numeric? (public)}} \\
char & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-whitespace? (public)}} \\
char & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-upper-case?, char-lower-case? (public)}} \\
char & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-alphabetic?

proc ::constcl::char-alphabetic? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  return [$char alphabetic?]
}
\end{lstlisting}
\index{char-numeric? procedure}

\begin{lstlisting}
reg char-numeric?

proc ::constcl::char-numeric? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  return [$char numeric?]
}
\end{lstlisting}
\index{char-whitespace? procedure}

\begin{lstlisting}
reg char-whitespace?

proc ::constcl::char-whitespace? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  return [$char whitespace?]
}
\end{lstlisting}
\index{char-upper-case? procedure}

\begin{lstlisting}
reg char-upper-case?

proc ::constcl::char-upper-case? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  return [$char upper-case?]
}
\end{lstlisting}
\index{char-lower-case? procedure}

\begin{lstlisting}
reg char-lower-case?

proc ::constcl::char-lower-case? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  return [$char lower-case?]
}
\end{lstlisting}

\subsection{char->integer procedure}
\label{charinteger-procedure}
\index{char->integer procedure}

\texttt{char->integer} and \texttt{integer->char} convert between characters and their 16-bit numeric codes.

Example:

\begin{verbatim}
(char->integer #\A)   =>  65
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char->integer (public)}} \\
char & a character \\
\textit{Returns:} & an integer \\
\hline
\end{tabular}

\begin{lstlisting}
reg char->integer

proc ::constcl::char->integer {char} {
  return [MkNumber [scan [$char char] %c]]
}
\end{lstlisting}

\subsection{integer->char procedure}
\label{integerchar-procedure}
\index{integer->char procedure}

Example:

\begin{verbatim}
(integer->char 97)   =>  #\a
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{integer->char (public)}} \\
int & an integer \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg integer->char

proc ::constcl::integer->char {int} {
  if {$int == 10} {
    return [MkChar #\\newline]
  } elseif {$int == 32} {
    return [MkChar #\\space]
  } else {
    return [MkChar #\\[format %c [$int numval]]]
  }
}
\end{lstlisting}

\subsection{char-upcase procedure}
\label{charupcase-procedure}
\index{char-upcase procedure}

\textbf{char-downcase} procedure

\texttt{char-upcase} and \texttt{char-downcase} alter the case of a character.

Example:

\begin{verbatim}
(char-upcase #\a)   ==>  #\A
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{char-upcase, char-downcase (public)}} \\
char & a character \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-upcase

proc ::constcl::char-upcase {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  if {[$char char] in [::list " " "\n"]} {
    return $char
  } else {
    return [MkChar [
      ::string toupper [$char external]]]
  }
}
\end{lstlisting}
\index{char-downcase procedure}

\begin{lstlisting}
reg char-downcase

proc ::constcl::char-downcase {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char tstr])
  }
  if {[$char char] in [::list " " "\n"]} {
    return $char
  } else {
    return [MkChar [
      ::string tolower [$char external]]]
  }
}
\end{lstlisting}

\section{Control}
\label{control}
\index{Control}

This section concerns itself with procedures and the application of the same.

A \texttt{Procedure} object is a closure\footnote{See \texttt{https://en.wikipedia.org/wiki/Closure\_(computer\_programming)}}\index{closure}, storing the procedure's parameter list, the body, and the environment that is current when the object is created, i.e. when the procedure is defined (see page \pageref{procedure-definition}).

When a \texttt{Procedure} object is called, the body is evaluated in a new environment where the parameters are given values from the argument list and the outer link goes to the closure environment.

\subsection{Procedure class}
\label{procedure-class}
\index{Procedure class}

The Procedure class defines what capabilities a procedure has (in addition to those from the Base class), and also defines the internal representation of a procedure value expression. A procedure is stored in an instance as a tuple of formal parameters, body, and closed over environment. There is no method that yields the stored values.

\begin{lstlisting}
catch { ::constcl::Procedure destroy }

oo::class create ::constcl::Procedure {
  superclass ::constcl::Base
  variable parms body env
\end{lstlisting}

The \texttt{Procedure} constructor simply copies its arguments into the instance variables \texttt{parms}, \texttt{body}, and \texttt{env}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Procedure constructor (internal)}} \\
p & a Scheme formals list \\
b & an expression \\
e & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {p b e} {
    set parms $p
    set body $b
    set env $e
  }
}
\end{lstlisting}

The \texttt{call} method makes each argument a tuple of \texttt{VARIABLE} and the argument value, storing the argument tuples in the list \texttt{vals}. Then an environment is created with the stored \texttt{parms}, \texttt{vals}, and stored \texttt{env} as arguments. The stored \texttt{body} is evaluated in this environment and the result is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Procedure instance) call (internal)}} \\
args & some values \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
oo::define ::constcl::Procedure method call {args} {
  set vals [lmap a $args {list VARIABLE $a}]
  ::constcl::eval $body [
    ::constcl::MkEnv $parms $vals $env]
}
\end{lstlisting}

The \texttt{value} method is a dummy.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Procedure instance) value (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
oo::define ::constcl::Procedure method value {} {}
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the procedure. It is used by error messages and by the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Procedure instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
oo::define ::constcl::Procedure method tstr {} {
  regexp {(\d+)} [self] -> num
  return "#<proc-$num>"
}
\end{lstlisting}

\subsection{MkProcedure generator}
\label{mkprocedure-generator}
\index{MkProcedure generator}

\texttt{MkProcedure} generates a Procedure object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkProcedure (internal)}} \\
parms & a Scheme formals list \\
body & an expression \\
env & an environment \\
\textit{Returns:} & a procedure \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkProcedure \
  {} ::constcl::Procedure new
\end{lstlisting}

\subsection{procedure? procedure}
\label{procedure-procedure}
\index{procedure? procedure}

\texttt{procedure?} recognizes procedures either by type or by namespace, for procedures that are Tcl commands.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{procedure? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg procedure?

proc ::constcl::procedure? {val} {
  if {[typeof? $val Procedure] eq ${::#t}} {
    return ${::#t}
  } elseif {[::string match "::constcl::*" $val]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{apply procedure}
\label{apply-procedure}
\index{apply procedure}

\texttt{apply} applies a procedure to a Lisp list of Lisp arguments.

Example:

\begin{verbatim}
(apply + (list 2 3))   =>  5
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{apply (public)}} \\
pr & a procedure \\
vals & a Lisp list of values \\
\textit{Returns:} & what pr returns \\
\hline
\end{tabular}

\begin{lstlisting}
reg apply

proc ::constcl::apply {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([pn] [$pr tstr] ...)
  }
  invoke $pr $vals
}
\end{lstlisting}

\subsection{map procedure}
\label{map-procedure}
\index{map procedure}

\texttt{map} iterates over one or more lists, taking an element from each list to pass to a procedure as an argument. The Lisp list of the results of the invocations is returned.

Example:

\begin{verbatim}
(map + '(1 2 3) '(5 6 7))   => (6 8 10)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{map (public)}} \\
pr & a procedure \\
args & some lists \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg map

proc ::constcl::map {pr args} {
  check {procedure? $pr} {
    PROCEDURE expected\n([pn] [$pr tstr] ...)
  }
\end{lstlisting}

The procedure iterates over the list of argument lists, converting each of them to a Tcl list.

\begin{lstlisting}
  set arglists $args
  for {set i 0} \
    {$i < [llength $arglists]} \
    {incr i} {
    lset arglists $i [
      splitlist [lindex $arglists $i]]
  }
\end{lstlisting}

The procedure iterates over the items in each argument list (\texttt{item}) and each argument list (\texttt{arglist}), building a list of actual parameters (\texttt{actuals}). Then \texttt{pr} is invoked on the Lisp list of actuals and the result list-appended to \texttt{res}. After all the iterations, the Lisp list of items in \texttt{res} is returned.

\begin{lstlisting}
  set res {}
  for {set item 0} \
    {$item < [llength [lindex $arglists 0]]} \
    {incr item} {
    set actuals {}
    for {set arglist 0} \
      {$arglist < [llength $arglists]} \
      {incr arglist} {
      lappend actuals [
        lindex $arglists $arglist $item]
    }
    lappend res [invoke $pr [list {*}$actuals]]
  }
  return [list {*}$res]
}
\end{lstlisting}

\subsection{for-each procedure}
\label{foreach-procedure}
\index{for-each procedure}

\texttt{for-each} iterates over one or more lists, taking an element from each list to pass to a procedure as an argument. The empty list is returned.

Example: (from R5RS; must be pasted as a oneliner for the \texttt{tkcon} repl to stomach it.)

\begin{verbatim}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                        =>  #(0 1 4 9 16)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{for-each (public)}} \\
pr & a procedure \\
args & some lists \\
\textit{Returns:} & the empty list \\
\hline
\end{tabular}

\begin{lstlisting}
reg for-each

proc ::constcl::for-each {proc args} {
  check {procedure? $proc} {
    PROCEDURE expected\n([pn] [$proc tstr] ...)
  }
\end{lstlisting}

The procedure iterates over the list of argument lists, converting each of them to a Tcl list.

\begin{lstlisting}
  set arglists $args
  for {set i 0} \
    {$i < [llength $arglists]} \
    {incr i} {
    lset arglists $i [
      splitlist [lindex $arglists $i]]
  }
\end{lstlisting}

The procedure iterates over the items in each argument list (\texttt{item}) and each argument list (\texttt{arglist}), building a list of actual parameters (\texttt{actuals}). Then \texttt{proc} is invoked on the Lisp list of actuals. After all the iterations, the empty list is returned.

\begin{lstlisting}
  for {set item 0} \
    {$item < [llength [lindex $arglists 0]]} \
    {incr item} {
    set actuals {}
    for {set arglist 0} \
      {$arglist < [llength $arglists]} \
      {incr arglist} {
      lappend actuals [
        lindex $arglists $arglist $item]
    }
    invoke $proc [list {*}$actuals]
  }
  return ${::#NIL}
}
\end{lstlisting}

\section{Input and output}
\label{input-and-output}
\index{Input and output}

Like most programming languages, Scheme has input and output facilities beyond mere \texttt{read} and \texttt{write}. I/O is based on the \emph{port} abstraction (see page \pageref{ports}) of a character supplying or receiving device. There are four kinds of ports:

\begin{enumerate}
\item file input (InputPort)
\item file output (OutputPort)
\item string input (StringInputPort)
\item string output (StringOutputPort)
\end{enumerate}

and there is also the \texttt{Port} kind, which isn't used other than as a base class.

\subsection{Port class}
\label{port-class}
\index{Port class}

\begin{lstlisting}
oo::abstract create ::constcl::Port {
  superclass ::constcl::Base
  variable handle
\end{lstlisting}

The \texttt{Port} constructor uses a fake argument to store a value in the instance variable \texttt{handle}. If the value isn't provided, \texttt{handle} gets the value of the empty list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Port constructor (internal)}} \\
?h? & a channel handle \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {args} {
    if {[llength $args]} {
      lassign $args handle
    } else {
      set handle ${::#NIL}
    }
  }
\end{lstlisting}

The \texttt{handle} method yields the stored handle value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) handle (internal)}} \\
\textit{Returns:} & a channel handle or NIL \\
\hline
\end{tabular}

\begin{lstlisting}
  method handle {} {
    set handle
  }
\end{lstlisting}

The \texttt{close} method acts to close the stored handle's channel, and sets the stored handle to the empty list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(concrete instance) close (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method close {} {
    close $handle
    set handle ${::#NIL}
    return
  }
}
\end{lstlisting}

\subsection{InputPort class}
\label{inputport-class}
\index{InputPort class}

The InputPort class extends Port with the ability to open a channel for reading, and to get a character from the channel and to detect end-of-file.

\begin{lstlisting}
oo::class create ::constcl::InputPort {
  superclass ::constcl::Port
  variable handle
\end{lstlisting}

The InputPort \texttt{open} method takes a file name and attempts to open it for reading. If it succeeds, it sets the stored handle to the opened channel. If it fails, it sets the stored handle to the empty list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(InputPort instance) open (internal)}} \\
name & a filename string \\
\textit{Returns:} & a channel handle or NIL \\
\hline
\end{tabular}

\begin{lstlisting}
  method open {name} {
    try {
      set handle [open [$name value] "r"]
    } on error {} {
      set handle ${::#NIL}
    }
    return $handle
  }
\end{lstlisting}

The \texttt{get} method reads one character from the channel of the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(InputPort instance) get (internal)}} \\
\textit{Returns:} & a Tcl character \\
\hline
\end{tabular}

\begin{lstlisting}
  method get {} {
    chan read $handle 1
  }
\end{lstlisting}

The \texttt{eof} method reports end-of-file status on the channel of the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(InputPort instance) eof (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method eof {} {
    chan eof $handle
  }
\end{lstlisting}

The \texttt{copy} method returns a new instance of InputPort which is a copy of this instance, sharing the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(InputPort instance) copy (internal)}} \\
\textit{Returns:} & an input port \\
\hline
\end{tabular}

\begin{lstlisting}
  method copy {} {
    ::constcl::InputPort new $handle
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the port as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(InputPort instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    regexp {(\d+)} [self] -> num
    return "#<input-port-$num>"
  }
}
\end{lstlisting}

\subsection{MkInputPort generator}
\label{mkinputport-generator}
\index{MkInputPort generator}

\texttt{MkInputPort} generates an InputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkInputPort (internal)}} \\
?handle? & a channel handle \\
\textit{Returns:} & an input port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkInputPort \
  {} ::constcl::InputPort new
\end{lstlisting}

\subsection{StringInputPort class}
\label{stringinputport-class}
\index{StringInputPort class}

The StringInputPort class extends Port with the ability to get a character from the buffer and detect end-of-file. It turns \texttt{open} and \texttt{close} into no-op methods.

\begin{lstlisting}
oo::class create ::constcl::StringInputPort {
  superclass ::constcl::Port
  variable buffer read_eof
\end{lstlisting}

The StringInputPort constructor simply copies a given string into the stored buffer and sets the \texttt{read\_eof} state variable to 0.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{StringInputPort constructor (internal)}} \\
str & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {str} {
    set buffer $str
    set read_eof 0
  }
\end{lstlisting}

The \texttt{open} and \texttt{close} methods are present but don't do anything.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) open (internal)}} \\
name & a filename string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) close (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method open {name} {}
  method close {} {}
\end{lstlisting}

The StringInputPort \texttt{get} method reads one character from the buffer. If the buffer is empty, \texttt{\#EOF} is returned and \texttt{read\_eof} is set to 1. The buffer is reduced by one character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) get (internal)}} \\
\textit{Returns:} & a Tcl character or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
  method get {} {
    if {[::string length $buffer] == 0} {
      set read_eof 1
      return #EOF
    }
    set c [::string index $buffer 0]
    set buffer [::string range $buffer 1 end]
    return $c
  }
\end{lstlisting}

The \texttt{eof} method reports end-of-file status on the buffer.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) eof (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method eof {} {
    return $read_eof
  }
\end{lstlisting}

The \texttt{copy} method creates a new instance with a (non-shared) copy of the buffer such as it is at this point in time.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) copy (internal)}} \\
\textit{Returns:} & a string input port \\
\hline
\end{tabular}

\begin{lstlisting}
  method copy {} {
    ::constcl::StringInputPort new $buffer
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the string input port as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringInputPort instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    regexp {(\d+)} [self] -> num
    return "#<string-input-port-$num>"
  }
}
\end{lstlisting}

\subsection{MkStringInputPort generator}
\label{mkstringinputport-generator}
\index{MkStringInputPort generator}

\texttt{MkStringInputPort} generates a StringInputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkStringInputPort (internal)}} \\
str & a string \\
\textit{Returns:} & a string input port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkStringInputPort \
  {} ::constcl::StringInputPort new
\end{lstlisting}

\subsection{OutputPort class}
\label{outputport-class}
\index{OutputPort class}

OutputPort extends Port with the ability to open a channel for writing, and to put a string through the channel, print a newline, and flush the channel.

\begin{lstlisting}
oo::class create ::constcl::OutputPort {
  superclass ::constcl::Port
  variable handle
\end{lstlisting}

The OutputPort \texttt{open} method attempts to open a channel for writing on a given file name, setting the stored handle to the channel if it succeeds and to the empty list if it fails.

The \texttt{open} method is locked with an error command for safety. Only remove this line if you really know what you're doing: once it is unlocked, the \texttt{open} method can potentially overwrite existing files.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(OutputPort instance) open (internal)}} \\
name & a filename string \\
\textit{Returns:} & a channel handle or NIL \\
\hline
\end{tabular}

\begin{lstlisting}
  method open {name} {
    ::error "remove this line to use"
    try {
      set handle [open [$name value] "w"]
    } on error {} {
      set handle ${::#NIL}
    }
    return $handle
  }
\end{lstlisting}

The OutputPort \texttt{put} method outputs a string on the channel in the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(OutputPort instance) put (internal)}} \\
str & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method put {str} {
    puts -nonewline $handle $str
  }
\end{lstlisting}

The \texttt{newline} method prints a newline on the channel in the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(OutputPort instance) newline (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method newline {} {
    puts $handle {}
  }
\end{lstlisting}

The \texttt{flush} method flushes the output channel in the stored handle.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(OutputPort instance) flush (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method flush {} {
    flush $handle
  }
\end{lstlisting}

The \texttt{copy} method returns a new instance of OutputPort which is a copy of this instance, sharing the stored handle.

\begin{lstlisting}
  method copy {} {
    ::constcl::OutputPort new $handle
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the port as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(OutputPort instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    regexp {(\d+)} [self] -> num
    return "#<output-port-$num>"
  }
}
\end{lstlisting}

\subsection{MkOutputPort generator}
\label{mkoutputport-generator}
\index{MkOutputPort generator}

\texttt{MkOutputPort} generates an OutputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkOutputPort (internal)}} \\
?handle? & a channel handle \\
\textit{Returns:} & an output port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkOutputPort \
  {} ::constcl::OutputPort new
\end{lstlisting}

\subsection{StringOutputPort class}
\label{stringoutputport-class}
\index{StringOutputPort class}

StringOutputPort extends Port with the ability to put strings into a string buffer. The \texttt{tostring} method yields the current contents of the buffer.

\begin{lstlisting}
oo::class create ::constcl::StringOutputPort {
  superclass ::constcl::Port
  variable buffer
\end{lstlisting}

The StringOutputPort constructor uses a fake argument to optionally initialize the internal buffer, which otherwise is empty.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{StringOutputPort constructor (internal)}} \\
?str? & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {args} {
    if {[llength $args]} {
      lassign $args str
      set buffer $str
    } else {
      set buffer {}
    }
  }
\end{lstlisting}

The \texttt{open} and \texttt{close} methods are present but don't do anything.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) open (internal)}} \\
name & a filename string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) close (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method open {name} {}
  method close {} {}
\end{lstlisting}

The StringOutputPort \texttt{put} method appends a string to the internal buffer.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) put (internal)}} \\
str & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method put {str} {
    append buffer $str
    return
  }
\end{lstlisting}

The \texttt{newline} method appends a newline character to the internal buffer.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) newline (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method newline {} {
    append buffer \n
  }
\end{lstlisting}

The \texttt{flush} method is present but does nothing.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) flush (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method flush {} {}
\end{lstlisting}

The \texttt{tostring} method dumps the internal buffer as a string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) tostring (internal)}} \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tostring {} {
    MkString $buffer
  }
\end{lstlisting}

The \texttt{copy} method returns a new instance of StringOutputPort which is a copy of this instance, with a (non-shared) copy of the internal buffer such as it is at this point in time.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) copy (internal)}} \\
\textit{Returns:} & a string output port \\
\hline
\end{tabular}

\begin{lstlisting}
  method copy {} {
    ::constcl::StringOutputPort new $buffer
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the string output port as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(StringOutputPort instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    regexp {(\d+)} [self] -> num
    return "#<string-output-port-$num>"
  }
}
\end{lstlisting}

\subsection{MkStringOutputPort generator}
\label{mkstringoutputport-generator}
\index{MkStringOutputPort generator}

\texttt{MkStringOutputPort} generates a StringOutputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkStringOutputPort (internal)}} \\
?str? & a string \\
\textit{Returns:} & a string output port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkStringOutputPort \
  {} ::constcl::StringOutputPort new
\end{lstlisting}

\textbf{Input\_Port} variable

\textbf{Output\_port} variable

These two variables store the current configuration of the shared input and output ports globally. They are initially set to standard input and output respectively.

\begin{lstlisting}
set ::constcl::Input_port [
  ::constcl::MkInputPort stdin]
set ::constcl::Output_port [
  ::constcl::MkOutputPort stdout]
\end{lstlisting}

\subsection{port? procedure}
\label{port-procedure}
\index{port? procedure}

\texttt{port?} recognizes Port objects, i.e. all kinds of ports.

\begin{lstlisting}
reg port?

proc ::constcl::port? {val} {
  typeof? $val Port
}
\end{lstlisting}

\subsection{call-with-input-file procedure}
\label{callwithinputfile-procedure}
\index{call-with-input-file procedure}

\texttt{call-with-input-file} opens a file for input and passes the port to \texttt{proc}. The file is closed again once \texttt{proc} returns. The result of the call is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{call-with-input-file (public)}} \\
filename & a filename string \\
proc & a procedure \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg call-with-input-file

proc ::constcl::call-with-input-file {filename proc} {
  set port [open-input-file $filename]
  set res [invoke $proc [list $port]]
  close-input-port $port
  $port destroy
  return $res
}
\end{lstlisting}

\subsection{call-with-output-file procedure}
\label{callwithoutputfile-procedure}
\index{call-with-output-file procedure}

\texttt{call-with-output-file} opens a file for output and passes the port to \texttt{proc}. The file is closed again once \texttt{proc} returns. The result of the call is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{call-with-output-file (public)}} \\
filename & a filename string \\
proc & a procedure \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg call-with-output-file

proc ::constcl::call-with-output-file {filename proc} {
  set port [open-output-file $filename]
  set res [invoke $proc [list $port]]
  close-output-port $port
  $port destroy
  return $res
}
\end{lstlisting}

\subsection{input-port? procedure}
\label{inputport-procedure}
\index{input-port? procedure}

\texttt{input-port?} recognizes an \texttt{InputPort} or \texttt{StringInputPort} object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{input-port? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg input-port?

proc ::constcl::input-port? {val} {
  if {[T typeof? $val InputPort]} {
    return ${::#t}
  } elseif {[T typeof? $val StringInputPort]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{output-port? procedure}
\label{outputport-procedure}
\index{output-port? procedure}

\texttt{output-port?} recognizes an \texttt{OutputPort} or \texttt{StringOutputPort} object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{output-port? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg output-port?

proc ::constcl::output-port? {val} {
  if {[T typeof? $val OutputPort]} {
    return ${::#t}
  } elseif {[T typeof? $val StringOutputPort]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{current-input-port procedure}
\label{currentinputport-procedure}
\index{current-input-port procedure}

\texttt{current-input-port} makes a copy of the current shared input port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{current-input-port (public)}} \\
\textit{Returns:} & a port \\
\hline
\end{tabular}

\begin{lstlisting}
reg current-input-port

proc ::constcl::current-input-port {} {
  return [$::constcl::Input_port copy]
}
\end{lstlisting}

\subsection{current-output-port procedure}
\label{currentoutputport-procedure}
\index{current-output-port procedure}

\texttt{current-output-port} makes a copy of the current shared output port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{current-output-port (public)}} \\
\textit{Returns:} & a port \\
\hline
\end{tabular}

\begin{lstlisting}
reg current-output-port

proc ::constcl::current-output-port {} {
  return [$::constcl::Output_port copy]
}
\end{lstlisting}

\subsection{with-input-from-file procedure}
\label{withinputfromfile-procedure}
\index{with-input-from-file procedure}

\texttt{with-input-from-file} opens a file for input and calls a `thunk' while the file is open. The file is closed again when the call is done.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{with-input-from-file (public)}} \\
filename & a filename string \\
thunk & a procedure \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg with-input-from-file

proc ::constcl::with-input-from-file {filename thunk} {
  set newport [open-input-file $filename]
  if {[$newport handle] ne ${::#NIL}} {
    set oldport $::constcl::Input_port
    set ::constcl::Input_port $newport
    $thunk call
    set ::constcl::Input_port $oldport
    close-input-port $newport
  }
  $newport destroy
}
\end{lstlisting}

\subsection{with-output-to-file procedure}
\label{withoutputtofile-procedure}
\index{with-output-to-file procedure}

\texttt{with-output-to-file} opens a file for output and calls a `thunk' while the file is open. The file is closed again when the call is done.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{with-output-to-file (public)}} \\
filename & a filename string \\
thunk & a procedure \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg with-output-to-file

proc ::constcl::with-output-to-file {filename thunk} {
  set newport [open-output-file $filename]
  if {[$newport handle] ne ${::#NIL}} {
    set oldport $::constcl::Output_port
    set ::constcl::Output_port $newport
    $thunk call
    set ::constcl::Output_port $oldport
    close-input-port $newport
  }
  $newport destroy
}
\end{lstlisting}

\subsection{open-input-file procedure}
\label{openinputfile-procedure}
\index{open-input-file procedure}

\texttt{open-input-file} opens a file for input and returns the port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{open-input-file (public)}} \\
filename & a filename string \\
\textit{Returns:} & an input port \\
\hline
\end{tabular}

\begin{lstlisting}
reg open-input-file

proc cnof {} {return "could not open file"}
proc fae {} {return "file already exists"}

proc ::constcl::open-input-file {filename} {
  set p [MkInputPort]
  $p open $filename
  if {[$p handle] eq ${::#NIL}} {
    set fn [$filename value]
    error "open-input-file: [cnof] $fn"
  }
  return $p
}
\end{lstlisting}

\subsection{open-output-file procedure}
\label{openoutputfile-procedure}
\index{open-output-file procedure}

\texttt{open-output-file} opens a file for output and returns the port. Throws an error if the file already exists.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{open-output-file (public)}} \\
filename & a filename string \\
\textit{Returns:} & an output port \\
\hline
\end{tabular}

\begin{lstlisting}
reg open-output-file

proc ::constcl::open-output-file {filename} {
  if {[file exists $filename]} {
    error "open-output-file: [fae] $filename"
  }
  set p [MkOutputPort]
  $p open $filename
  if {[$p handle] eq ${::#NIL}} {
    error "open-output-file: [cnof] $filename"
  }
  return $p
}
\end{lstlisting}

\subsection{close-input-port procedure}
\label{closeinputport-procedure}
\index{close-input-port procedure}

\texttt{close-input-port} closes an input port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{close-input-port (public)}} \\
port & an input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg close-input-port

proc ::constcl::close-input-port {port} {
  if {[$port handle] eq "stdin"} {
    error "don't close the standard input port"
  }
  $port close
}
\end{lstlisting}

\subsection{close-output-port procedure}
\label{closeoutputport-procedure}
\index{close-output-port procedure}

\texttt{close-output-port} closes an output port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{close-output-port (public)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg close-output-port

proc ::constcl::close-output-port {port} {
  if {[$port handle] eq "stdout"} {
    error "don't close the standard output port"
  }
  $port close
}
\end{lstlisting}

\texttt{write} is implemented in the output (see page \pageref{output}) chapter.

\texttt{display} is implemented in the same chapter.

\subsection{newline procedure}
\label{newline-procedure}
\index{newline procedure}

\texttt{newline} outputs a newline character. Especially helpful when using \texttt{display} for output, since it doesn't end lines with newline.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{newline (public)}} \\
?port? & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg newline

proc ::constcl::newline {args} {
  if {[llength $args]} {
    lassign $args port
  } else {
    set port [current-output-port]
  }
  $port newline
}
\end{lstlisting}

\textbf{load}

\texttt{load} reads a Scheme source file and evals the expressions in it in the global environment. The procedure is a ConsTcl mix of Scheme calls and Tcl syntax.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{load (public)}} \\
filename & a filename string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg load

proc ::constcl::load {filename} {
  try {
    open-input-file $filename
  } on ok port {
  } on error {} {
    return
  }
  if {[$port handle] ne ${::#NIL}} {
    set expr [read $port]
    while {$expr ne "#EOF"} {
      eval $expr
      set expr [read $port]
    }
    close-input-port $port
  }
  $port destroy
}
\end{lstlisting}

\section{Pairs and lists}
\label{pairs-and-lists}
\index{Pairs and lists}

List processing is another of Lisp's great strengths. In Lisp, lists (which are actually tree structures) are composed of \emph{pairs}, which in the most elementary case are constructed using calls to the \texttt{cons} function. Example:

\begin{verbatim}
(cons 'a
  (cons 'b (cons (cons 'c '()) '())))  ==> (a b (c))
\end{verbatim}

A \emph{pair} consists of a pair of pointers, named the \emph{car} and the \emph{cdr}\footnote{There are historical, not very interesting, reasons for this naming.}.

\includegraphics{images/pair.png}

The example above would look like this (we'll name it L). \texttt{car L} is the symbol \texttt{a}, and \texttt{cdr L} is the list \texttt{(b (c))}. \texttt{cadr L} (the \texttt{car} of \texttt{cdr L}) is \texttt{b}.

\includegraphics{images/tree.png}

All program source code has a tree structure, even though this is usually mostly hidden by the language. Lisp, on the other hand, makes the tree structure fully explicit by using the same notation for source code as for list data (hence all the parentheses).

\subsection{Pair class}
\label{pair-class}
\index{Pair class}

The Pair class defines what capabilities a pair has (in addition to those from the Base class), and also defines the internal representation of a pair value expression. A pair is stored in an instance as a couple of pointers, and the \texttt{car} and \texttt{cdr} methods yield each of them as result.

\begin{lstlisting}
oo::class create ::constcl::Pair {
  superclass ::constcl::Base
  variable car cdr constant
\end{lstlisting}

The constructor stores values into the \texttt{car} and \texttt{cdr} variables, and sets \texttt{constant} to 0, denoting that the pair is mutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Pair constructor (internal)}} \\
a & a value \\
d & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {a d} {
    set car $a
    set cdr $d
    set constant 0
  }
\end{lstlisting}

The \texttt{value} method is a synonym for \texttt{tstr}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) value (internal)}} \\
\textit{Returns:} & an external representation of a pair \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    my tstr
  }
\end{lstlisting}

The \texttt{car} method returns the value stored in the \texttt{car} variable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) car (internal)}} \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
  method car {} {
    set car
  }
\end{lstlisting}

The \texttt{cdr} method returns the value stored in the \texttt{cdr} variable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) cdr (internal)}} \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
  method cdr {} {
    set cdr
  }
\end{lstlisting}

The \texttt{set-car!} method modifies the value stored in the \texttt{car} variable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) set-car! (internal)}} \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
  method set-car! {val} {
    ::constcl::check {my mutable?} {
      Can't modify a constant pair
    }
    set car $val
    self
  }
\end{lstlisting}

The \texttt{set-cdr!} method modifies the value stored in the \texttt{cdr} variable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) set-cdr! (internal)}} \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
  method set-cdr! {val} {
    ::constcl::check {my mutable?} {
      Can't modify a constant pair
    }
    set cdr $val
    self
  }
\end{lstlisting}

The \texttt{mkconstant} method changes the instance from mutable to immutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) mkconstant (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method mkconstant {} {
    set constant 1
    return
  }
\end{lstlisting}

The \texttt{constant} method signals whether the pair instance is immutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    return $constant
  }
\end{lstlisting}

The \texttt{mutable?} method is a predicate that tells if the pair instance is mutable or not.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) mutable? (internal)}} \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method mutable? {} {
    expr {$constant ? ${::#f} : ${::#t}}
  }
\end{lstlisting}

The \texttt{write} method prints an external representation of the pair on the given port.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) write (internal)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method write {port} {
    $port put "("
    ::constcl::write-pair $port [self]
    $port put ")"
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the pair instance as a Tcl string. It is used by error messages.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Pair instance) tstr (internal)}} \\
\textit{Returns:} & an external representation of a pair \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    format "(%s)" [::constcl::tstr-pair [self]]
  }
}
\end{lstlisting}

\subsection{MkPair generator}
\label{mkpair-generator}
\index{MkPair generator}

\texttt{MkPair} generates a Pair object. Shorter form: \texttt{cons}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkPair (internal)}} \\
car & a value \\
cdr & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkPair \
  {} ::constcl::Pair new
\end{lstlisting}

\subsection{pair? procedure}
\label{pair-procedure}
\index{pair? procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pair? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg pair?

proc ::constcl::pair? {val} {
  typeof? $val Pair
}
\end{lstlisting}

\subsection{tstr-pair procedure}
\label{tstrpair-procedure}
\index{tstr-pair procedure}

Helper procedure to make a string representation of a list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{tstr-pair (internal)}} \\
pair & a pair \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::tstr-pair {pair} {
  # take a pair and make a string of the car
  # and the cdr of the stored value
  set str {}
  set a [car $pair]
  set d [cdr $pair]
  ::append str [$a tstr]
  if {[T [pair? $d]]} {
    # cdr is a cons pair
    ::append str " "
    ::append str [tstr-pair $d]
  } elseif {[T [null? $d]]} {
    # cdr is nil
    return $str
  } else {
    # it is an atom
    ::append str " . "
    ::append str [$d tstr]
  }
  return $str
}
\end{lstlisting}

\subsection{cons procedure}
\label{cons-procedure}
\index{cons procedure}

\texttt{cons} joins two values in a pair; useful in many operations such as pushing a new value onto a list.

Example:

\begin{verbatim}
(cons 'a 'b)              ==>  (a . b)
(cons 'a nil)             ==>  (a)
(cons 'a (cons 'b nil))   ==>  (a b)
\end{verbatim}

\begin{figure}[h!]\includegraphics{images/consing.png}\captionsetup{labelformat=empty}\caption{Examples of consing}\label{fig:examples-of-consing}\end{figure}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{cons (public)}} \\
car & a value \\
cdr & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg cons

proc ::constcl::cons {car cdr} {
  MkPair $car $cdr
}
\end{lstlisting}

\subsection{car procedure}
\label{car-procedure}
\index{car procedure}

\texttt{car} gets the contents of the first cell in a pair.

Example:

\begin{verbatim}
(car '(a b))   ==>  a
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{car (public)}} \\
pair & a pair \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg car

proc ::constcl::car {pair} {
  $pair car
}
\end{lstlisting}

\subsection{cdr procedure}
\label{cdr-procedure}
\index{cdr procedure}

\texttt{cdr} gets the contents of the second cell in a pair.

Example:

\begin{verbatim}
(cdr '(a b))   ==>  (b)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{cdr (public)}} \\
pair & a pair \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg cdr

proc ::constcl::cdr {pair} {
  $pair cdr
}
\end{lstlisting}

\textbf{caar} to \textbf{cddddr}

\texttt{car} and \texttt{cdr} can be combined to form 28 composite access operations.
\index{caar procedure}

\begin{lstlisting}
foreach ads {
  aa
  ad
  da
  dd
  aaa
  ada
  daa
  dda
  aad
  add
  dad
  ddd
  aaaa
  adaa
  daaa
  ddaa
  aada
  adda
  dada
  ddda
  aaad
  adad
  daad
  ddad
  aadd
  addd
  dadd
  dddd
} {
    reg c${ads}r

    proc ::constcl::c${ads}r {x} "
        foreach c \[lreverse \[split $ads {}\]\] {
            if {\$c eq \"a\"} {
                set x \[car \$x\]
            } else {
                set x \[cdr \$x\]
            }
        }
        return \$x
    "

}
\end{lstlisting}

\subsection{set-car! procedure}
\label{setcar-procedure}
\index{set-car"! procedure}

\texttt{set-car!} sets the contents of the first cell in a pair.

Example:

\begin{verbatim}
(let ((pair (cons 'a 'b)) (val 'x))
  (set-car! pair val))                ==>  (x . b)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{set-car! (public)}} \\
pair & a pair \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg set-car!

proc ::constcl::set-car! {pair val} {
  $pair set-car! $val
}
\end{lstlisting}

\subsection{set-cdr! procedure}
\label{setcdr-procedure}
\index{set-cdr"! procedure}

\texttt{set-cdr!} sets the contents of the second cell in a pair.

Example:

\begin{verbatim}
(let ((pair (cons 'a 'b)) (val 'x))
  (set-cdr! pair val))                ==>  (a . x)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{set-cdr! (public)}} \\
pair & a pair \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg set-cdr!

proc ::constcl::set-cdr! {pair val} {
  $pair set-cdr! $val
}
\end{lstlisting}

\subsection{list? procedure}
\label{list-procedure}
\index{list? procedure}

The \texttt{list?} predicate tests if a pair is part of a proper list, one that ends with NIL. See the figure showing proper and improper lists (see page \pageref{fig:a-proper-list-and-two-improper-ones}).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg list?

proc ::constcl::list? {val} {
  set visited {}
  if {[T [null? $val]]} {
      return ${::#t}
  } elseif {[T [pair? $val]]} {
      return [listp $val]
  } else {
      return ${::#f}
  }
}
\end{lstlisting}

\textbf{listp} procedure

\texttt{listp} is a helper procedure that recursively traverses a pair trail to find out if it is cyclic or ends in an atom, which means that the procedure returns false, or if it ends in \texttt{NIL}, which means that it returns true.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{listp (internal)}} \\
pair & a pair \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{listp procedure}

\begin{lstlisting}
proc ::constcl::listp {pair} {
  upvar visited visited
  if {$pair in $visited} {
    return ${::#f}
  }
  lappend visited $pair
  if {[T [null? $pair]]} {
    return ${::#t}
  } elseif {[T [pair? $pair]]} {
    return [listp [cdr $pair]]
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{list procedure}
\label{list-procedure1}
\index{list procedure}

\texttt{list} constructs a Lisp list from a number of values.

Example:

\begin{verbatim}
(list 1 2 3)   ==>  (1 2 3)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list (public)}} \\
args & some values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg list

proc ::constcl::list {args} {
  if {[llength $args] == 0} {
    return ${::#NIL}
  } else {
    set prev ${::#NIL}
    foreach obj [lreverse $args] {
      set prev [cons $obj $prev]
    }
    return $prev
  }
}
\end{lstlisting}

\subsection{length procedure}
\label{length-procedure}
\index{length procedure}

\texttt{length} reports the length of a Lisp list.

Example:

\begin{verbatim}
(length '(a b c d))   ==>  4
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{length (public)}} \\
pair & a pair \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg length

proc ::constcl::length {pair} {
  check {list? $pair} {
    LIST expected\n([pn] lst)
  }
  MkNumber [length-helper $pair]
}
\end{lstlisting}

\textbf{length-helper} procedure

\texttt{length-helper} is a helper procedure which measures a list recursively.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{length-helper (internal)}} \\
pair & a pair \\
\textit{Returns:} & a Tcl number \\
\hline
\end{tabular}
\index{length-helper procedure}

\begin{lstlisting}
proc ::constcl::length-helper {pair} {
  if {[T [null? $pair]]} {
    return 0
  } else {
    return [expr {1 +
      [length-helper [cdr $pair]]}]
  }
}
\end{lstlisting}

\subsection{append procedure}
\label{append-procedure}
\index{append procedure}

\texttt{append} joins lists together.

Example:

\begin{verbatim}
(append '(a b) '(c d))   ==>  (a b c d)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{append (public)}} \\
args & some lists \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg append

proc ::constcl::append {args} {
  set prev [lindex $args end]
  foreach r [lreverse [lrange $args 0 end-1]] {
    check {list? $r} {
      LIST expected\n([pn] [$r tstr])
    }
    set prev [copy-list $r $prev]
  }
  set prev
}
\end{lstlisting}

\textbf{copy-list} procedure

\texttt{copy-list} joins together two lists by recursively consing items from the first list towards the second.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{copy-list (internal)}} \\
pair & a pair \\
next & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}
\index{copy-list procedure}

\begin{lstlisting}
proc ::constcl::copy-list {pair next} {
  if {[T [null? $pair]]} {
    set next
  } elseif {[T [null? [cdr $pair]]]} {
    cons [car $pair] $next
  } else {
    cons [car $pair] [copy-list [cdr $pair] $next]
  }
}
\end{lstlisting}

\subsection{reverse procedure}
\label{reverse-procedure}
\index{reverse procedure}

\texttt{reverse} produces a reversed copy of a Lisp list.

Example:

\begin{verbatim}
(reverse '(a b c))   ==>  (c b a)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{reverse (public)}} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg reverse

proc ::constcl::reverse {vals} {
  list {*}[lreverse [splitlist $vals]]
}
\end{lstlisting}

\subsection{list-tail procedure}
\label{listtail-procedure}
\index{list-tail procedure}

Given a list index, \texttt{list-tail} yields the sublist starting from that index.

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (k 3))
  (list-tail lst k))                ==>  (d e f)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list-tail (public)}} \\
vals & a Lisp list of values \\
k & a number \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg list-tail

proc ::constcl::list-tail {vals k} {
  if {[T [zero? $k]]} {
    return $vals
  } else {
    list-tail [cdr $vals] [- $k [N 1]]
  }
}
\end{lstlisting}

\subsection{list-ref procedure}
\label{listref-procedure}
\index{list-ref procedure}

\texttt{list-ref} yields the list item at a given index (0-based).

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (k 3))
  (list-ref lst k))                 ==>  d
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list-ref (public)}} \\
vals & a Lisp list of values \\
k & a number \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg list-ref

proc ::constcl::list-ref {vals k} {
  car [list-tail $vals $k]
}
\end{lstlisting}

\subsection{memq procedure}
\label{memq-procedure}
\index{memq procedure}

\noindent \textbf{memv} procedure

\noindent \textbf{member} procedure

\texttt{memq}, \texttt{memv}, and \texttt{member} return the sublist starting with a given item, or \texttt{\#f} if there is none. They use \texttt{eq?}, \texttt{eqv?}, and \texttt{equal?}, respectively, for the comparison.

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (val 'd))
  (memq val lst))                      ==>  (d e f)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{memq (public)}} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}

\begin{lstlisting}
reg memq

proc ::constcl::memq {val1 val2} {
  return [member-proc eq? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{memv (public)}} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{memv procedure}

\begin{lstlisting}
reg memv

proc ::constcl::memv {val1 val2} {
  return [member-proc eqv? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{member (public)}} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{member procedure}

\begin{lstlisting}
reg member

proc ::constcl::member {val1 val2} {
  return [member-proc equal? $val1 $val2]
}
\end{lstlisting}

\textbf{member-proc} procedure

The \texttt{member-proc} helper procedure does the work for the \texttt{memq}, \texttt{memv}, and \texttt{member} procedures. It works by comparing against the \texttt{car} of the list, then recursively taking the \texttt{cdr} of the list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{member-proc (internal)}} \\
epred & an equivalence predicate \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{member-proc procedure}

\begin{lstlisting}
proc ::constcl::member-proc {epred val1 val2} {
  switch $epred {
    eq? { set name "memq" }
    eqv? { set name "memv" }
    equal? { set name "member" }
  }
  check {list? $val2} {
    LIST expected\n($name [$val1 tstr] [$val2 tstr])
  }
  if {[T [null? $val2]]} {
    return ${::#f}
  } elseif {[T [pair? $val2]]} {
    if {[T [$epred $val1 [car $val2]]]} {
      return $val2
    } else {
      return [member-proc $epred $val1 [cdr $val2]]
    }
  }
}
\end{lstlisting}

\subsection{assq procedure}
\label{assq-procedure}
\index{assq procedure}

\noindent \textbf{assv} procedure

\noindent \textbf{assoc} procedure

\texttt{assq}, \texttt{assv}, and \texttt{assoc} scan an association list and return the association pair with a given key, or \texttt{\#f} if there is none. They use \texttt{eq?}, \texttt{eqv?}, and \texttt{equal?}, respectively, for the comparison. They implement lookup in the kind of lookup table known as an association list, or \emph{alist}.

Example:

\begin{verbatim}
(let ((e '((a . 1) (b . 2) (c . 3)))
      (key 'a))
  (assq key e))                        ==> (a . 1)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{assq (public)}} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}

\begin{lstlisting}
reg assq

proc ::constcl::assq {val1 val2} {
  return [assoc-proc eq? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{assv (public)}} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assv procedure}

\begin{lstlisting}
reg assv

proc ::constcl::assv {val1 val2} {
  return [assoc-proc eqv? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{assoc (public)}} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assoc procedure}

\begin{lstlisting}
reg assoc

proc ::constcl::assoc {val1 val2} {
  return [assoc-proc equal? $val1 $val2]
}
\end{lstlisting}

\textbf{assoc-proc} procedure

\texttt{assoc-proc} is a helper procedure which does the work for \texttt{assq}, \texttt{assv}, and \texttt{assoc}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{assoc-proc (internal)}} \\
epred & an equivalence predicate \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assoc-proc procedure}

\begin{lstlisting}
proc ::constcl::assoc-proc {epred val1 val2} {
  switch $epred {
    eq? { set name "assq" }
    eqv? { set name "assv" }
    equal? { set name "assoc" }
  }
  check {list? $val2} {
    LIST expected\n($name [$val1 tstr] [$val2 tstr])
  }
  if {[T [null? $val2]]} {
    return ${::#f}
  } elseif {[T [pair? $val2]]} {
    if {[T [pair? [car $val2]]] &&
      [T [$epred $val1 [caar $val2]]]} {
      return [car $val2]
    } else {
      return [assoc-proc $epred $val1 [cdr $val2]]
    }
  }
}
\end{lstlisting}

\section{Strings}
\label{strings}
\index{Strings}

Strings are sequences of characters. They are the most common form of real-world data in computing nowadays, having outpaced numbers some time ago. Lisp has strings, both constant and mutable, but some of the uses for strings in other languages are instead taken up by symbols.

\subsection{String class}
\label{string-class}
\index{String class}

Strings have the internal representation of a vector of character objects, with the data elements of 1) the vector address of the first element, and 2) the length of the vector. The external representation of a string is enclosed within double quotes, with double quotes and backslashes within the string escaped with a backslash.

As an extension, a \texttt{\textbackslash n} pair in the external representation is stored as a newline character. It is restored to \texttt{\textbackslash n} if the string is printed using \texttt{write}, but remains a newline character if the string is printed using \texttt{display}.

\begin{lstlisting}
oo::class create ::constcl::String {
  superclass ::constcl::Base
  variable data constant
\end{lstlisting}

The String constructor converts the given string to print form (no escaping backslashes), sets the string length, and allocates that much vector memory to store the string. The characters that make up the string are stored as Char objects. Finally the string's data tuple (a pair holding the address to the first stored character and the length of the string) is stored and \texttt{constant} is set to 0, indicating a mutable string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{String constructor (internal)}} \\
val & an external repr. of a string, w/o double quotes \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {val} {
    set val [string map {\\\\ \\ \\\" \" \\n \n} $val]
    set len [::string length $val]
    # allocate vector space for the string's
    # characters
    set vsa [::constcl::vsAlloc $len]
    # store the characters in vector space, as
    # Char objects
    set idx $vsa
    foreach elt [split $val {}] {
      if {$elt eq " "} {
        set c #\\space
      } elseif {$elt eq "\n"} {
        set c #\\newline
      } else {
        set c #\\$elt
      }
      lset ::constcl::vectorSpace $idx \
        [::constcl::MkChar $c]
      incr idx
    }
    # store the basic vector data: address of
    # first character and length
    set data [
      ::constcl::cons [N $vsa] [N $len]]
    set constant 0
  }
\end{lstlisting}

The \texttt{=} method tells if the stored string is equal to a given string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) = (internal)}} \\
str & a string \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method = {str} {
    ::string equal [my value] [$str value]
  }
\end{lstlisting}

The \texttt{cmp} method compares the stored string to a given string. Returns -1, 0, or 1, depending on whether the stored string is less than, equal to, or greater than the other string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) cmp (internal)}} \\
str & a string \\
\textit{Returns:} & a comparison value: -1, 0, or 1 \\
\hline
\end{tabular}

\begin{lstlisting}
  method cmp {str} {
    ::string compare [my value] [$str value]
  }
\end{lstlisting}

The \texttt{length} method returns the length (as a Number object) of the internal representation of the string in characters.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) length (internal)}} \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method length {} {
    ::constcl::cdr $data
  }
\end{lstlisting}

The \texttt{ref} method, given an index value which is between 0 and the length of the string, returns the character at that index position.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) ref (internal)}} \\
k & a number \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
  method ref {k} {
    set k [$k numval]
    if {$k < 0 || $k >= [[my length] numval]} {
      ::error "index out of range\n$k"
    }
    lindex [my store] $k
  }
\end{lstlisting}

The \texttt{store} method presents the range in vector memory where the string is stored.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) store (internal)}} \\
\textit{Returns:} & a Tcl list of characters \\
\hline
\end{tabular}

\begin{lstlisting}
  method store {} {
    set base [[::constcl::car $data] numval]
    set end [expr {[[my length] numval] + $base - 1}]
    lrange $::constcl::vectorSpace $base $end
  }
\end{lstlisting}

The \texttt{value} method presents the store as a Tcl string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) value (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    # present the store as printable characters
    join [lmap c [my store] {$c char}] {}
  }
\end{lstlisting}

The \texttt{set!} method does nothing to a constant string. Given an index value which is between 0 and the length of the string, it changes the character at that position to a given character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) set! (internal)}} \\
k & a number \\
c & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method set! {k c} {
    if {[my constant]} {
      ::error "string is constant"
    } else {
      set k [$k numval]
      if {$k < 0 ||
        $k >= [[my length] numval]} {
        ::error "index out of range\n$k"
      }
      set base [[::constcl::car $data] numval]
      lset ::constcl::vectorSpace $base+$k $c
    }
    return [self]
  }
\end{lstlisting}

The \texttt{fill!} method does nothing to a constant string. Given a character, it changes every character of the string to that character.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) fill! (internal)}} \\
c & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method fill! {c} {
    if {[my constant]} {
      ::error "string is constant"
    } else {
      set base [[::constcl::car $data] numval]
      set len [[my length] numval]
      for {set idx $base} \
        {$idx < $base+$len} \
        {incr idx} {
        lset ::constcl::vectorSpace $idx $c
      }
    }
    return [self]
  }
\end{lstlisting}

The \texttt{substring} method, given a \emph{from} and a \emph{to} index, returns the substring between those two indexes.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) substring (internal)}} \\
from & a number \\
to & a number \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method substring {from to} {
    set f [$from numval]
    if {$f < 0 ||
      $f >= [[my length] numval]} {
      ::error "index out of range\n$f"
    }
    set t [$to numval]
    if {$t < 0 ||
      $t > [[my length] numval]} {
      ::error "index out of range\n$t"
    }
    if {$t < $f} {
      ::error "index out of range\n$t"
    }
    join [lmap c [
      lrange [my store] $f $t-1] {$c char}] {}
  }
\end{lstlisting}

The \texttt{mkconstant} method changes the instance from mutable to immutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) mkconstant (internal)}} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method mkconstant {} {
    set constant 1
    return
  }
\end{lstlisting}

The \texttt{constant} method signals whether the string instance is mutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    return $constant
  }
\end{lstlisting}

The \texttt{external} method renders a string in external representation format.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) external (internal)}} \\
\textit{Returns:} & an external repr. of a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method external {} {
    return "\"[
      string map {\\ \\\\ \" \\\" \n \\n} [my value]]\""
  }
\end{lstlisting}

The \texttt{display} method prints a string in internal representation format.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) display (internal)}} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  method display {port} {
    $port put [my value]
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the string instance as a Tcl string. It is used by error messages and the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(String instance) tstr (internal)}} \\
\textit{Returns:} & an external repr. of a string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return [my external]
  }
}
\end{lstlisting}

\subsection{MkString generator}
\label{mkstring-generator}
\index{MkString generator}

\texttt{MkString} generates a String object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkString (internal)}} \\
str & an external repr. of a string, w/o double quotes \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkString \
  {} ::constcl::String new
\end{lstlisting}

\subsection{string? procedure}
\label{string-procedure}
\index{string? procedure}

\texttt{string?} recognizes a string by type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg string?

proc ::constcl::string? {val} {
  typeof? $val String
}
\end{lstlisting}

\subsection{make-string procedure}
\label{makestring-procedure}
\index{make-string procedure}

\texttt{make-string} creates a string of \emph{k} characters, optionally filled with \emph{char} characters. If \emph{char} is omitted, the string will be filled with space characters.

Example:

\begin{verbatim}
(let ((k 5))
  (make-string k))        ==>  "     "
(let ((k 5) (char #\A))
  (make-string k char))   ==>  "AAAAA"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-string (public)}} \\
k & a number \\
?char? & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg make-string

proc ::constcl::make-string {k args} {
  set i [$k numval]
  if {[llength $args] == 0} {
    set char " "
  } else {
    lassign $args c
    set char [$c char]
  }
  return [MkString [::string repeat $char $i]]
}
\end{lstlisting}

\subsection{string procedure}
\label{string-procedure1}
\index{string procedure}

\texttt{string} constructs a string from a number of Lisp characters.

Example:

\begin{verbatim}
(string #\f #\o #\o)   ==>  "foo"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string (public)}} \\
args & some characters \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string

proc ::constcl::string {args} {
  set str {}
  foreach char $args {
    check {::constcl::char? $char} {
      CHAR expected\n([pn] [lmap c $args \
        {$c tstr}])
    }
    ::append str [$char char]
  }
  return [MkString $str]
}
\end{lstlisting}

\subsection{string-length procedure}
\label{stringlength-procedure}
\index{string-length procedure}

\texttt{string-length} reports a string's length.

Example:

\begin{verbatim}
(string-length "foobar")   ==> 6
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-length (public)}} \\
str & a string \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-length

proc ::constcl::string-length {str} {
  check {::constcl::string? $str} {
    STRING expected\n([pn] [$str tstr])
  }
  return [$str length]
}
\end{lstlisting}

\subsection{string-ref procedure}
\label{stringref-procedure}
\index{string-ref procedure}

\texttt{string-ref} yields the \emph{k}-th character (0-based) in \emph{str}.

Example:

\begin{verbatim}
(string-ref "foobar" 3)   ==> #\b
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-ref (public)}} \\
str & a string \\
k & a number \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-ref

proc ::constcl::string-ref {str k} {
  check {::constcl::string? $str} {
    STRING expected\n([pn] [$str tstr] \
      [$k tstr])
  }
  check {::constcl::number? $k} {
    INTEGER expected\n([pn] [$str tstr] \
      [$k tstr])
  }
  return [$str ref $k]
}
\end{lstlisting}

\subsection{string-set! procedure}
\label{stringset-procedure}
\index{string-set"! procedure}

\texttt{string-set!} replaces the character at \emph{k} with \emph{char} in a non-constant string.

Example:

\begin{verbatim}
(let ((str (string #\f #\o #\o))
      (k 2)
      (char #\x))
  (string-set! str k char))         ==>  "fox"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-set! (public)}} \\
str & a string \\
k & a number \\
char & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-set!

proc ::constcl::string-set! {str k char} {
  check {string? $str} {
    STRING expected\n([pn] [$str tstr] [$k tstr] \
      [$char tstr])
  }
  check {number? $k} {
    INTEGER expected\n([pn] [$str tstr] \
      [$k tstr] [$char tstr])
  }
  check {char? $char} {
    CHAR expected\n([pn] [$str tstr] [$k tstr] \
      [$char tstr])
  }
  $str set! $k $char
  return $str
}
\end{lstlisting}

\textbf{string=?}, \textbf{string-ci=?}

\textbf{string<?}, \textbf{string-ci<?}

\textbf{string>?}, \textbf{string-ci>?}

\textbf{string<=?}, \textbf{string-ci<=?}

\textbf{string>=?}, \textbf{string-ci>=?}

The procedures \texttt{string=?}, \texttt{string<?}, \texttt{string>?}, \texttt{string<=?}, \texttt{string>=?} and their case insensitive variants \texttt{string-ci=?}, \texttt{string-ci<?}, \texttt{string-ci>?}, \texttt{string-ci<=?}, \texttt{string-ci>=?} compare strings.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string=?, string<?, string>? (public)}} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string<=?, string>=? (public)}} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-ci=?, string-ci<?, string-ci>? (public)}} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-ci<=?, string-ci>=? (public)}} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{string=? procedure}

\begin{lstlisting}
reg string=?

proc ::constcl::string=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[$str1 value] eq [$str2 value]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string-ci=? procedure}

\begin{lstlisting}
reg string-ci=?

proc ::constcl::string-ci=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[::string tolower [$str1 value]] eq
      [::string tolower [$str2 value]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string<? procedure}

\begin{lstlisting}
reg string<?

proc ::constcl::string<? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[$str1 value] < [$str2 value]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string-ci<? procedure}

\begin{lstlisting}
reg string-ci<?

proc ::constcl::string-ci<? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[::string tolower [$str1 value]] <
      [::string tolower [$str2 value]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string>? procedure}

\begin{lstlisting}
reg string>?

proc ::constcl::string>? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[$str1 value] > [$str2 value]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string-ci>? procedure}

\begin{lstlisting}
reg string-ci>?

proc ::constcl::string-ci>? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[::string tolower [$str1 value]] >
      [::string tolower [$str2 value]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string<=? procedure}

\begin{lstlisting}
reg string<=?

proc ::constcl::string<=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[$str1 value] <= [$str2 value]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string-ci<=? procedure}

\begin{lstlisting}
reg string-ci<=?

proc ::constcl::string-ci<=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[::string tolower [$str1 value]] <=
      [::string tolower [$str2 value]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string>=? procedure}

\begin{lstlisting}
reg string>=?

proc ::constcl::string>=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[$str1 value] >= [$str2 value]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}
\index{string-ci>=? procedure}

\begin{lstlisting}
reg string-ci>=?

proc ::constcl::string-ci>=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 tstr] \
      [$str2 tstr])
  }
  if {[::string tolower [$str1 value]] >=
      [::string tolower [$str2 value]]} {
    return ${::#t}
  } else {
    return ${::#f}
  }
}
\end{lstlisting}

\subsection{substring procedure}
\label{substring-procedure}
\index{substring procedure}

\texttt{substring} yields the substring of \emph{str} that starts at \emph{start} and ends before \emph{end}.

Example:

\begin{verbatim}
(substring "foobar" 2 5)   ==> "oba"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{substring (public)}} \\
str & a string \\
start & a number \\
end & a number \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg substring

proc ::constcl::substring {str start end} {
  check {string? $str} {
    STRING expected\n([pn] [$str tstr] \
      [$start tstr] [$end tstr])
  }
  check {number? $start} {
    NUMBER expected\n([pn] [$str tstr] \
      [$start tstr] [$end tstr])
  }
  check {number? $end} {
    NUMBER expected\n([pn] [$str tstr] \
      [$start tstr] [$end tstr])
  }
  return [MkString [$str substring $start $end]]
}
\end{lstlisting}

\subsection{string-append procedure}
\label{stringappend-procedure}
\index{string-append procedure}

\texttt{string-append} joins strings together.

Example:

\begin{verbatim}
(string-append "foo" "bar")   ==>  "foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-append (public)}} \\
args & some strings \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-append

proc ::constcl::string-append {args} {
    MkString [::append --> {*}[lmap arg $args {
      $arg value
    }]]
}
\end{lstlisting}

\subsection{string->list procedure}
\label{stringlist-procedure}
\index{string->list procedure}

\texttt{string->list} converts a string to a Lisp list of characters.

Example:

\begin{verbatim}
(string->list "foo")   ==>  (#\f #\o #\o)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string->list (public)}} \\
str & a string \\
\textit{Returns:} & a Lisp list of characters \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->list

proc ::constcl::string->list {str} {
  list {*}[$str store]
}
\end{lstlisting}

\subsection{list->string procedure}
\label{liststring-procedure}
\index{list->string procedure}

\texttt{list->string} converts a Lisp list of characters to a string.

Example:

\begin{verbatim}
(list->string '(#\1 #\2 #\3))   ==> "123"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list->string (public)}} \\
list & a Lisp list of characters \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg list->string

proc ::constcl::list->string {list} {
  MkString [::append --> {*}[
    lmap c [splitlist $list] {$c char}]]
}
\end{lstlisting}

\subsection{string-copy procedure}
\label{stringcopy-procedure}
\index{string-copy procedure}

\texttt{string-copy} makes a copy of a string.

Example:

\begin{verbatim}
(let ((str (string-copy "abc"))
      (k 0)
      (char #\x))
  (string-set! str k char))       ==>  "xbc"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-copy (public)}} \\
str & a string \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-copy

proc ::constcl::string-copy {str} {
  check {string? $str} {
    STRING expected\n([pn] [$str tstr])
  }
  return [MkString [$str value]]
}
\end{lstlisting}

\subsection{string-fill! procedure}
\label{stringfill-procedure}
\index{string-fill"! procedure}

\texttt{string-fill!} \emph{str} \emph{char} fills a non-constant string with \emph{char}.

Example:

\begin{verbatim}
(let ((str (string-copy "foobar"))
      (char #\X))
  (string-fill! str char))           ==>  "XXXXXX"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string-fill! (public)}} \\
str & a string \\
char & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-fill!

proc ::constcl::string-fill! {str char} {
  check {string? $str} {
    STRING expected\n([pn] [$str tstr] \
      [$char tstr])
  }
  $str fill! $char
  return $str
}
\end{lstlisting}

\section{Symbols}
\label{symbols}
\index{Symbols}

Symbols are like little immutable strings that are used to refer to things (variables, category labels, collection keys, etc) or for equality comparison against each other.

\subsection{Symbol class}
\label{symbol-class}
\index{Symbol class}

The Symbol class defines what capabilities a symbol has (in addition to those from the Base class), and also defines the internal representation of a symbol value expression. A symbol is stored in an instance as a Tcl string, and the \texttt{name} method yields the symbol's name as result.

\begin{lstlisting}
oo::class create ::constcl::Symbol {
  superclass ::constcl::Base
  variable name caseconstant
\end{lstlisting}

The Symbol constructor checks that the given name is a valid identifier and then stores it. It also sets \texttt{caseconstant} to 0, indicating that the name doesn't keep its case when turned into a string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Symbol constructor (internal)}} \\
n & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {n} {
    ::constcl::idcheck $n
    set name $n
    set caseconstant 0
  }
\end{lstlisting}

The \texttt{name} method returns the symbol's name.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) name (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method name {} {
    set name
  }
\end{lstlisting}

The \texttt{value} method is a synonym for \texttt{name}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) value (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    set name
  }
\end{lstlisting}

The \texttt{=} method compares the stored name with the name of a given symbol. It returns \texttt{\#t} if they are equal, otherwise \texttt{\#f}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) = (internal)}} \\
sym & a symbol \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
  method = {symname} {
    if {$name eq [$sym name]} {
      return ${::#t}
    } else {
      return ${::#f}
    }
  }
\end{lstlisting}

The \texttt{constant} method signals whether the symbol instance is immutable (it is).

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    return 1
  }
\end{lstlisting}

The \texttt{case-constant} method signals whether the symbol instance is \emph{case constant}, i.e. keeps its case when turned into a string.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) case-constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method case-constant {} {
    set caseconstant
  }
\end{lstlisting}

The \texttt{make-case-constant} method makes the symbol \emph{case constant}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) make-case-constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1) \\
\hline
\end{tabular}

\begin{lstlisting}
  method make-case-constant {} {
    set caseconstant 1
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the symbol instance (the name) as a Tcl string. It is used by error messages.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Symbol instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return $name
  }
}
\end{lstlisting}

\subsection{MkSymbol generator}
\label{mksymbol-generator}
\index{MkSymbol generator}

\texttt{MkSymbol} generates a symbol with a given name. If a symbol with that name already exists, it is returned. Otherwise, a fresh symbol is created. Short form: \texttt{S}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkSymbol (internal)}} \\
str & a Tcl string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkSymbol {str} {
  if {[dict exists $::constcl::symbolTable $str]} {
    return [dict get $::constcl::symbolTable $str]
  } else {
    set sym [::constcl::Symbol new $str]
    dict set ::constcl::symbolTable $str $sym
    return $sym
  }
}
interp alias {} S {} ::constcl::MkSymbol
\end{lstlisting}

\subsection{symbol? procedure}
\label{symbol-procedure}
\index{symbol? procedure}

\texttt{symbol?} recognizes a symbol by type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{symbol? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg symbol?

proc ::constcl::symbol? {val} {
  typeof? $val Symbol
}
\end{lstlisting}

\subsection{symbol->string procedure}
\label{symbolstring-procedure}
\index{symbol->string procedure}

\texttt{symbol->string} yields a string consisting of the symbol name, usually lower-cased.

Example:

\begin{verbatim}
(let ((sym 'Foobar))
  (symbol->string sym))   ==>  "foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{symbol->string (public)}} \\
sym & a symbol \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg symbol->string

proc ::constcl::symbol->string {sym} {
  check {symbol? $sym} {
    SYMBOL expected\n([pn] [$sym tstr])
  }
  if {![$sym case-constant]} {
    set str [MkString [
      ::string tolower [$sym name]]]
  } else {
    set str [MkString [$sym name]]
  }
  $str mkconstant
  return $str
}
\end{lstlisting}

\subsection{string->symbol procedure}
\label{stringsymbol-procedure}
\index{string->symbol procedure}

\texttt{string->symbol} creates a symbol with the name given by the string. The symbol is 'case-constant', i.e. it will not be lower-cased.

Example:

\begin{verbatim}
(define sym (let ((str "Foobar"))
              (string->symbol str)))
sym                                    ==>  Foobar
(symbol->string sym)                   ==>  "Foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{string->symbol (public)}} \\
str & a string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->symbol

proc ::constcl::string->symbol {str} {
  check {string? $str} {
    STRING expected\n([pn] [$obj tstr])
  }
  set sym [MkSymbol [$str value]]
  $sym make-case-constant
  return $sym
}
\end{lstlisting}

\section{Vectors}
\label{vectors}
\index{Vectors}

Vectors are heterogenous structures of fixed length whose elements are indexed by integers. The number of elements that a vector contains (the \emph{length}) is set when the vector is created. Elements can be indexed by integers from zero to length minus one.

\subsection{Vector class}
\label{vector-class}
\index{Vector class}

The Vector class defines what capabilities a vector has (in addition to those from the Base class), and also defines the internal representation of a vector value expression. A vector is stored in an instance as a tuple of vector memory address and vector length. The \texttt{value} method yields the contents of the vector as result.

\begin{lstlisting}
oo::class create ::constcl::Vector {
  superclass ::constcl::Base
  variable data constant
\end{lstlisting}

The Vector constructor is divided in two main parts, one for the case where the value is a Lisp list, and one for the case where the value is a Tcl list. Their structure is similar: set the length (number of items), allocate vector space, and store the elements.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{Vector constructor (internal)}} \\
val & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
  constructor {val} {
    if {[T [::constcl::list? $val]]} {
      # if val is provided in the form of a Lisp list
      set len [[::constcl::length $val] numval]
      # allocate vector space for the elements
      set vsa [::constcl::vsAlloc $len]
      # store the elements in vector space
      set idx $vsa
      while {![T [::constcl::null? $val]]} {
        set elt [::constcl::car $val]
        lset ::constcl::vectorSpace $idx $elt
        incr idx
        set val [::constcl::cdr $val]
      }
    } else {
      # if val is provided in the form of a Tcl list
      set len [llength $val]
      # allocate vector space for the elements
      set vsa [::constcl::vsAlloc $len]
      # store the elements in vector space
      set idx $vsa
      foreach elt $val {
        lset ::constcl::vectorSpace $idx $elt
        incr idx
      }
    }
    # store the basic vector data: address of
    # first element and length
    set data [::constcl::cons [N $vsa] [N $len]]
    set constant 0
  }
\end{lstlisting}

The \texttt{baseadr} method returns the address of the first element as a number object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) baseadr (internal)}} \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method baseadr {} {
    ::constcl::car $data
  }
\end{lstlisting}

The \texttt{length} method returns the length (number of elements) as a number object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) length (internal)}} \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
  method length {} {
    ::constcl::cdr $data
  }
\end{lstlisting}

The \texttt{ref} method returns one element given the (0-based) index for it.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) ref (internal)}} \\
k & a number \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
  method ref {k} {
    set k [$k numval]
    if {$k < 0 || $k >= [[my length] numval]} {
      ::error "index out of range\n$k"
    }
    lindex [my store] $k
  }
\end{lstlisting}

The \texttt{store} method returns the range of vector memory cells that store the vector's elements.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) store (internal)}} \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}

\begin{lstlisting}
  method store {} {
    set base [[my baseadr] numval]
    set end [expr {[[my length] numval] + $base - 1}]
    lrange $::constcl::vectorSpace $base $end
  }
\end{lstlisting}

The \texttt{value} method is a synonym for \texttt{store}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) value (internal)}} \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}

\begin{lstlisting}
  method value {} {
    my store
  }
\end{lstlisting}

The \texttt{set!} method changes one element in a mutable vector given a (0-based) index value and a value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) set! (internal)}} \\
k & a number \\
val & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
  method set! {k val} {
    if {[my constant]} {
      ::error "vector is constant"
    } else {
      set k [$k numval]
      if {$k < 0 || $k >= [[my length] numval]} {
        ::error "index out of range\n$k"
      }
      set base [[my baseadr] numval]
      lset ::constcl::vectorSpace $k+$base $val
    }
    return [self]
  }
\end{lstlisting}

The \texttt{fill!} method changes every element in a mutable vector to a given value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) fill! (internal)}} \\
val & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
  method fill! {val} {
    if {[my constant]} {
      ::error "vector is constant"
    } else {
      set base [[my baseadr] numval]
      set len [[my length] numval]
      for {set idx $base} \
        {$idx < $len+$base} \
        {incr idx} {
        lset ::constcl::vectorSpace $idx $val
      }
    }
    return [self]
  }
\end{lstlisting}

The \texttt{mkconstant} method makes a vector immutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) mkconstant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1) \\
\hline
\end{tabular}

\begin{lstlisting}
  method mkconstant {} {
    set constant 1
  }
\end{lstlisting}

The \texttt{constant} method signals whether the vector instance is immutable.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) constant (internal)}} \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
  method constant {} {
    set constant
  }
\end{lstlisting}

The \texttt{tstr} method yields the external representation of the symbol instance (the name) as a Tcl string. It is used by error messages and for the \texttt{write} method.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{(Vector instance) tstr (internal)}} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
  method tstr {} {
    return [format "#(%s)" [
      join [lmap val [my value] {$val tstr}]]]
  }
}
\end{lstlisting}

\subsection{MkVector generator}
\label{mkvector-generator}
\index{MkVector generator}

\texttt{MkVector} generates a Vector object.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{MkVector (internal)}} \\
vals & a Lisp or Tcl list of values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkVector \
  {} ::constcl::Vector new
\end{lstlisting}

\subsection{vector? procedure}
\label{vector-procedure}
\index{vector? procedure}

\texttt{vector?} recognizes vectors by type.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector? (public)}} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector?

proc ::constcl::vector? {val} {
  typeof? $val Vector
}
\end{lstlisting}

\subsection{make-vector procedure}
\label{makevector-procedure}
\index{make-vector procedure}

\texttt{make-vector} creates a vector with a given length and optionally a fill value. If a fill value isn't given, the empty list will be used.

Example:

\begin{verbatim}
(let ((k 3))
  (make-vector k))        ==>  #(() () ())
(let ((k 3) (val #\A))
  (make-vector k val))    ==>  #(#\A #\A #\A)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{make-vector? (public)}} \\
k & a number \\
?val? & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg make-vector

proc ::constcl::make-vector {k args} {
  if {[llength $args] == 0} {
    set val ${::#NIL}
  } else {
    lassign $args val
  }
  MkVector [lrepeat [$k numval] $val]
}
\end{lstlisting}

\subsection{vector procedure}
\label{vector-procedure1}
\index{vector procedure}

Given a number of Lisp values, \texttt{vector} creates a vector containing them.

Example:

\begin{verbatim}
(vector 'a "foo" 99)   ==>  #(a "foo" 99)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector (public)}} \\
args & some values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector

proc ::constcl::vector {args} {
  MkVector $args
}
\end{lstlisting}

\subsection{vector-length procedure}
\label{vectorlength-procedure}
\index{vector-length procedure}

\texttt{vector-length} returns the length of a vector.

Example:

\begin{verbatim}
(vector-length '#(a "foo" 99))   ==>  3
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector-length (public)}} \\
vec & a vector \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-length

proc ::constcl::vector-length {vec} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec tstr])
  }
  return [$vec length]
}
\end{lstlisting}

\subsection{vector-ref procedure}
\label{vectorref-procedure}
\index{vector-ref procedure}

\texttt{vector-ref} returns the element of \emph{vec} at index \emph{k} (0-based).

Example:

\begin{verbatim}
(let ((vec '#(a "foo" 99)) (k 1))
  (vector-ref vec k))              ==>  "foo"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector-ref (public)}} \\
vec & a vector \\
k & a number \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-ref

proc ::constcl::vector-ref {vec k} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec tstr] [$k tstr])
  }
  check {number? $k} {
    NUMBER expected\n([pn] [$vec tstr] [$k tstr])
  }
  return [$vec ref $k]
}
\end{lstlisting}

\subsection{vector-set! procedure}
\label{vectorset-procedure}
\index{vector-set"! procedure}

\texttt{vector-set!} sets the element at index \emph{k} to \emph{val} on a vector that isn't constant.

Example:

\begin{verbatim}
(let ((vec '#(a b c))
      (k 1)
      (val 'x))
  (vector-set! vec k val))      ==>  *error*
(let ((vec (vector 'a 'b 'c))
      (k 1)
      (val 'x))
  (vector-set! vec k val))      ==>  #(a x c)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector-set! (public)}} \\
vec & a vector \\
k & a number \\
val & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-set!

proc ::constcl::vector-set! {vec k val} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec tstr] [$k tstr])
  }
  check {number? $k} {
    NUMBER expected\n([pn] [$vec tstr] [$k tstr])
  }
  return [$vec set! $k $val]
}
\end{lstlisting}

\subsection{vector->list procedure}
\label{vectorlist-procedure}
\index{vector->list procedure}

\texttt{vector->list} converts a vector value to a Lisp list.

Example:

\begin{verbatim}
(vector->list '#(a b c))   ==>  (a b c)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector->list (public)}} \\
vec & a vector \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector->list

proc ::constcl::vector->list {vec} {
  list {*}[$vec value]
}
\end{lstlisting}

\subsection{list->vector procedure}
\label{listvector-procedure}
\index{list->vector procedure}

\texttt{list->vector} converts a Lisp list value to a vector.

Example:

\begin{verbatim}
(list->vector '(1 2 3))   ==>  #(1 2 3)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list->vector (public)}} \\
list & a Lisp list of values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg list->vector

proc ::constcl::list->vector {list} {
  vector {*}[splitlist $list]
}
\end{lstlisting}

\subsection{vector-fill! procedure}
\label{vectorfill-procedure}
\index{vector-fill"! procedure}

\texttt{vector-fill!} fills a non-constant vector with a given value.

Example:

\begin{verbatim}
(define vec (vector 'a 'b 'c))
(vector-fill! vec 'x)             ==>  #(x x x)
vec                               ==>  #(x x x)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vector-fill! (public)}} \\
vec & a vector \\
fill & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-fill!

proc ::constcl::vector-fill! {vec fill} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec tstr] \
      [$fill tstr])
  }
  $vec fill! $fill
}
\end{lstlisting}

\chapter{Initialization}
\label{initialization}

Before the interpreter can run, some elements must be initialized.

\subsubsection{Vector space}
\label{vector-space}
\index{vector space}

Initialize the memory space for vector contents.

\begin{lstlisting}
set ::constcl::vectorSpaceSize [expr {1 * 1024}]
set ::constcl::vectorSpace [
  lrepeat $::constcl::vectorSpaceSize [N 0]]

set ::constcl::vectorAssign 0
\end{lstlisting}

The \texttt{vsAlloc} procedure allocates vector space for strings and vectors. First it checks that there is enough space left, and then it increases the fill marker and returns its old value.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{vsAlloc (internal)}} \\
num & a number \\
\textit{Returns:} & a Tcl number \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::vsAlloc {num} {
  if {$::constcl::vectorSpaceSize -
    $::constcl::vectorAssign < $num} {
    error "not enough vector space left"
  }
  set va $::constcl::vectorAssign
  incr ::constcl::vectorAssign $num
  return $va
}
\end{lstlisting}

\subsubsection{Symbol table}
\label{symbol-table}
\index{symbol table}

Initialize the symbol table and gensym number.

\begin{lstlisting}
unset -nocomplain ::constcl::symbolTable
set ::constcl::symbolTable [dict create]

set ::constcl::gensymnum 0
\end{lstlisting}

\subsubsection{Recursion limit}
\label{recursion-limit}
\index{recursion limit}

Make it possible to reach (fact 100). Probably more than needed, but this amount can't hurt (default is 1000).

\begin{lstlisting}
interp recursionlimit {} 2000
\end{lstlisting}

\subsubsection{A set of source code constants}
\label{a-set-of-source-code-constants}
\index{a set of source code constants}

Pre-make a set of constants (e.g. \texttt{\#NIL}, \texttt{\#t}, and \texttt{\#f}) and give them aliases for use in source text.

\begin{lstlisting}
set #NIL [::constcl::NIL new]

set #t [::constcl::True new]

set #f [::constcl::False new]

set #UNS [::constcl::Unspecified new]

set #UND [::constcl::Undefined new]

set #EOF [::constcl::EndOfFile new]
\end{lstlisting}

\subsubsection{Pi and nil}
\label{pi-and-nil}
\index{pi and nil}

Crown the definition register with the queen of numbers (or at least a double-precision floating point approximation).
\index{pi constant}

\begin{lstlisting}
regvar pi [N 3.1415926535897931]
\end{lstlisting}

In this interpreter, \texttt{nil} does refer to the empty list.
\index{nil constant}

\begin{lstlisting}
regvar nil ${::#NIL}
\end{lstlisting}

\subsubsection{Environment startup}
\label{environment-startup}
\index{environment startup}

On startup, two \texttt{Environment} objects called \texttt{null\_env} (the null environment, not the same as \texttt{null-environment} in Scheme) and \texttt{global\_env} (the global environment) are created.

Make \texttt{null\_env} empty and judgemental: this is where searches for unbound symbols end up.
\index{null\_env environment}

\begin{lstlisting}
::constcl::Environment create \
  ::constcl::null_env ${::#NIL} {}

oo::objdefine ::constcl::null_env {
  method find {sym} {
    self
  }
  method get {sym} {
    ::error "Unbound variable: [$sym name]"
  }
  method set {sym t_ i_} {
    ::error "Unbound variable: [$sym name]"
  }
}
\end{lstlisting}

Meanwhile, \texttt{global\_env} is populated with all the definitions from the definitions register, \texttt{defreg}. This is where top level evaluation happens.
\index{global\_env environment}

\begin{lstlisting}
namespace eval ::constcl {
  Environment create global_env ${::#NIL} {} \
    ::constcl::null_env
  foreach v [dict values $defreg] {
    lassign $v key val
    lassign $val bt in
    global_env bind [S $key] $bt $in
  }
}
\end{lstlisting}

Thereafter, each time a user-defined procedure is called, a new \texttt{Environment} object is created to hold the bindings introduced by the call, and also a link to the outer environment (the one closed over when the procedure was defined).

\subsubsection{The Scheme base}
\label{the-scheme-base}
\index{the scheme base}

Load the Scheme base to add more definitions to the global environment.
\index{Scheme base}

\begin{lstlisting}
pe {(load "schemebase.scm")}
\end{lstlisting}

\chapter{A Scheme base}
\label{a-scheme-base}

\begin{lstlisting}
; An assortment of procedures to supplement the builtins.
\end{lstlisting}

\subsection{get procedure}
\label{get-procedure}
\index{get procedure}

\texttt{get} is a procedure for picking out values out of property lists. It returns either the value or \texttt{\#f} if the key isn't found.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{get (public)}} \\
plist & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a value OR \#f \\
\hline
\end{tabular}

\begin{lstlisting}
(define (get plist key)
  (let ((v (memq key plist)))
    (if v
      (cadr v)
      #f)))
\end{lstlisting}

\subsection{list-find-key procedure}
\label{listfindkey-procedure}
\index{list-find-key procedure}

\texttt{list-find-key} searches for a key in a property list. If it finds it, it returns the (0-based) index of it. If it doesn't find it, it returns -1. It doesn't look at the values.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list-find-key (public)}} \\
lst & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-find-key lst key)
  (lfk lst key 0))
\end{lstlisting}

\subsection{lfk procedure}
\label{lfk-procedure}
\index{lfk procedure}

\texttt{lfk} does the work for \texttt{list-find-key}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{lfk (public)}} \\
lst & a Lisp list of values \\
key & a symbol \\
count & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (lfk lst key count)
  (if (null? lst)
    -1
    (if (eq? (car lst) key)
      count
      (lfk (cddr lst) key (+ count 2)))))
\end{lstlisting}

\subsection{list-set! procedure}
\label{listset-procedure}
\index{list-set"! procedure}

\texttt{list-set!} works in analogy with \texttt{string-set!}. Given a list and an index, it finds the place to insert a value. Is in real trouble if the index value is out of range.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list-set! (public)}} \\
lst & a Lisp list of values \\
idx & a number \\
val & a value \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-set! lst idx val)
  (if (zero? idx)
    (set-car! lst val)
    (list-set! (cdr lst) (- idx 1) val)))
\end{lstlisting}

\subsection{delete! procedure}
\label{delete-procedure}
\index{delete"! procedure}

\texttt{delete!} removes a key-value pair from a property list. Returns the list.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{delete! (public)}} \\
lst & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (delete! lst key)
  (let ((idx (list-find-key lst key)))
    (if (< idx 0)
      lst
      (if (= idx 0)
        (set! lst (cddr lst))
        (let ((bef (del-seek lst (- idx 1)))
              (aft (del-seek lst (+ idx 2))))
          (set-cdr! bef aft))))
    lst))
\end{lstlisting}

\subsection{del-seek procedure}
\label{delseek-procedure}
\index{del-seek procedure}

\texttt{del-seek} does the searching for \texttt{delete!}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{del-seek (public)}} \\
lst & a Lisp list of values \\
idx & a number \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (del-seek lst idx)
  (if (zero? idx)
    lst
    (del-seek (cdr lst) (- idx 1))))
\end{lstlisting}

\subsection{get-alist procedure}
\label{getalist-procedure}
\index{get-alist procedure}

\texttt{get-alist} is like \texttt{get} but for association lists.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{get-alist (public)}} \\
lst & a Lisp list of association pairs \\
key & a symbol \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
(define (get-alist lst key)
  (let ((item (assq key lst)))
    (if item
      (cdr item)
      #f)))
\end{lstlisting}

\subsection{pairlis procedure}
\label{pairlis-procedure}
\index{pairlis procedure}

\texttt{pairlis} takes two lists like \texttt{'(a b c)} and \texttt{'(1 2 3)} and produces a list of association pairs \texttt{'((a . 1) (b . 2) (c . 3))}.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{pairlis (public)}} \\
a & a Lisp list of values \\
b & a Lisp list of values \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
(define (pairlis a b)
  (if (null? a)
    '()
    (cons
      (cons (car a) (car b))
      (pairlis (cdr a) (cdr b)))))
\end{lstlisting}

\subsection{set-alist! procedure}
\label{setalist-procedure}
\index{set-alist"! procedure}

\texttt{set-alist!} updates a value in an association list, given a key.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{set-alist! (public)}} \\
lst & a Lisp list of association pairs \\
key & a symbol \\
val & a value \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
(define (set-alist! lst key val)
  (let ((item (assq key lst)))
    (if item
      (begin (set-cdr! item val) lst)
      lst)))
\end{lstlisting}

\subsection{fact procedure}
\label{fact-procedure}
\index{fact procedure}

\texttt{fact} calculates the factorial of \emph{n}. The function is obvious from the definition of factorial, but I've copied the code from Lispy.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{fact (public)}} \\
n & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (fact n)
  (if (<= n 1)
    1
    (* n (fact (- n 1)))))
\end{lstlisting}

\subsection{list-copy procedure}
\label{listcopy-procedure}
\index{list-copy procedure}

Returns a newly allocated copy of \emph{list}. This copies each of the pairs comprising \emph{list}. From MIT Scheme.

\noindent\begin{tabular}{ |p{1.9cm} p{6.5cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\textbf{list-copy (public)}} \\
list & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-copy list)
  (if (null? list)
    '()
    (cons (car list)
      (list-copy (cdr list)))))
\end{lstlisting}



\bigskip\bigskip\noindent And that's all. Thank you for joining me on this voyage of exploration.

\backmatter
\printindex
\newpage 
\pagestyle{empty}

\ % The empty page

\newpage
\end{document}

