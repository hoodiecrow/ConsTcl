\documentclass[twoside]{report}
\usepackage[a5paper]{geometry}
\usepackage{newpxmath}
%\usepackage{libertine} \usepackage[libertine]{newtxmath}
%\usepackage{kpfonts}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{imakeidx}
\usepackage{marginnote}
\usepackage[table]{xcolor}
\usepackage{caption}
\usepackage{etoc}
\usepackage{float}
  \floatstyle{boxed}
  \newfloat{pulledtext}{tbp}{pulledtext}
\lstset{
  showstringspaces=false,
  language=tcl,
  frame=lines,
  aboveskip=\bigskipamount,
  belowskip=\bigskipamount,
  numbers=left,
  numberstyle=\tiny,
  firstnumber=last,
  basicstyle=\small\ttfamily,
}
%\renewcommand{\thesection}{\arabic{section}}
\title{Into the Interpreter\\with ConsTcl}
\author{Peter Lewerin}
\date{\today}
\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
    {\parindent \z@ \raggedright \normalfont
      \ifnum \c@secnumdepth >\m@ne
        %\if@mainmatter
          %\huge\bfseries \@chapapp\space \thechapter
          \Huge\bfseries \thechapter.\space%
          %\par\nobreak
          %\vskip 20\p@
        %\fi
      \fi
      \interlinepenalty\@M
      \Huge \bfseries #1\par\nobreak
      \vskip 40\p@
   }}
\makeatother
\makeindex[intoc]
\counterwithout{footnote}{chapter}
\setcounter{secnumdepth}{1}

\begin{document}
\pagestyle{headings}
\maketitle

\renewcommand*{\contentsname}{Short contents}
\etocsettocdepth.toc{section}
\tableofcontents

\renewcommand*\contentsname{Detailed contents}
\etocignoretoctocdepth
\tableofcontents


\chapter{Introduction}
\label{introduction}
\section{To run the software}
\label{to-run-the-software}


First things first. To run, source the file \textbf{constcl.tcl} (with
\textbf{schemebase.scm} in the directory) in a Tcl console (I use
\textbf{tkcon}) and use the command \textbf{repl} for a primitive command
dialog. Source \textbf{all.tcl} to run the test suite (you need
\textbf{constcl.test} for that). The files can be found on GitHub/ConsTcl\footnote{See
\texttt{https://github.com/hoodiecrow/ConsTcl}}.

\section{Background}
\label{background}

It all started with Peter Norvig's Lisp emulator
Lispy\footnote{See \texttt{https://norvig.com/lispy.html}}. In January 2025 I
was inspired to port it to Tcl. The result was Thtcl\footnote{See
\texttt{https://github.com/hoodiecrow/thtcl}}. It had the same features and
limitations as Lispy, plus a couple of limitations that were due to
shortcomings of Tcl, and I came out of the experience feeling a bit
dissatisfied. In the latter part of January I embarked on a new project,
ConsTcl, a true Lisp interpreter. In Tcl.

\subsection{About Lisp}
\label{about-lisp}

ConsTcl is a \emph{Lisp interpreter}, specifically a \emph{Scheme interpreter}.
Lisp is a family of programming languages that share the same basic form, and
Scheme is one of those languages. Where some other languages use braces to
structure code, and Python uses indents, Lisp instead uses parentheses. This
Python snippet:

\begin{verbatim}
x = 1
if x == 1:
    print("x is 1.")
\end{verbatim}

\noindent looks like this in Scheme:

\begin{verbatim}
(let ((x 1))
  (if (= x 1)
    (write "x is 1.")))
\end{verbatim}

In Lisp, everything is either an \emph{atom}, an indivisible value, like
\texttt{x} and \texttt{1} (and e.g. \texttt{let} and \texttt{write} too) or
else it is a \emph{list expression}, starting and ending with parentheses and
having an operator at the front of the list, with the rest of the parts being
operands. If the operator is a keyword like \texttt{let} or \texttt{if}, then
the expression is a \emph{special form}. If not, like \texttt{+} or
\texttt{write}, then it's a \emph{function call}.  A full description of Lisp
is beyond the scope of this introduction, but Lisp will be explained from the
inside out in the rest of this book. If you want to learn Scheme right away,
there are good tutorials in different\footnote{See
\texttt{https://docs.scheme.org/schintro/}} places\footnote{See
\texttt{https://www.scheme.com/tspl4/}} on the web\footnote{See
\texttt{https://files.spritely.institute/papers/scheme-primer.html}}.

\subsection{About ConsTcl}
\label{about-constcl}

Compared to Lispy/Thtcl, ConsTcl has, (quote from Lispy), ``comments, quote and
quasiquote notation, \# literals, the derived expression types (such as cond,
derived from if, or let, derived from lambda), and dotted list notation.''
Again compared to Lispy/Thtcl, ConsTcl has the data types, quote, ``strings,
characters, booleans, ports, vectors.'' And pairs and procedures too. The
number of missing primitive procedures is in the tens, not the 100s. 

The completeness comes with a price: due to the sheer number of calls for each
action, ConsTcl is is fairly slow. On my cheap computer, the following code
(which calculates the factorial of 100) takes 0.04 seconds to run. That is thirteen
times slower than Lispy assuming that Norvig's computer is as slow as mine,
which is unlikely.

\begin{verbatim}
time {pe "(fact 100)"} 10
\end{verbatim}

ConsTcl is of course still limited. It doesn't come close to having call/cc or
tail recursion. It doesn't have exact/inexact numbers, or most of the numerical
tower. There is no memory management. Error reporting is spotty, and there is no
error recovery.

\subsection{About the book}
\label{about-the-book}


I like writing documentation, and occasionally I'm good at it. I like to
annotate the source code with bits of documentation, which I then extract and
put together using tools like \texttt{awk}. It looks like this:

\includegraphics{images/document.png}

In the middle are a bunch of \texttt{.ans} files (ANnotated Source). These are
written with Vim. From the TT tags of those, I extract a \texttt{.test} file.
From the CB tags I extract \texttt{.tcl} source (or Scheme or C source, as the
case might be). From all the tags except TT I extract formatted documentation
in Markdown and \LaTeX{} format. All these extractions are automated using
\texttt{make}.  Figures are made with Inkscape.  I create a PDF document from
the \LaTeX{} source using TeXworks. On finishing up ConsTcl, it struck me that
the documentation for this piece of software was fit for a book.

ConsTcl is at least 97\% my own work, but I have ported one part (see page
\pageref{resolving-local-defines}) from ``Scheme 9 from Empty
Space''\footnote{See \texttt{https://t3x.org/s9book/index.html}} by Nils M
Holm\index{Holm, Nils M}, a Lisp interpreter written in C and commented in a
similar manner to this book. Another source of guidance and inspiration was
``Lisp in Small Pieces'' by Christian Queinnec. Yet another source was ``An
Introduction to Scheme and its Implementation''\footnote{See
\texttt{https://docs.scheme.org/schintro/}}

\subsection{About the program listings}
\label{about-the-program-listings}

I have tried to write clear, readable code, but the page format forces me to
shorten lines. I have used two-space indents instead of four-space, a smaller
font, and broken off long lines with a \textbackslash\  at the end of the first
line (a so-called `tucked-in tail'). Neither of these measures improve
readability, but the alternative is overwriting the margins. Not all broken
lines have the \textbackslash: some are broken inside a
\texttt{\{}\ldots\texttt{\}} block, and some right after a \texttt{^^5b}.

\subsection{About me}
\label{about-me}

I'm a 60 year old former system manager who has been active in programming
since 1979. Currently, since around 25 years, my language of choice is the
rather marginal Tcl\footnote{See \texttt{https://www.tcl-lang.org/}} (it's not
even in the 100 most used languages). Tcl suits me, and there are things that
one can do in Tcl that one can't easily do in other languages. Lisp is a
runner-up in my affections, a language that fascinates me but doesn't fit my
brain very well (though I have written one large piece of software in AutoLisp,
a CAD subsystem for designing drilling boxes).

In addition to my terms as programmer and system manager, I have worked as a
teacher (teaching C/C++ in upper secondary school) and for a short while I
wrote textbooks for the department for information technology at
the University of SkÃ¶vde. I've also been active writing answers at
question-and-answer sites on the web, mainly Stack Overflow.

\subsection{About time}
\label{about-time}

I'd like to thank

\begin{itemize}
\item my children and their lifemates for being awesome.

\item my ex-wife for supporting the printing of the book financially.

\item my mother, sister and brother-in-law for being supportive.
\end{itemize}

And now let's journey into the Interpreter.

\chapter{Initial declarations}
\label{initial-declarations}

In this chapter, mostly things I need to start working on the interpreter. Feel free to skim this chapter, maybe coming back later to check up on things here.

First, I need to create the namespace that will be used for most identifiers:

\begin{lstlisting}
namespace eval ::constcl {}
\end{lstlisting}

\section{Utility commands}
\label{utility-commands}
\index{utility commands}

Next, some procedures that make my life as developer somewhat easier.

\subsection{reg procedure}
\label{reg-procedure}
\index{reg procedure}

\texttt{reg} registers built-in procedures, special forms, and macros in the definitions register\index{definitions register}. That way I don't need to manually keep track of and list procedures. The definitions register's contents will eventually get dumped into the standard library (see page \pageref{environment-startup}).

You can call \texttt{reg} with one parameter: \emph{name}. \emph{name} is the string that will eventually become the lookup symbol in the standard library. If you give two parameters, the first one is the \emph{binding type}, either \texttt{special} or \texttt{macro}. The former registers special forms like \texttt{if} and \texttt{define}, and the latter registers macros like \texttt{and} or \texttt{when}.

There is also \texttt{regvar}, which registers variables. You pass the \emph{name} and \emph{value} to it. There are only a couple of variables registered this way.

\texttt{reg} and \texttt{regvar} start out by checking if the definitions register (\texttt{defreg}) exists, and if not, they create it. Then they construct a \emph{val}(ue) by concatenating a keyword (\texttt{VARIABLE}, \texttt{SPECIAL}, or \texttt{SYNTAX}) with a variation on \emph{name} (or, in \texttt{regvar}'s case, \emph{value}). Then they set an \emph{index number} based on the current size of the \texttt{defreg}. Finally they insert the concatenation of \emph{name} and \emph{val} under \emph{index}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf reg (internal)} \\
?btype? & either 'special' or 'macro' \\
name & a Tcl string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf regvar (internal)} \\
name & a Tcl string \\
val & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}
\index{regvar procedure}

\begin{lstlisting}
unset -nocomplain ::constcl::defreg

proc reg {args} {
  if {[llength $args] == 2} {
    lassign $args btype name
  } elseif {[llength $args] == 1} {
    lassign $args name
    set btype {}
  } else {
    error "wrong number of parameters\n([pn])"
  }
  if {![info exists ::constcl::defreg]} {
    set ::constcl::defreg [dict create]
  }
  switch $btype {
    special {
      set val [::list SPECIAL ::constcl::special-$name]
    }
    macro {
      set val [::list SYNTAX ::constcl::expand-$name]
    }
    default {
      set val [::list VARIABLE ::constcl::$name]
    }
  }
  set idx [dict size $::constcl::defreg]
  dict set ::constcl::defreg $idx [::list $name $val]
}

proc regvar {name value} {
  if {![info exists ::constcl::defreg]} {
    set ::constcl::defreg [dict create]
  }
  set val [::list VARIABLE $value]
  set idx [dict size $::constcl::defreg]
  dict set ::constcl::defreg $idx [::list $name $val]
}
\end{lstlisting}

\begin{pulledtext}

\subsubsection{Procedures, functions, and commands}
\label{procedures-functions-and-commands}
\index{procedures, functions, and commands}

I use all of these terms for the subroutines in ConsTcl. I try to stick to procedure, because that's the standard term in R5RS\footnote{Revised:5 Report on the Algorithmic Language Scheme, Scheme's standardization document}. Still, they usually pass useful values back to the caller, so technically they're functions. Lastly, I'm programming in Tcl here, and the usual term for these things is `commands' in Tcl.

And the `internal/public' distinction is probably a misnomer (an aside within an aside, here). What it means is that `public' procedures can be called from Lisp code being interpreted, and the others cannot. They are for use in the infrastructure around the interpreter, including in implementing the `public' procedures. Another way to put it is that procedures registered by \texttt{reg}* are `public' and those who aren't are `internal'.
\end{pulledtext}

\subsection{atom? procedure}
\label{atom-procedure}
\index{atom? procedure}

This one isn't just for my convenience: it's a standard procedure in Scheme. There are two kinds of data in Lisp: lists\index{lists} and atoms\index{atoms}. Lists are collections of lists and atoms. Atoms are instances of types such as booleans, characters, numbers, ports, strings, symbols, and vectors. \texttt{Atom?} recognizes an atom by checking for membership in any one of the atomic types. It returns \texttt{\#t} (true) if it is an atom, and \texttt{\#f} (false) if not.

\begin{pulledtext}

\subsubsection{Predicates}
\label{predicates}
\index{predicates}

By Scheme convention, predicates (procedures that return either \texttt{\#t} or \texttt{\#f}) have '?' at the end of their name. Some care is necessary when calling Scheme predicates from Tcl code (the Tcl \texttt{if} command expects 1 or 0 as truth values). Example:

\texttt{if \{[atom? \$x]\} \ldots }

will not do, but

\texttt{if \{[atom? \$x] ne "\#f"\} \ldots }

(``[atom? \$x] not equal to false'') works. Or see the \texttt{T} procedure.
\end{pulledtext}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf atom? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg atom?

proc ::constcl::atom? {val} {
  foreach type {symbol number string
      char boolean vector port eof} {
    if {[$type? $val] eq "#t"} {
      return #t
    }
  }
  return #f
}
\end{lstlisting}

\subsection{T procedure}
\label{t-procedure}
\index{T procedure}

The \texttt{T} procedure is intended to reduce the hassle of trying to make Lisp booleans work with Tcl conditions. The idea is to line the Tcl condition with \texttt{[T \ldots ]} and have the Lisp expression inside \texttt{T}. \texttt{T} returns 0 if and only if the value passed to it is \texttt{\#f}, and 1 otherwise. The procedure's name stands for `truth of'.

Example:

\begin{verbatim}
if {[T [atom? $x]]} ...
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf T (internal)} \\
val & a value \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::T {val} {
  if {$val eq "#f"} {
    return 0
  } elseif {[::constcl::boolean? $val] eq "#t" &&
    [$val boolval] eq "#f"} {
    return 0
  } else {
    return 1
  }
}
\end{lstlisting}

\subsection{assert procedure}
\label{assert-procedure}
\index{assert procedure}

\texttt{assert} signals an error if an assertion fails.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf assert (internal)} \\
expr & a Tcl expression \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc assert {expr} {
  if {![uplevel [list expr $expr]]} {
    error "Failed assertion [
      uplevel [list subst $expr]]"
  }
}
\end{lstlisting}

\subsection{pairlis-tcl procedure}
\label{pairlistcl-procedure}
\index{pairlis-tcl procedure}

A Tcl version of the procedure in the Scheme base.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pairlis-tcl (internal)} \\
lvals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::pairlis-tcl {a b} {
  if {[T [null? $a]]} {
    parse {()}
  } else {
    cons \
      [cons [car $a] [car $b]] \
      [pairlis-tcl [cdr $a] [cdr $b]]
  }
}
\end{lstlisting}

\subsection{usage procedure}
\label{usage-procedure}
\index{usage procedure}

\texttt{usage} is a simple procedure to compare a Lisp list (to wit: a Lisp expression) with the expected format of the expression. Mostly it just compares lengths.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf usage (internal)} \\
usage & an expression \\
expr & an expression \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::usage {usage expr} {
  set u $usage
  set e $expr
  if {[[length $usage] numval] !=
      [[length $expr] numval]} {
    while {$u ne "#NIL" && $e ne "#NIL"} {
      set u [cdr $u]
      set e [cdr $e]
    }
    if {$e eq "#NIL" && $u ne "#NIL" &&
      [regexp {\?.*\?} [[car $u] name]]} {
      return
    }
    ::error "usage error\n[
      $usage show] not [$expr show]"
  }
}
\end{lstlisting}

\subsection{pn procedure}
\label{pn-procedure}
\index{pn procedure}

\texttt{pn} stands for 'procedure name'. When called, tells the caller the name of its command. I use it for error messages so the error message can automagically tell the user which command failed.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pn (internal)} \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pn {} {
  namespace tail [lindex [info level -1] 0]
}
\end{lstlisting}

\subsection{unbind procedure}
\label{unbind-procedure}
\index{unbind procedure}

\texttt{unbind} removes one binding from the environment it is bound in.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf unbind (internal)} \\
syms & some symbols \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::unbind {args} {
  # TODO go from current environment
  set syms $args
  foreach sym $syms {
    set env [::constcl::global_env find $sym]
    if {$env ne "::constcl::null_env"} {
      $env unbind $sym
    }
  }
}
\end{lstlisting}

\subsection{typeof? procedure}
\label{typeof-procedure}
\index{typeof? procedure}

\texttt{typeof?} looks at a value's type and reports if it is the same as the given type. To be certain, it looks at the value in two ways: once assuming that the value is a ConsTcl object, and once assuming that the value is an interpreter\footnote{the Tcl interpreter, not ConsTcl} alias for a ConsTcl object. If one of those affirms the type, the procedure returns \texttt{\#t}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf typeof? (internal)} \\
val & a value \\
type & a Tcl string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::typeof? {val type} {
  if {[info object isa typeof $val $type]} {
    return #t
  } elseif {[info object isa typeof \
      [interp alias {} $val] $type]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{in-range procedure}
\label{inrange-procedure}
\index{in-range procedure}

This one is a little bit of both, a utility function that is also among the builtins in the library (it's not standard, though). It started out as a one-liner by Donal K. Fellows\index{Fellows, Donal}, but has grown a bit since then to suit my needs.

The plan is to arrange a sequence of numbers, given one, two or three ConsTcl Number objects. If one is passed to the procedure, it is used as the end of the sequence: the sequence will end just before it. If two numbers are passed, the first one becomes the start of the sequence: the first number in it. The second number will become the end of the sequence. If three numbers are passed, they become start, end, and step, i.e. how much is added to the current number to find next number in the sequence.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf in-range (public)} \\
x & a number \\
?e? & a number \\
?t? & a number \\
\textit{Returns:} & a Lisp list of numbers \\
\hline
\end{tabular}

\begin{lstlisting}
reg in-range

proc ::constcl::in-range {x args} {
  set start 0
  set step 1
  switch [llength $args] {
    0 {
      set e $x
      set end [$e numval]
    }
    1 {
      set s $x
      lassign $args e
      set start [$s numval]
      set end [$e numval]
    }
    2 {
      set s $x
      lassign $args e t
      set start [$s numval]
      set end [$e numval]
      set step [$t numval]
    }
  }
  set res $start
  while {$step > 0 && $end > [incr start $step] ||
      $step < 0 && $end < [incr start $step]} {
    lappend res $start
  }
  return [list {*}[lmap r $res {MkNumber $r}]]
}
\end{lstlisting}

\subsection{error procedure}
\label{error-procedure}
\index{error procedure}

\texttt{error} is used to signal an error, with \emph{msg} being a message string and the optional arguments being values to show after the message.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf error (public)} \\
msg & a message string \\
?exprs? & some expressions \\
\textit{Returns:} & -don't care- \\
\hline
\end{tabular}

\begin{lstlisting}
reg error

proc ::constcl::error {msg args} {
  if {[llength $args]} {
    set res [lmap arg $args {
      $arg show
    }]
    ::append msg " (" [join $res] ")"
  }
  ::error $msg
}
\end{lstlisting}

\subsection{check procedure}
\label{check-procedure}
\index{check procedure}

\texttt{check} does a check (typically a type check) on something and throws an error if it fails.

\begin{lstlisting}
proc ::constcl::check {cond msg} {
  if {[uplevel $cond] eq "#f"} {
    ::error [
      uplevel [
        ::list subst [
          ::string trim $msg]]]
  }
}
\end{lstlisting}

\section{Testing commands}
\label{testing-commands}
\index{Testing commands}

Testing gets easier if you have the software tools to manipulate and pick apart the testing data and actions. Short names reduce clutter in the test cases, at the cost of some readability.

\subsection{pew procedure}
\label{pew-procedure}
\index{pew procedure}

\texttt{pew} was originally named \texttt{pep} after the sequence parse-eval-print. Now it's named for parse-eval-write. It reads and evals an expression, and writes the result. It's the most common command in the test cases, since it allows me to write code directly in Scheme, get it evaled and get to see proper Lisp output from it.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pew (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pew {str {env ::constcl::global_env}} {
  ::constcl::write [
    ::constcl::eval [
      ::constcl::parse $str] $env]
}
\end{lstlisting}

\subsection{rew procedure}
\label{rew-procedure}
\index{rew procedure}

\texttt{rew} is the reading variant of \texttt{pew}. Instead of taking string input it takes a regular input port. It mattered more while the input library was being written.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rew (internal)} \\
port & an input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::rew {port {env ::constcl::global_env}} {
  ::constcl::write [
    ::constcl::eval [
      ::constcl::read $port] $env]
}
\end{lstlisting}

\subsection{pw procedure}
\label{pw-procedure}
\index{pw procedure}

\texttt{pw} is a similar command, except it doesn't eval the expression. It just writes what is parsed. It is useful for tests when the evaluator can't (yet) evaluate the form, but I can still check if it gets read and written correctly.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pw (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pw {str} {
  ::constcl::write [
    ::constcl::parse $str]
}
\end{lstlisting}

\subsection{rw procedure}
\label{rw-procedure}
\index{rw procedure}

\texttt{rw} is the reading variant of \texttt{pw}. Instead of taking string input it takes a regular input port. The procedure just writes what is read.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rw (internal)} \\
?port? & an input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::rw {args} {
  ::constcl::write [
    ::constcl::read {*}$args]
}
\end{lstlisting}

\subsection{pe procedure}
\label{pe-procedure}
\index{pe procedure}

\texttt{pe} is also similar, but it doesn't write the expression. It just evaluates what is read. That way I get a value object which I can pass to another command, or pick apart in different ways.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pe (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pe {str {env ::constcl::global_env}} {
  ::constcl::eval [
    ::constcl::parse $str] $env
}
\end{lstlisting}

\subsection{re procedure}
\label{re-procedure}
\index{re procedure}

\texttt{re} is like \texttt{pe}, but it reads from a regular port instead of an string input port. It evaluates what is read.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf re (internal)} \\
port & an input port \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::re {port {env ::constcl::global_env}} {
  ::constcl::eval [
    ::constcl::read $port] $env
}
\end{lstlisting}

\subsection{p procedure}
\label{p-procedure}
\index{p procedure}

\texttt{p} only parses the input, returning an expression object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf p (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::p {str} {
  ::constcl::parse $str
}
\end{lstlisting}

\subsection{e procedure}
\label{e-procedure}
\index{e procedure}

\texttt{e} is another single-action procedure, evaluating an expression and returning a value.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf e (internal)} \\
expr & an expression \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::e {expr {env ::constcl::global_env}} {
  ::constcl::eval $expr $env
}
\end{lstlisting}

\subsection{w procedure}
\label{w-procedure}
\index{w procedure}

\texttt{w} is the third single-action procedure, printing a value and that's all.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf w (internal)} \\
val & a value \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::w {val} {
  ::constcl::write $val
}
\end{lstlisting}

\subsection{r procedure}
\label{r-procedure}
\index{r procedure}

\texttt{r} is an extra single-action procedure, reading from default input or from a port and returning an expression object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf r (internal)} \\
?port? & an input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::r {args} {
  ::constcl::read {*}$args
}
\end{lstlisting}

\subsection{prw procedure}
\label{prw-procedure}
\index{prw procedure}

\texttt{prw} reads an expression, resolves defines, and writes the result. It was handy during the time I was porting the `resolve local defines' section.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf prw (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::prw {str} {
  set expr [::constcl::parse $str]
  set expr [::constcl::resolve-local-defines \
    [::constcl::cdr $expr]]
  ::constcl::write $expr
}
\end{lstlisting}

\subsection{pxw procedure}
\label{pxw-procedure}
\index{pxw procedure}

\texttt{pxw} attempts to macro-expand whatever it reads, and writes the result. (I do know that 'expand' doesn't start with an 'x'.) Again, this command's heyday was when I was developing the macro facility.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pxw (internal)} \\
str & a Tcl string, Lisp string, or a string input port \\
?env? & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::pxw {str {env ::constcl::global_env}} {
  set expr [::constcl::parse $str]
  set op [::constcl::car $expr]
  lassign [::constcl::binding-info $op $env] btype hinfo
  if {$btype eq "SYNTAX"} {
    set expr [$hinfo $expr $env]
    ::constcl::write $expr
  } else {
    puts "not a macro"
  }
}
\end{lstlisting}

\section{Some small classes}
\label{some-small-classes}
\index{some small classes}

\subsection{Dot class}
\label{dot-class}
\index{Dot class}

The \texttt{Dot} class is a helper class for the parser.

\begin{lstlisting}
catch { ::constcl::Dot destroy }

oo::class create ::constcl::Dot {
  method mkconstant {} {}
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "."
  }
}
\end{lstlisting}

\subsection{dot? procedure}
\label{dot-procedure}
\index{dot? procedure}

\texttt{dot?} is a type predicate that checks for membership in the type \texttt{Dot}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf dot? (internal)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::dot? {val} {
  typeof? $val "Dot"
}
\end{lstlisting}

\subsection{EndOfFile class}
\label{endoffile-class}
\index{EndOfFile class}

The \texttt{EndOfFile} class is for end-of-file\index{end of file} conditions.

\begin{lstlisting}
catch { ::constcl::EndOfFile destroy }

oo::singleton create ::constcl::EndOfFile {
  method mkconstant {} {}
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "#<end-of-file>"
  }
}
\end{lstlisting}

\subsection{eof? procedure}
\label{eof-procedure}
\index{eof? procedure}

\texttt{eof?} is a type predicate that recognizes the end-of-file object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf eof? (internal)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc eof? {val} {
  if {$val eq "#EOF"} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{NIL class}
\label{nil-class}
\index{NIL class}

The \texttt{NIL} class has one object: the empty list called \texttt{\#NIL}. It is also base class for many other type classes.

\begin{lstlisting}
catch { ::constcl::NIL destroy }

oo::singleton create ::constcl::NIL {
  method boolval {} {
    return #t
  }
  method car {} {
    ::error "PAIR expected"
  }
  method cdr {} {
    ::error "PAIR expected"
  }
  method set-car! {v} {
    ::error "PAIR expected"
  }
  method set-cdr! {v} {
    ::error "PAIR expected"
  }
  method numval {} {
    ::error "NUMBER expected"
  }
  method mkconstant {} {}
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "()"
  }
}
\end{lstlisting}

\subsection{null? procedure}
\label{null-procedure}
\index{null? procedure}

The \texttt{null?} standard predicate recognizes the empty list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf null? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg null?

proc ::constcl::null? {val} {
  if {$val eq "#NIL"} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{Undefined class}
\label{undefined-class}
\index{Undefined class}

The \texttt{Undefined} class is for undefined things. It was created to facilitate porting of code from `Scheme 9 from Empty Space'\index{S9fES}.

\begin{lstlisting}
catch { ::constcl::Undefined destroy }

oo::singleton create ::constcl::Undefined {
  method mkconstant {} {}
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "#<undefined>"
  }
}
\end{lstlisting}

\subsection{Unspecified class}
\label{unspecified-class}
\index{Unspecified class}

The \texttt{Unspecified} class is for unspecified things. Also a S9fES support class.

\begin{lstlisting}
catch { ::constcl::Unspecified destroy }

oo::singleton create ::constcl::Unspecified {
  method mkconstant {} {}
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "#<unspecified>"
  }
}
\end{lstlisting}

\chapter{Input}
\label{input}

The first thing an interpreter must be able to do is to take in the user's code and data input\index{input}, whether from the keyboard or from a source file. \texttt{read} represents the interpreter's main input facility. The \texttt{read-} procedures read from standard input, or--if a port is provided--from the port's channel.

The main input procedures, \texttt{read} and the non-standard \texttt{parse}, do more than just read in the text of code and data: they also \emph{parse} the input into an \emph{internal representation} that the evaluator can use.

\section{The parsing process}
\label{the-parsing-process}
\index{the parsing process}

Parsing\footnote{See \texttt{https://en.wikipedia.org/wiki/Parsing}}\index{parsing}, or syntactic analysis, is analyzing a sequence of letters, digits, and other characters, conforming to the rules of \emph{external representation}\index{external representation}. The result of parsing is an \emph{expression}\index{expression}.

The parsing process translates a piece of text from external representation to internal representation.

\subsection{External representation}
\label{external-representation}
\index{external representation}

The external representation is a 'recipe' for an expression that expresses it in a unique way.

For example, the external representation for a vector is a pound sign (\texttt{\#}), a left parenthesis (\texttt{(}), the external representation for some values, and a right parenthesis (\texttt{)}). When the reader or parser is working through input, a \texttt{\#(} symbol signals that a vector structure is being read. A number of subexpressions for the elements of the vector follow, and then a closing parenthesis \texttt{)} signals that the vector is done. The elements are saved in vector memory and the vector gets the address to the first element and the number of elements.

\includegraphics{images/vector-representation.png}

The \texttt{parse} or \texttt{read} procedure takes in the input buffer character by character, matching each character against a fitting external representation. When done, it creates a ConsTcl object, which is the internal representation of an expression. The object can then be passed to the evaluator.

Given a string, \texttt{parse} creates a string input port for itself to read from. It then parses the input and produces the internal representation of an expression.

Example:

\begin{verbatim}
% ::constcl::parse "(+ 2 3)"
::oo::Obj491
\end{verbatim}

Here, \texttt{parse} parsed the external representation of a list with three elements, +, 2, and 3. It produced the expression that has an internal representation labeled \texttt{::oo::Obj491}. I will now reach briefly into the following chapters and present procedures like \texttt{eval}, which transforms an expression into a value, and \texttt{write}, which writes a printed external representation of expressions and values. Putting them together we can see

\begin{verbatim}
% ::constcl::write ::oo::Obj491
(+ 2 3)
% ::constcl::eval ::oo::Obj491
::oo::Obj494
% ::constcl::write ::oo::Obj494
5
\end{verbatim}

Fortunately, we don't \emph{have} to work at such a low level. We can use the \texttt{repl}\index{repl} instead:

\begin{verbatim}
ConsTcl> (+ 2 3)
5
\end{verbatim}

Then, parsing and evaluation and writing goes on in the background and the internal representations of expressions and values are hidden.

Anyway, the figure shows what it really looks like. \texttt{::oo::Obj491} was just the head of the list.

\begin{figure}[h!]\includegraphics{images/intreplist.png}\captionsetup{labelformat=empty}\caption{The internal structure of the expression}\label{fig:the-internal-structure-of-the-expression}\end{figure}

\section{Input procedures}
\label{input-procedures}
\index{input procedures}

\begin{pulledtext}

\subsubsection{Ports}
\label{ports}
\index{Ports}

Ports are an abstraction of the input or output mechanism. An input port can be connected to standard input (the keyboard) or a file opened for input or a string input buffer where the complete available input is laid out before reading starts. Regardless of what kind of input port it is, one can read characters from it until it runs out and signals end-of-file. Likewise, an output port, regardless of whether it's the standard output--the screen--or a file opened for output, will receive characters sent to it.
\end{pulledtext}

\subsection{parse procedure}
\label{parse-procedure}
\index{parse procedure}

\texttt{parse} can be called with either a string input port or a Tcl or ConsTcl string (which it uses to open a string input port). Once the input port is established, \texttt{parse} leaves control to \texttt{read-expr} (see page \pageref{read-expr-procedure}).

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf parse (internal)} \\
inp & a Tcl string, Lisp string, or a string input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg parse

proc ::constcl::parse {inp} {
  set c {}
  set unget {}
  if {[info object isa object $inp]} {
    if {[T [typeof? $inp StringInputPort]]} {
      set port $inp
    } elseif {[T [typeof? $inp String]]} {
      set port [StringInputPort new [$inp value]]
    } else {
      ::error "Unknown object [$inp show]"
    }
  } else {
    # It's a Tcl string, we hope
    set port [StringInputPort new $inp]
  }
  set oldport $::constcl::Input_port
  set ::constcl::Input_port $port
  set expr [read-expr]
  set ::constcl::Input_port $oldport
  return $expr
}
\end{lstlisting}

\subsection{read procedure}
\label{read-procedure}
\index{read procedure}

The standard builtin \texttt{read} reads an input port the same way that \texttt{parse} does, but one can't pass a string to it. The \texttt{read-} procedures parse their input and produce ConsTcl objects.

One can pass a port to \texttt{read} (including a string input port) in which case \texttt{read} sets the standard input port temporarily to the provided port. If not, \texttt{read} uses the default standard input port (usually the keyboard\footnote{which doesn't work in a Windows windowing environment, e.g. wish or tkcon. repl does work in those, though. Input works in tclsh on Windows.}).

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read (public)} \\
?port? & an input port \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg read

proc ::constcl::read {args} {
  set c {}
  set unget {}
  set oldport $::constcl::Input_port
  if {[llength $args]} {
    lassign $args port
    set ::constcl::Input_port $port
  }
  set expr [read-expr]
  set ::constcl::Input_port $oldport
  return $expr
}
\end{lstlisting}

\section{Input helper procedures}
\label{input-helper-procedures}
\index{input helper procedures}

\subsection{make-constant procedure}
\label{makeconstant-procedure}
\index{make-constant procedure}

The \texttt{make-constant} helper procedure is called to set expressions to constants when read as a literal.

\begin{lstlisting}
proc ::constcl::make-constant {val} {
  if {[T [pair? $val]]} {
    $val mkconstant
    make-constant [car $val]
    make-constant [cdr $val]
  } elseif {[T [null? $val]]} {
    return #NIL
  } else {
    $val mkconstant
  }
}
\end{lstlisting}

\subsection{interspace? procedure}
\label{interspace-procedure}
\index{interspace? procedure}

The \texttt{interspace?} helper procedure recognizes whitespace between value representations.

\begin{lstlisting}
proc ::constcl::interspace? {c} {
  if {[::string is space $c]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{delimiter? procedure}
\label{delimiter-procedure}
\index{delimiter? procedure}

The \texttt{delimiter?} helper procedure recognizes delimiter characters between value representations.

\begin{lstlisting}
proc ::constcl::delimiter? {c} {
  if {$c in {( ) ; \" ' ` | [ ] \{ \}}} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{valid-char? procedure}
\label{validchar-procedure}
\index{valid-char? procedure}

The \texttt{valid-char?} helper procedure compares a potential character constant to the valid kinds.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf valid-char? (internal)} \\
name & a Tcl string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::valid-char? {name} {
  if {[regexp {(?i)^#\\([[:graph:]]|space|newline)$} \
      $name]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{readchar procedure}
\label{readchar-procedure}
\index{readchar procedure}

\texttt{readchar} reads one character from the \texttt{unget} store if it isn't empty or else from the input port. If the input is at end-of-file, an \texttt{\#EOF} object is returned. Shares the variable \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf readchar (internal)} \\
\textit{Returns:} & a Tcl character or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::readchar {} {
  upvar unget unget
  if {$unget ne {}} {
    set c $unget
    set unget {}
  } else {
    set c [$::constcl::Input_port get]
    if {[$::constcl::Input_port eof]} {
      return #EOF
    }
  }
  return $c
}
\end{lstlisting}

\subsection{find-char? procedure}
\label{findchar-procedure}
\index{find-char? procedure}

\texttt{find-char?} reads ahead through whitespace to find a given character. It returns \texttt{\#t} if it has found the character, and \texttt{\#f} if it has stopped at some other character. Returns end of file if eof is encountered. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf find-char? (internal)} \\
char & a Tcl character \\
\textit{Returns:} & a boolean or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::find-char? {char} {
  upvar c c unget unget
  while {[::string is space -strict $c]} {
    set c [readchar]
    read-eof $c
    set unget $c
  }
  expr {($c eq $char) ? "#t" : "#f"}
}
\end{lstlisting}

\subsection{read-end? procedure}
\label{readend-procedure}
\index{read-end? procedure}

\texttt{read-end?} reads one character and returns \texttt{\#t} if it is an interspace character or a delimiter character, or end of file. Otherwise it returns \texttt{\#f}. It ungets the character before returning. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-end? (internal)} \\
\textit{Returns:} & a boolean or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-end? {} {
  upvar c c unget unget
  set c [readchar]
  if {[T [interspace? $c]] ||
      [T [delimiter? $c]] ||
      $c eq "#EOF"} {
    set unget $c
    return #t
  } else {
    set unget $c
    return #f
  }
}
\end{lstlisting}

\subsection{skip-ws procedure}
\label{skipws-procedure}
\index{skip-ws procedure}

\texttt{skip-ws} skips whitespace and comments (the \texttt{;} to end of line kind). It leaves the first character not to be skipped in \texttt{c} and also ungets it. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf skip-ws (internal)} \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::skip-ws {} {
  upvar c c unget unget
  while true {
    switch -regexp $c {
      {[[:space:]]} {
        set c [readchar]
      }
      {;} {
        while {$c ne "\n" && $c ne "#EOF"}  {
          set c [readchar]
        }
      }
      default {
        set unget $c
        return
      }
    }
  }
}
\end{lstlisting}

\subsection{read-eof procedure}
\label{readeof-procedure}
\index{read-eof procedure}

\texttt{read-eof} checks a number of presumed characters for possible end-of-file objects. If it finds one, it returns \emph{from its caller} with the EOF value.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-eof (internal)} \\
chars & some characters \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-eof {args} {
  set chars $args
  foreach char $chars {
    if {$char eq "#EOF"} {
      return -level 1 -code return #EOF
    }
  }
}
\end{lstlisting}

\section{Reader procedures}
\label{reader-procedures}
\index{reader procedures}

Reader procedures specialize in reading a certain kind of input, except for \texttt{read-expr} which reads them all (with a little help).

\subsection{read-expr procedure}
\label{readexpr-procedure}
\index{read-expr procedure}

The \texttt{read-expr} procedure reads the first available character from the input port. Based on that it delegates to one of the more detailed readers, producing an expression of any kind. A Tcl character value can be passed to it: that character will be used first before reading from the input. If end of file is encountered before an expression can be read in full, the procedure returns end of file (\texttt{\#EOF})\index{end of file}. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-expr (internal)} \\
?char? & a Tcl character \\
\textit{Returns:} & an expression or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-expr {args} {
  upvar c c unget unget
  if {[llength $args]} {
    lassign $args c
  } else {
    set c [readchar]
  }
  set unget {}
  read-eof $c
  if {[::string is space $c] || $c eq ";"} {
    skip-ws
    read-eof $c
  }
  switch -regexp $c {
    {\"}          { read-string-expr }
    {\#}          { read-pound }
    {\'}          { read-quoted-expr }
    {\(}          { read-pair-expr ")" }
    {\+} - {\-}   { read-plus-minus $c }
    {\,}          { read-unquoted-expr }
    {\.} {
        set x [Dot new]; set c [readchar]; set x
    }
    {\:}          { read-object-expr }
    {\[}          { read-pair-expr "\]" }
    {\`}          { read-quasiquoted-expr }
    {\d}          { read-number-expr $c }
    {^$}          { return }
    {[[:graph:]]} { read-identifier-expr $c }
    default {
      read-eof $c
      ::error "unexpected character ($c)"
    }
  }
}
\end{lstlisting}

\subsection{read-character-expr procedure}
\label{readcharacterexpr-procedure}
\index{read-character-expr procedure}

\texttt{read-character-expr} is activated by \texttt{read-pound} when that procedure finds a backslash in the input stream (pound-backslash is the external representation prefix for characters). It reads one or more characters to produce a character expression and return a Char (see page \pageref{characters}) object. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-character-expr (internal)} \\
\textit{Returns:} & a character or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-character-expr {} {
  upvar c c unget unget
  set name "#\\"
  set c [readchar]
  read-eof $c
  while {![T [delimiter? $c]] &&
      [::string is graph $c] &&
      $c ne "#EOF"} {
    ::append name $c
    set c [readchar]
  }
  check {valid-char? $name} {
      Invalid character constant $name
  }
  set expr [MkChar $name]
  read-eof $expr
  return $expr
}
\end{lstlisting}

\subsection{read-identifier-expr procedure}
\label{readidentifierexpr-procedure}
\index{read-identifier-expr procedure}

\texttt{read-identifier-expr} is activated for 'anything else', and takes in characters until it finds whitespace or a delimiter character. If it is passed one or more characters it will use them before consuming any from input. It checks the input against the rules for identifiers, accepting or rejecting it with an error message. It returns a Symbol (see page \pageref{symbols}) object. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-identifier-expr (internal)} \\
?chars? & some Tcl characters \\
\textit{Returns:} & a symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-identifier-expr {args} {
  upvar c c unget unget
  set unget {}
  if {[llength $args]} {
    set c [join $args {}]
  } else {
    set c [readchar]
  }
  read-eof $c
  set name {}
  while {[::string is graph -strict $c]} {
    if {$c eq "#EOF" || [T [interspace? $c]] ||
      [T [delimiter? $c]]} {
      break
    }
    ::append name $c
    set c [readchar]
    # do not check for EOF here
  }
  if {$c ne "#EOF"} {
    set unget $c
  }
  read-eof $name
  # idcheck throws error if invalid identifier
  idcheck $name
  return [S $name]
}
\end{lstlisting}

\subsection{read-number-expr procedure}
\label{readnumberexpr-procedure}
\index{read-number-expr procedure}

\texttt{read-number-expr} reads numerical input, both integers and floating point numbers. It is activated by \texttt{read-expr} or \texttt{read-plus-minus} if they encounter digits, and it actually takes in anything that starts out like a number and stops at whitespace or a delimiter character, and then it accepts or rejects the input by comparing it to a Tcl double. It returns a Number (see page \pageref{numbers}) object. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-number-expr (internal)} \\
?char? & a Tcl character \\
\textit{Returns:} & a number or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-number-expr {args} {
  upvar c c unget unget
  set unget {}
  if {[llength $args]} {
    lassign $args c
  } else {
    set c [readchar]
  }
  read-eof $c
  while {[interspace? $c] ne "#t" && $c ne "#EOF" &&
      ![T [delimiter? $c]]} {
    ::append num $c
    set c [readchar]
  }
  set unget $c
  check {::string is double -strict $num} {
      Invalid numeric constant $num
  }
  set expr [N $num]
  return $expr
}
\end{lstlisting}

\subsection{read-object-expr procedure}
\label{readobjectexpr-procedure}
\index{read-object-expr procedure}

A non-standard extension, \texttt{read-object-expr} reads a ConsTcl object of any kind and passes its name along. It is activated when \texttt{read-expr} finds a colon in the input. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-object-expr (internal)} \\
\textit{Returns:} & a ConsTcl object or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-object-expr {} {
  upvar c c unget unget
  # first colon has already been read
  foreach ch [split ":oo::Obj" {}] {
    set c [readchar]
    read-eof $c
    if {$c ne $ch} {
      error "bad object name"
    }
  }
  set res "::oo::Obj"
  set c [readchar]
  read-eof $c
  while {[::string is digit $c]} {
    ::append res $c
    set c [readchar]
    read-eof $c
  }
  set unget $c
  return $res
}
\end{lstlisting}

\subsection{read-pair-expr procedure}
\label{readpairexpr-procedure}
\index{read-pair-expr procedure}

The \texttt{read-pair-expr} procedure reads everything between two matching parentheses, or, as the case might be, brackets. It produces either an empty list, or a possibly recursive structure of Pair (see page \pageref{pairs-and-lists}) objects, either a proper list (one that ends in \texttt{\#NIL}), or an improper one (one that has an atom as its last member). Shares the variables \texttt{c} and \texttt{unget} with its caller.

\begin{figure}[h!]\includegraphics{images/prop-improp.png}\captionsetup{labelformat=empty}\caption{A proper list and two improper ones.}\label{fig:a-proper-list-and-two-improper-ones}\end{figure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-pair-expr (internal)} \\
char & the terminating paren or bracket \\
\textit{Returns:} & a structure of pair expressions or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-pair-expr {char} {
  upvar c c unget unget
  set unget {}
  set expr [read-pair $char]
  read-eof $expr
  if {$c ne $char} {
    if {$char eq ")"} {
      ::error \
        "Missing right paren. ($c)."
    } else {
      ::error \
        "Missing right bracket ($c)."
    }
  } else {
    set unget {}
    set c [readchar]
  }
  return $expr
}
\end{lstlisting}

\textbf{read-pair} procedure

\texttt{read-pair} is a helper procedure that does the heavy lifting in reading a pair structure. First it checks if the list is empty, returning \texttt{\#NIL} in that case. Otherwise it reads the first element in the list and then repeatedly the rest of them. If it reads a Dot object, the following element to be read is the tail end of an improper list. When \texttt{read-pair} has reached the ending parenthesis or bracket, it conses up the elements starting from the last, and returns the head of the list. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-pair (internal)} \\
char & the terminating paren or bracket \\
\textit{Returns:} & a structure of pair expressions or end of file \\
\hline
\end{tabular}
\index{read-pair}

\begin{lstlisting}
proc ::constcl::read-pair {char} {
  upvar c c unget unget
  set c [readchar]
  read-eof $c
  if {[T [find-char? $char]]} {
    # read right paren/brack
    #set c [readchar]
    return #NIL
  }
  set a [read-expr $c]
  set res $a
  skip-ws
  set prev #NIL
  while {[find-char? $char] eq "#f"} {
    set x [read-expr $c]
    skip-ws
    read-eof $c
    if {[T [dot? $x]]} {
      set prev [read-expr $c]
      skip-ws
      read-eof $c
    } else {
      lappend res $x
    }
    if {[llength $res] > 99} break
  }
  # read right paren/brack
  foreach r [lreverse $res] {
    set prev [cons $r $prev]
  }
  return $prev
}
\end{lstlisting}

\subsection{read-plus-minus procedure}
\label{readplusminus-procedure}
\index{read-plus-minus procedure}

\texttt{read-plus-minus} is called when a plus or minus is found in the input stream. The plus or minus character is passed to it. If the next character is a digit, it delegates to the number reader. If it is a space character or a delimiter, it returns a \texttt{+} or \texttt{-} symbol. Otherwise, it delegates to the identifier reader. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-plus-minus (internal)} \\
char & a Tcl character \\
\textit{Returns:} & either the symbols + or - or a number or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-plus-minus {char} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
  if {[::string is digit -strict $c]} {
    set n [read-number-expr $c]
    read-eof $n
    if {$char eq "-"} {
      set n [- $n]
    }
    return $n
  } elseif {[::string is space -strict $c] ||
      [T [delimiter? $c]]} {
    if {$char eq "+"} {
      return [S "+"]
    } else {
      return [S "-"]
    }
  } else {
    set n [read-identifier-expr $char $c]
    read-eof $n
    return $n
  }
}
\end{lstlisting}

\subsection{read-pound procedure}
\label{readpound-procedure}
\index{read-pound procedure}

\texttt{read-pound} is activated by \texttt{read-expr} when it reads a pound sign (\texttt{\#}). It in turn either delegates to the vector reader or the character reader, or returns boolean literals. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-pound (internal)} \\
\textit{Returns:} & a vector, boolean, or character value or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-pound {} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
  switch $c {
    (    { set n [read-vector-expr] }
    t    { if {[T [read-end?]]} {set n #t} }
    f    { if {[T [read-end?]]} {set n #f} }
    "\\" { set n [read-character-expr] }
    default {
      ::error "Illegal #-literal: #$c"
    }
  }
  return $n
}
\end{lstlisting}

\subsection{read-quasiquoted-expr procedure}
\label{readquasiquotedexpr-procedure}
\index{read-quasiquoted-expr procedure}

\texttt{read-quasiquoted-expr} is activated when there is a backquote (\texttt{`}) in the input stream. It reads an entire expression and returns it wrapped in \texttt{quasiquote}. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-quasiquoted-expr (internal)} \\
\textit{Returns:} & an expr. wr. in the quasiquote symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-quasiquoted-expr {} {
  upvar c c unget unget
  set unget {}
  set expr [read-expr]
  read-eof $expr
  make-constant $expr
  return [list [S quasiquote] $expr]
}
\end{lstlisting}

\subsection{read-quoted-expr procedure}
\label{readquotedexpr-procedure}
\index{read-quoted-expr procedure}

\texttt{read-quoted-expr} is activated by \texttt{read-expr} when reading a single quote ('). It then reads an entire expression beyond that, returning it wrapped in a list with \texttt{quote}. The quoted expression is made constant. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-quoted-expr (internal)} \\
\textit{Returns:} & an expression wrapped in the quote symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-quoted-expr {} {
  upvar c c unget unget
  set unget {}
  set expr [read-expr]
  read-eof $expr
  make-constant $expr
  return [list [S quote] $expr]
}
\end{lstlisting}

\subsection{read-string-expr procedure}
\label{readstringexpr-procedure}
\index{read-string-expr procedure}

\texttt{read-string-expr} is activated by \texttt{read-expr} when it reads a double quote. It collects characters until it reaches another (unescaped) double quote. To have double quotes in the string, escape them with backslash (which also means that backslashes have to be escaped with backslash). A backslash+n pair of characters denotes a newline (this is a ConsTcl extension). It then returns a string expression--an immutable String (see page \pageref{strings}) object. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-string-expr (internal)} \\
\textit{Returns:} & a string or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-string-expr {} {
  upvar c c unget unget
  set str {}
  set c [readchar]
  read-eof $c
  while {$c ne "\"" && $c ne "#EOF"} {
    if {$c eq "\\"} {
      ::append str $c
      set c [readchar]
    }
    ::append str $c
    set c [readchar]
  }
  if {$c eq "#EOF"} {
    error "bad string (no ending double quote)"
  }
  set c [readchar]
  set expr [MkString $str]
  read-eof $expr
  make-constant $expr
  return $expr
}
\end{lstlisting}

\subsection{read-unquoted-expr procedure}
\label{readunquotedexpr-procedure}
\index{read-unquoted-expr procedure}

When a comma is found in the input stream, \texttt{read-unquoted-expr} is activated. If it reads an at-sign (\texttt{@}) it selects the symbol \texttt{unquote-splicing}, otherwise it selects the symbol \texttt{unquote}. Then it reads an entire expression and returns it wrapped in the selected symbol. Both of these expressions are only supposed to occur inside a quasiquoted expression. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-unquoted-expr (internal)} \\
\textit{Returns:} & an expr. wr. in the unquote/-splicing symbol or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-unquoted-expr {} {
  upvar c c unget unget
  set unget {}
  set c [readchar]
  read-eof $c
  if {$c eq "@"} {
    set symbol "unquote-splicing"
    set expr [read-expr]
  } else {
    set symbol "unquote"
    set expr [read-expr $c]
  }
  read-eof $expr
  return [list [S $symbol] $expr]
}
\end{lstlisting}

\subsection{read-vector-expr procedure}
\label{readvectorexpr-procedure}
\index{read-vector-expr procedure}

\texttt{read-vector-expr} is activated by \texttt{read-pound} and reads a number of expressions until it finds an ending parenthesis. It produces a vector expression and returns a Vector (see page \pageref{vectors}) object. Shares the variables \texttt{c} and \texttt{unget} with its caller.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf read-vector-expr (internal)} \\
\textit{Returns:} & a vector or end of file \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::read-vector-expr {} {
  upvar c c unget unget
  set res {}
  set last {}
  set c [readchar]
  while {$c ne "#EOF" && $c ne ")"} {
    set e [cons [read-expr $c] #NIL]
    if {$res eq {}} {
      set res $e
      set last $e
    } else {
      set-cdr! $last $e
      set last $e
    }
    skip-ws
    read-eof $c
  }
  if {$c ne ")"} {
    ::error "Missing right paren. ($c)."
  }
  set unget {}
  set c [readchar]
  set expr [MkVector $res]
  read-eof $expr
  $expr mkconstant
  return $expr
}
\end{lstlisting}

\chapter{Evaluation}
\label{evaluation}

The second thing an interpreter must be able to do is to reduce expressions to their \emph{normal form}, or \emph{evaluate}\index{eval}\index{evaluate} them. As an example, 2 + 6 and 8 are two expressions that have the same value, but the latter is in normal form (can't be reduced further) and the former is not.

To be able to evaluate every kind of expression, a structured approach is needed. Lisp has nine syntactic forms, each with its own syntax, and each with its own process of evaluation.

\begin{description}
\item[variable reference] Syntax: a symbol. Process: variable lookup (see page \pageref{variable-reference}).
\item[constant literal] Syntax: a number, string, character, or boolean. Process: take the value (see page \pageref{constant-literal}).
\item[quotation] Syntax: \texttt{(quote datum)}. Process: take the datum (see page \pageref{quotation}).
\item[conditional] Syntax: \texttt{if}, \texttt{case}, or \texttt{cond}. Process: depends on which syntax (see page \pageref{conditional}).
\item[sequence] Syntax: \texttt{(begin expression \ldots )}. Process: evaluate all expressions, take value of the last (see page \pageref{sequence}).
\item[definition] Syntax: \texttt{(define var val)}. Process: bind a variable to a location, store the value there (see page \pageref{definition}).
\item[assignment] Syntax: \texttt{(set! var val)}. Process: take a bound variable, store the value to its location (see page \pageref{assignment}).
\item[procedure definition] Syntax: \texttt{(lambda formals body)}. Process: take formals and body and apply lambda to get a procedure value (see page \pageref{procedure-definition}).
\item[procedure call] Syntax: \texttt{(operator operand \ldots )}. Process: invoke operator on operands (see page \pageref{procedure-call}).
\end{description}

The evaluator recognizes the syntax of the expression and chooses the appropriate process to evaluate it. How this happens for the nine syntactic forms will be described in the following sections.

A word about \emph{environments}: an environment is where evaluating code keeps track of things. This is why most of the procedures in this chapter get a reference to an environment when they are called. More about environments very soon (see page \pageref{environments}).

\section{Variable reference}
\label{variable-reference}
\index{variable reference}

\emph{Example: \texttt{r} $\Rightarrow$ 10 (a symbol \texttt{r} is evaluated to what it's bound to)}

A variable\index{variable} is about a symbol, a location in the environment, and a value. The symbol is \emph{bound}\index{bound symbol} to the location, and the value is stored there. When an expression consists of the symbol, the evaluator does \emph{lookup} and finds the value.

This is handled by the helper procedure \texttt{lookup}. It (or rather, the helper procedure \texttt{binding-info}) searches the environment chain (see page \pageref{environments}) for the symbol, and returns the value stored in the location it is bound to. It is an error to do lookup on an unbound symbol, or a symbol that is bound for some other purpose, such as being a keyword or a macro.

Syntax: \emph{symbol}

\subsection{lookup procedure}
\label{lookup-procedure}
\index{lookup procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf lookup (internal)} \\
sym & a symbol \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::lookup {sym env} {
  lassign [binding-info $sym $env] type value
  if {$type eq "VARIABLE"} {
    return $value
  } else {
    error "not a variable name" $sym
  }
}
\end{lstlisting}

\section{Constant literal}
\label{constant-literal}
\index{constant literal}

\emph{Example: \texttt{99} $\Rightarrow$ 99 (a number evaluates to itself)}

Not just numbers but booleans, characters, and strings evaluate to themselves, to their innate value. Because of this, they are called self-evaluating or autoquoting types (see next section).

Syntax: \emph{number} | \emph{string} | \emph{character} | \emph{boolean}

\textbf{self-evaluating?} procedure

Only numeric, string, character, and boolean constants evaluate to themselves. This procedure returns \texttt{\#t} if the given value is a self-evaluating value, and \texttt{\#f} otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf self-evaluating? (internal)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{self-evaluating? procedure}

\begin{lstlisting}
proc ::constcl::self-evaluating? {val} {
  if {[T [number? $val]] ||
    [T [string? $val]] ||
    [T [char? $val]] ||
    [T [boolean? $val]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\section{Quotation}
\label{quotation}
\index{quotation}

\emph{Example: \texttt{(quote r)} $\Rightarrow$ \texttt{r} (quotation makes the symbol evaluate to itself, like a constant)}

According to the rules of variable reference, a symbol evaluates to its stored value. Sometimes one wishes to use the symbol itself as a value. That is partly what quotation\index{quotation} is for. \texttt{(quote x)} evaluates to the symbol \texttt{x} itself and not to any value that might be stored under it. This is so common that there is a shorthand notation for it: \texttt{'x} is interpreted as \texttt{(quote x)} by the Lisp reader (see page \pageref{reader-procedures}). The argument of \texttt{quote} may be any external representation (see page \pageref{external-representation}) of a Lisp object. In this way, for instance a vector or list constant can be introduced in the program text.

\subsection{quote special form}
\label{quote-special-form}
\index{quote special form}

Syntax: (\textbf{quote} \emph{datum})

The \texttt{quote} special form is expanded by \texttt{special-quote}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-quote (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special quote

proc ::constcl::special-quote {expr env} {
  cadr $expr
}
\end{lstlisting}

\section{Conditional}
\label{conditional}
\index{conditional}

\emph{Example: \texttt{(if (> 99 100) (* 2 2) (+ 2 4))} $\Rightarrow$ 6}

The conditional form \texttt{if} takes three expressions. The first, the \emph{condition}, is evaluated first. If it evaluates to true, i.e. anything other than the value \texttt{\#f} (false), the second expression (the \emph{consequent}) is evaluated and the value returned. Otherwise, the third expression (the \emph{alternate}) is evaluated and the value returned. One of the two latter expressions will be evaluated, and the other will remain unevaluated. The \emph{alternate} can be omitted.

\subsection{if special form}
\label{if-special-form}
\index{if special form}

Syntax: (\textbf{if} \emph{condition} \emph{consequent} ?\emph{alternate}?)

The \texttt{if} special form is expanded by \texttt{special-if}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-if (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special if

proc ::constcl::special-if {expr env} {
  set args [cdr $expr]
  if {[T [null? [cddr $args]]]} {
    /if1 {[eval [car $args] $env]} \
      {eval [cadr $args] $env}
  } else {
    /if {[eval [car $args] $env]} \
      {eval [cadr $args] $env} \
      {eval [caddr $args] $env}
  }
}
\end{lstlisting}

The two procedures that help the if form out are \texttt{/if} and \texttt{/if1}. The former takes both a consequent and an alternate, the latter takes only a consequent.

\textbf{/if} procedure \textbf{/if1} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf /if (internal)} \\
cond & an expression \\
conseq & an expression \\
altern & an expression \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf /if1 (internal)} \\
cond & an expression \\
conseq & an expression \\
\textit{Returns:} & a value \\
\hline
\end{tabular}
\index{/if}
\index{/if1}

\begin{lstlisting}
proc ::constcl::/if {cond conseq altern} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  } else {
    uplevel $altern
  }
}

proc ::constcl::/if1 {cond conseq} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  }
}
\end{lstlisting}

\subsection{case special form}
\label{case-special-form}
\index{case special form}

Another conditional form is \texttt{case}. It implements a multi-choice where a single expression selects between alternatives. The body of the \texttt{case} form consists of a key-expression and a number of clauses. Each clause has a list of values and a body. If the key-expression evaluates to a value that occurs in one of the value-lists (considered in order), that clause's body is evaluated and all other clauses are ignored.

Syntax: (\textbf{case} \emph{key} \emph{clause} \ldots )

Where each \emph{clause} has the form

((\emph{datum} \ldots ) \emph{expression} \ldots )

The last clause may have the form

(\textbf{else} \emph{expression} \ldots )

Example:

\begin{verbatim}
(case 'c
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))     ==> consonant
\end{verbatim}

The \texttt{case} special form is expanded by \texttt{special-case}. It expands to \texttt{'()} if there are no clauses (left), and to nested \texttt{if} constructs if there are some.

\textbf{special-case} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-case (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special case

proc ::constcl::special-case {expr env} {
  set tail [cdr $expr]
  set expr [do-case [car $tail] [cdr $tail] $env]
  eval $expr $env
}
\end{lstlisting}

\begin{pulledtext}

\subsubsection{caar, cadr, cdar, and the rest}
\label{caar-cadr-cdar-and-the-rest}
\index{caar, cadr, cdar, and the rest}

The \texttt{do-case} procedure uses extensions of the \texttt{car}/\texttt{cdr} operators like \texttt{caar} and \texttt{cdar}\index{car/cdr operators}. \texttt{car}/\texttt{cdr} notation gets really powerful when combined to form operators from \texttt{caar} to \texttt{cddddr}. One can read \texttt{caar L} as `the first element of the first element of L', implying that the first element of \texttt{L} is a list. \texttt{cdar L} is `the rest of the elements of the first element of L', and \texttt{cadr L} is `the first element of the rest of the elements of L' or in layman's terms, the second element of L.
\end{pulledtext}

\begin{pulledtext}

\subsubsection{Quasiquote}
\label{quasiquote}
\index{Quasiquote}

In this and many other special form and macro form expanders I use a quasiquote\index{quasiquote} construct to lay out how the form is to be expanded. A quasiquote starts with a backquote (\texttt{`}) instead of the single quote that precedes regular quoted material. A quasiquote allows for `unquoting' of selected parts: this is notated with a comma (\texttt{,}). \texttt{`(foo ,bar baz)} is very nearly the same as \texttt{('foo bar 'baz)}. In both cases \texttt{foo} and \texttt{baz} are constants while \texttt{bar} is a variable which will be evaluated. Like in \texttt{do-case} here, a quasiquote serves well as a templating mechanism. The variables in the quasiquote need to be a part of the environment in which the quasiquote is expanded: I use \texttt{/define} to bind them in a temporary environment.
\end{pulledtext}

\textbf{do-case} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf do-case (internal)} \\
keyexpr & an expression \\
clauses & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-case procedure}

\begin{lstlisting}
proc ::constcl::do-case {keyexpr clauses env} {
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set keyl [caar $clauses]
    set body [cdar $clauses]
    set keyl [list [S memv] $keyexpr \
        [list [S quote] $keyl]]
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the condition
      if {[T [eq? [caar $clauses] [S else]]]} {
        set keyl #t
      }
    }
    set env [MkEnv $env]
    /define [S keyl] $keyl $env
    /define [S body] $body $env
    /define [S rest] [
      do-case $keyexpr [cdr $clauses] $env] $env
    set qq "`(if ,keyl
               (begin ,@body)
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{cond special form}
\label{cond-special-form}
\index{cond special form}

\texttt{cond} is the third conditional form. The \texttt{cond} form has a list of clauses, each with a predicate and a body. The clauses is considered in order, and if a predicate evaluates to something other than \texttt{\#f} the body is evaluated and the remaining clauses are ignored.

Syntax: (\textbf{cond} \emph{clause} \ldots )

Where each \emph{clause} has the form

(\emph{test} \emph{expression} \ldots )

or

(\emph{test} \textbf{=>} \emph{recipient})

where \emph{recipient} is a procedure that accepts one argument, which is evaluated with the result of the predicate as argument if the predicate returns a true value.

The last clause may have the form

(\textbf{else} \emph{expression} \ldots )

Example:

\begin{verbatim}
(let ((a 3))
  (cond ((> a 3) 'greater)
        ((< a 3) 'less)
        (else 'equal)))      ==> equal
\end{verbatim}

The \texttt{cond} special form is expanded by \texttt{special-cond}. It expands to \texttt{'()} if there are no clauses (left), and to nested \texttt{if} constructs if there are some.

\textbf{special-cond} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-cond (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special cond

proc ::constcl::special-cond {expr env} {
  set expr [do-cond [cdr $expr] $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{do-cond} procedure

\texttt{do-cond} is called recursively for every clause of the \texttt{cond} form. It chops up the clause into predicate and body. In the last clause, the predicate is allowed to be \texttt{else} (which gets translated to \texttt{\#t}). If there is no body, the body is set to the predicate. The form is expanded to a recursive \texttt{if} form.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf do-cond (internal)} \\
tail & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-cond procedure}

\begin{lstlisting}
proc ::constcl::do-cond {tail env} {
  set clauses $tail
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set pred [caar $clauses]
    set body [cdar $clauses]
    if {[T [symbol? [car $body]]] &&
        [[car $body] name] eq "=>"} {
      set body [list [caddar $clauses] $pred]
    } else {
      if {[[length $body] numval] == 1} {
        set body [car $body]
      } elseif {[[length $body] numval] > 1} {
        set body [cons [S begin] $body]
      }
    }
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the predicate
      if {[T [eq? $pred [S else]]]} {
        set pred #t
      }
    }
    if {[T [null? $body]]} {
        set body $pred
    }
    set env [MkEnv $env]
    /define [S pred] $pred $env
    /define [S body] $body $env
    /define [S rest] [
      do-cond [cdr $clauses] $env] $env
    set qq "`(if ,pred
               ,body
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\section{Sequence}
\label{sequence}
\index{sequence}

\emph{Example: \texttt{(begin (define r 10) (* r r))} $\Rightarrow$ 100}

There are times when one wants to treat a number of expressions as if they were one single expression (e.g. in the consequent or alternate of an \texttt{if} form). The \texttt{begin} special form bundles up expressions as an aggregate form. Internally, it sees to it that all the expressions are evaluated in order and that the resulting value of the last one is returned as the aggregate's result.

As part of the processing of sequences \emph{local defines} are resolved (see page \pageref{resolving-local-defines}), acting on expressions of the form \texttt{(begin (define \ldots } when in a local environment.

The following forms have an implicit \texttt{begin} in their bodies and the use of \texttt{begin} is therefore unnecessary with them:

\texttt{case}, \texttt{cond}, \texttt{define} (âprocedure defineâ only), \texttt{lambda}, \texttt{let}, \texttt{let*}, \texttt{letrec}.

\subsection{begin special form}
\label{begin-special-form}
\index{begin special form}

Syntax: (\textbf{begin} \emph{expression} \ldots )

The \texttt{begin} special form is expanded by \texttt{special-begin}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-begin (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special begin

proc ::constcl::special-begin {expr env} {
  if {$env ne "::constcl::global_env" &&
    [T [pair? [cadr $expr]]] &&
    [T [eq? [caadr $expr] [S define]]]
  } {
    set expr [resolve-local-defines $expr]
    eval $expr $env
  } else {
    /begin [cdr $expr] $env
  }
}
\end{lstlisting}

\textbf{/begin} procedure

The \texttt{/begin} helper procedure takes a Lisp list of expressions and evaluates them in sequence, returning the value of the last one.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf /begin (internal)} \\
exps & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}
\index{/begin}

\begin{lstlisting}
proc ::constcl::/begin {exps env} {
  /if {[pair? $exps]} {
    /if {[pair? [cdr $exps]]} {
      eval [car $exps] $env
      return [/begin [cdr $exps] $env]
    } {
      return [eval [car $exps] $env]
    }
  } {
    return #NIL
  }
}
\end{lstlisting}

\section{Definition}
\label{definition}
\index{definition}

\emph{Example: \texttt{(define r 10)} $\Rightarrow$ \ldots  (a definition doesn't evaluate to anything)}

We've already seen the relationship between symbols and values. Through (variable) definition\index{variable definition}\index{definition}, a symbol is bound to a value (or rather to the location the value is in), creating a variable. The \texttt{/define} helper procedure adds a variable to the current environment. It first checks that the symbol name is a valid identifier and that it isn't already bound. Then it updates the environment with the new binding.

The syntaxes with \texttt{lambda} in them refer to the eight syntactic form, procedure definition (see page \pageref{procedure-definition}).

\subsection{define special form}
\label{define-special-form}
\index{define special form}

Syntax: either

(\textbf{define} \emph{variable} \emph{expression})

(\textbf{define} (\emph{variable} \emph{formals}) \emph{body})

where \emph{formals} is a proper or dotted list of identifiers; equivalent form:

(\textbf{define} \emph{variable} (\textbf{lambda} (\emph{formals}) \emph{body})).

or

(\textbf{define} (\emph{variable} . \emph{formal}) \emph{body})

where \emph{formal} is a single identifier; equivalent form:

(\textbf{define} \emph{variable} (\textbf{lambda} \emph{formal} \emph{body}))

\emph{body} should be one or more expressions.

The \texttt{define} special form is expanded by \texttt{special-define}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-define (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg special define

proc ::constcl::special-define {expr env} {
  set expr [rewrite-define $expr $env]
  set sym [cadr $expr]
  set val [eval [caddr $expr] $env]
  /define $sym $val $env
}
\end{lstlisting}

\textbf{rewrite-define} procedure

\texttt{rewrite-define} rewrites ``procedural define'' syntaxes to their equivalent forms with \texttt{lambda}, which unifies the syntaxes with (\textbf{define} \emph{variable} \emph{expression}). That syntax passes through \texttt{rewrite-define} unchanged.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rewrite-define (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-define}

\begin{lstlisting}
proc ::constcl::rewrite-define {expr env} {
  if {[T [pair? [cadr $expr]]]} {
    set tail [cdr $expr]
    set env [::constcl::MkEnv $env]
    /define [S tail] $tail $env
    set qq "`(define ,(caar tail)
               (lambda ,(cdar tail) ,@(cdr tail)))"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
  }
  return $expr
}
\end{lstlisting}

\textbf{/define} procedure

The \texttt{/define} helper procedure carries out the binding of a symbol in a given environment, and stores the value in the location of binding.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf /define (internal)} \\
sym & a symbol \\
val & a value \\
env & an environment \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}
\index{/define}

\begin{lstlisting}
proc ::constcl::/define {sym val env} {
  varcheck [idcheck [$sym name]]
  # will throw an error if $sym is bound
  $env bind $sym VARIABLE $val
  return
}
\end{lstlisting}

\section{Assignment}
\label{assignment}
\index{assignment}

\emph{Example: \texttt{(set! r 20)} $\Rightarrow$ 20 (\texttt{r} is a bound symbol, so it's allowed to assign to it)}

Once again we consider the relationship of a symbol, an environment, and a value. Once a symbol is bound to a location in the environment, the value at that location can be changed with reference to the symbol, altering the value of the variable. The process is called assignment.

It is carried out by the \texttt{set!} special form. Given a symbol and a value, it finds the symbol's binding environment and updates the location with the value. It returns the value, so calls to \texttt{set!} can be chained: \texttt{(set! foo (set! bar 99))} sets both variables to 99. By Scheme convention, procedures that modify variables have `!' at the end of their name.

It is an error to do assignment on an unbound symbol.

\subsection{set! special form}
\label{set-special-form}
\index{set"! special form}

Syntax: (\textbf{set!} \emph{variable} \emph{expression})

The \texttt{set!} special form is expanded by \texttt{special-set!}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-set! (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg special set!

proc ::constcl::special-set! {expr env} {
  set args [cdr $expr]
  set var [car $args]
  set val [eval [cadr $args] $env]
  [$env find $var] assign $var VARIABLE $val
  set val
}
\end{lstlisting}

\section{Procedure definition}
\label{procedure-definition}
\index{procedure definition}

\emph{Example: \texttt{(lambda (r) (* r r))} $\Rightarrow$ \texttt{::oo::Obj3601} (it will be a different object each time)}

In Lisp, procedures are values just like numbers or characters. They can be defined\index{procedure definition} as the value of a symbol, passed to other procedures, and returned from procedures. One difference from most values is that procedures need to be specified. Two questions must answered: what is the procedure meant to do? The code that does that will form the \emph{body} of the procedure. Also, which, if any, items of data (\emph{parameters}) will have to be provided to the procedure to make it possible to calculate its result?

As an example, imagine that we want to have a procedure that calculates the square (\texttt{x * x}) of a given number. In Lisp, expressions are written with the operator first and then the operands\index{operator operand order}: \texttt{(* x x)}. That is the body of the procedure. Now, what data will we have to provide to the procedure to make it work? A value stored in the variable \texttt{x} will do. It's only a single variable, but by custom we need to put it in a list: \texttt{(x)}. The operator that creates procedures is called \texttt{lambda}\index{lambda}, and we create the function with \texttt{(lambda (x) (* x x))}.

One more step is needed before we can use the procedure. It must have a name. We could define it like this: \texttt{(define square (lambda (x) (* x x)))} but there is actually a shortcut notation for it: \texttt{(define (square x) (* x x))}.

Now, \texttt{square} is pretty tame. How about the \texttt{hypotenuse} procedure? \texttt{(define (hypotenuse a b) (sqrt (+ (square a) (square b))))}. It calculates the square root of the sum of two squares.

The \texttt{lambda} special form makes a Procedure (see page \pageref{control}) object. First it needs to convert the Lisp list \texttt{body}. It is bundled inside a \texttt{begin} if it has more than one expression (\texttt{S begin} stands for `the symbol begin'.), and taken out of its list if not. The Lisp list \texttt{formals} is passed on as it is.

\begin{pulledtext}

\subsubsection{Scheme formal parameters lists}
\label{scheme-formal-parameters-lists}
\index{Scheme formal parameters lists}

A Scheme formals list\index{formals list} is either:

\begin{itemize}
\item An \emph{empty list}, \texttt{()}, meaning that no arguments are accepted,
\item A \emph{proper list}, \texttt{(a b c)}, meaning it accepts three arguments, one in each symbol,
\item A \emph{symbol}, \texttt{a}, meaning that all arguments go into \texttt{a}, or
\item A \emph{dotted list}, \texttt{(a b . c)}, meaning that two arguments go into \texttt{a} and \texttt{b}, and the rest into \texttt{c}.
\end{itemize}
\end{pulledtext}

\subsection{lambda special form}
\label{lambda-special-form}
\index{lambda special form}

Syntax: (\textbf{lambda} \emph{formals} \emph{body})

where \emph{body} is one or more expressions.

The \texttt{lambda} special form is expanded by \texttt{special-lambda}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-lambda (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a procedure \\
\hline
\end{tabular}

\begin{lstlisting}
reg special lambda

proc ::constcl::special-lambda {expr env} {
  set args [cdr $expr]
  set formals [car $args]
  set body [cdr $args]
  if {[[length $body] numval] > 1} {
    set body [cons [S begin] $body]
  } elseif {[[length $body] numval] == 1} {
    set body [car $body]
  } else {
    set body #NIL
  }
  return [MkProcedure $formals $body $env]
}
\end{lstlisting}

\section{Procedure call}
\label{procedure-call}
\index{procedure call}

\emph{Example: \texttt{(+ 1 6)} $\Rightarrow$ 7}

Once we have procedures, we can \emph{call} them to have their calculations performed and yield results. The procedure name is put in the operator position at the front of a list, and the operands follow in the rest of the list. Our \texttt{square} procedure would be called for instance like this: \texttt{(square 11)}, and it would return 121.

\texttt{invoke} arranges for a procedure to be called with each of the values in the \emph{argument list} (the list of operands). It checks if \emph{pr} really is a procedure, and determines whether to call \emph{pr} as an object or as a Tcl command. Before \texttt{invoke} is called, the argument list should be evaluated with \texttt{eval-list} (see below).

\subsection{invoke procedure}
\label{invoke-procedure}
\index{invoke procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf invoke (internal)} \\
pr & a procedure \\
vals & a Lisp list of values \\
\textit{Returns:} & what pr returns \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::invoke {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([$pr show] val ...)
  }
  if {[info object isa object $pr]} {
    $pr call {*}[splitlist $vals]
  } else {
    $pr {*}[splitlist $vals]
  }
}
\end{lstlisting}

\section{Binding forms}
\label{binding-forms}
\index{Binding forms}

The binding forms are not fundamental the way the earlier nine forms are. They are an application of a combination of forms eight and nine, the procedure definition form and the procedure call. But their use is sufficiently distinguished to earn them their own heading.

\subsection{let special form}
\label{let-special-form}
\index{let special form}

Syntax: (\textbf{let} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

or

(\textbf{let} \emph{variable} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{let} special form (both forms) is expanded by \texttt{special-let}. They are ultimately rewritten to calls to \texttt{lambda} constructs and evaluated as such.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-let (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special let

proc ::constcl::special-let {expr env} {
  if {[T [symbol? [cadr $expr]]]} {
    set expr [rewrite-named-let $expr $env]
  }
  set expr [rewrite-let $expr $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-named-let} procedure

The rewriter for named \texttt{let} chops up the expression into \emph{variable}, \emph{bindings}, and \emph{body}. It creates a dictionary with the \emph{variable} as key and \texttt{\#f} as value. Then it fills up the dictionary with variable/value pairs from the \emph{bindings}. It uses the dictionary to build a declaration list for a \texttt{let} form, a variable list for a \texttt{lambda} form, and a procedure call. Then it assembles a \texttt{let} form with the declaration list and a body consisting of an assignment and the procedure call. The assignment binds the variable to a \texttt{lambda} form with the varlist and the original \emph{body}. The \texttt{let} form is returned, meaning that the primary expansion of the named \texttt{let} is a regular \texttt{let} form.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rewrite-named-let (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-named-let procedure}

\begin{lstlisting}
proc ::constcl::rewrite-named-let {expr env} {
  # named let
  set tail [cdr $expr]
  set variable [car $tail]
  set bindings [cadr $tail]
  set body [cddr $tail]
  set vars [dict create $variable #f]
  parse-bindings vars $bindings
  set env [MkEnv $env]
  /define [S decl] [list {*}[dict values [
    dict map {k v} $vars {list $k $v}]]] $env
  /define [S variable] $variable $env
  /define [S varlist] [list {*}[lrange [
    dict keys $vars] 1 end]] $env
  /define [S body] $body $env
  /define [S call] [list {*}[
    dict keys $vars]] $env
  set qq "`(let ,decl
             (set!
               ,variable
                 (lambda ,varlist ,@body)) ,call)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\textbf{rewrite-let} procedure

The rewriter for regular \texttt{let} chops up the original expression into \emph{bindings} and \emph{body}. It creates an empty dictionary and fills it up with variable/value pairs from the \emph{bindings}. Then it builds a \texttt{lambda} operator form with the variable list, the \emph{body}, and the value list. The \texttt{lambda} call is returned as the expansion of the regular \texttt{let} form.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rewrite-let (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-let procedure}

\begin{lstlisting}
proc ::constcl::rewrite-let {expr env} {
  # regular let
  set tail [cdr $expr]
  set bindings [car $tail]
  set body [cdr $tail]
  set vars [dict create]
  parse-bindings vars $bindings
  set env [MkEnv $env]
  /define [S varlist] [list {*}[
    dict keys $vars]] $env
  /define [S body] $body $env
  /define [S vallist] [list {*}[
    dict values $vars]] $env
  set qq "`((lambda ,varlist ,@body)
             ,@vallist)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\textbf{parse-bindings} procedure

\texttt{parse-bindings} is a helper procedure that traverses a \texttt{let} bindings list and extracts variables and values, which it puts in a dictionary. It throws an error if a variable occurs more than once.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf parse-bindings (internal)} \\
name & a call-by-name name \\
bindings & a Lisp list of values \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}
\index{parse-bindings procedure}

\begin{lstlisting}
proc ::constcl::parse-bindings {name bindings} {
  upvar $name vars
  foreach binding [splitlist $bindings] {
    set var [car $binding]
    set val [cadr $binding]
    if {$var in [dict keys $vars]} {
        ::error "'[$var name]' occurs more than once"
    }
    dict set vars $var $val
  }
  return
}
\end{lstlisting}

\subsection{letrec special form}
\label{letrec-special-form}
\index{letrec special form}

The \texttt{letrec} form is similar to \texttt{let}, but the bindings are created before the values for them are calculated. This means that one can define mutually recursive procedures.

Syntax: (\textbf{letrec} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{letrec} special form is expanded by \texttt{special-letrec}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-letrec (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special letrec

proc ::constcl::special-letrec {expr env} {
  set expr [rewrite-letrec $expr $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-letrec} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rewrite-letrec (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-letrec procedure}

\begin{lstlisting}
proc ::constcl::rewrite-letrec {expr env} {
  # regular let
  set tail [cdr $expr]
  set bindings [car $tail]
  set body [cdr $tail]
  set vars [dict create]
  parse-bindings vars $bindings
  foreach {key val} $vars {
    dict set outer $key [list [S quote] #UND]
    dict set inner [set g [gensym "g"]] $val
    dict set assigns $key $g
  }
  set env [MkEnv $env]
  /define [S outervars] [
    list {*}[dict keys $outer]] $env
  /define [S outervals] [
    list {*}[dict values $outer]] $env
  /define [S innervars] [
    list {*}[dict keys $inner]] $env
  /define [S innervals] [
    list {*}[dict values $inner]] $env
  /define [S assigns] [list {*}[lmap {k v} $assigns {
      list [S set!] $k $v
    }]] $env
  /define [S body] $body $env
  set qq "`((lambda ,outervars
             ((lambda ,innervars ,@assigns) ,@innervals)
             ,@body) ,@outervals)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{let* special form}
\label{let-special-form1}
\index{let* special form}

The \texttt{let*} form is similar to \texttt{let}, but the items in the binding list are considered sequentially, so the initializer in the second or later binding can reference the first binding, etc.

Syntax: (\textbf{let*} ((\emph{variable} \emph{init}) \ldots ) \emph{body})

where \emph{body} is one or more expressions.

The \texttt{let*} special form is expanded by \texttt{special-let*}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf special-let* (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg special let*

proc ::constcl::special-let* {expr env} {
  set tail [cdr $expr]
  set expr [rewrite-let* [car $tail] [cdr $tail] $env]
  eval $expr $env
}
\end{lstlisting}

\textbf{rewrite-let*} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf rewrite-let* (internal)} \\
bindings & a Lisp list of values \\
body & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{rewrite-let* procedure}

\begin{lstlisting}
proc ::constcl::rewrite-let* {bindings body env} {
  set env [MkEnv $env]
  if {$bindings eq "#NIL"} {
    /define [S body] $body $env
    set qq "`(begin ,@body)"
    set expr [expand-quasiquote [parse $qq] $env]
  } else {
    /define [S var] [caar $bindings] $env
    /define [S val] [cadar $bindings] $env
    /define [S rest] [rewrite-let* [cdr $bindings] \
      $body $env] $env
    set qq "`((lambda (,var)
               ,rest) ,val)"
    set expr [expand-quasiquote [parse $qq] $env]
  }
  $env destroy
  return $expr
}
\end{lstlisting}

\section{Environments}
\label{environments}
\index{environments}

Before I can talk about the evaluator, I need to spend some time on environments. To simplify, an environment can be seen as a table--or spreadsheet, if you will--that connects (binds) names to cells, which contain values. The evaluator looks up values in the environment that way. But there's more to an environment than just a name-value coupling. The environment also contains references to the very procedures that make up the Lisp library. And their bindings aren't just a simple connection: there are several kinds of bindings, from variable binding, the most common one, to special-form bindings for the fundamental operations of the interpreter, and syntax bindings for the macros that get expanded to `normal' code.

There isn't just one environment, either. Every time a non-primitive procedure is called, a new environment is created which has bindings for the procedure arguments and which links to the environment that was current when the procedure was defined (which in turn links backwards all the way to the original global environment). The evaluator follows into the new environment to evaluate the body of the procedure there, and then as the evaluator goes back along its call stack, it sheds environment references.

Not only procedures but binding forms (such as \texttt{let}) create new environments for the evaluator to work in. As they do that, they also bind variables to values. Just like with procedures, the added local bindings can shadow bindings in underlying environments but does not affect them: once the local environment has been forgotten by the evaluator, the underlying bindings are once more visible. The other side of the coin is that temporary environments don't have to be complete: every binding that the evaluator can't find in a temporary environment it looks for in the parent environment, or its parent and so on.

Environments make up the world the evaluator lives in and are the source of its values and procedures. The ability of procedure calls and execution of binding forms to temporarily change the current environment is a powerful one. But still the evaluator eventually backtracks into the previous environments.

The other side of the coin is that the evaluator uses the environment to keep track of changes in the state of the evaluation. In this way, the evaluator uses the environment for continuity and a progress record.

\begin{figure}[h!]\includegraphics{images/environments.png}\captionsetup{labelformat=empty}\caption{Two sample environments}\label{fig:two-sample-environments}\end{figure}

I will talk some more about the implementation of environments in a later section.

\section{The evaluator}
\label{the-evaluator}
\index{the evaluator}

Now that all nine syntactic forms are in place and we have a basic understanding of the environment, we can start assembling the evaluator.

\subsection{eval procedure}
\label{eval-procedure}
\index{eval procedure}

The heart of the Lisp interpreter, \texttt{eval} takes a Lisp expression and processes it according to its form. Variable reference and constant literals are handled here, but the other seven syntactic forms are delegated to \texttt{eval-form}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf eval (public)} \\
expr & an expression \\
?env? & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg eval

proc ::constcl::eval \
  {expr {env ::constcl::global_env}} {
  if {[T [symbol? $expr]]} {
    lookup $expr $env
  } elseif {[T [self-evaluating? $expr]]} {
    set expr
  } elseif {[T [pair? $expr]]} {
    eval-form $expr $env
  } else {
    error "unknown expression type [$expr show]"
  }
}
\end{lstlisting}

\subsection{eval-form procedure}
\label{evalform-procedure}
\index{eval-form procedure}

If the \texttt{car} of the expression (the operator) is a symbol, \texttt{eval-form} looks at the \emph{binding information} (which the \texttt{reg} procedure (see page \pageref{reg-procedure}) puts into the standard library and thereby the global environment) for the symbol. The \emph{binding type} tells in general how the expression should be treated: as a special form, a variable, or a macro (see page \pageref{macros}). The \emph{handling info} gives the exact procedure that will take care of the expression. If the operator isn't a symbol, it is evaluated and applied to the evaluated rest of the expression.

The seven remaining syntactic forms are implemented as special forms and handled when the relevant symbol appears in the \texttt{car} of the expression. Their \emph{binding type} is \texttt{SPECIAL} and the \emph{handling info} consists of the name of the procedure expanding the special form. The procedure is called with the expression and the environment as arguments.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf eval-form (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::eval-form {expr env} {
  set op [car $expr]
  set args [cdr $expr]
  if {[T [symbol? $op]]} {
    lassign [binding-info $op $env] btype hinfo
    switch $btype {
      UNBOUND {
        error "unbound symbol" $op
      }
      SPECIAL {
        $hinfo $expr $env
      }
      VARIABLE {
        invoke $hinfo [eval-list $args $env]
      }
      SYNTAX {
        eval [$hinfo $expr $env] $env
      }
      default {
        error "unrecognized binding type" $btype
      }
    }
  } else {
    invoke [eval $op $env] [eval-list $args $env]
  }
}
\end{lstlisting}

\textbf{binding-info} procedure

The \texttt{binding-info} procedure takes a symbol and returns a list of two items: 1) the binding type of the symbol, and 2) the handling info that \texttt{eval-form} uses to handle this symbol.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf binding-info (internal)} \\
op & a symbol \\
env & an environment \\
\textit{Returns:} & binding info \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::binding-info {op env} {
  set actual_env [$env find $op]
  # parentless envs have #NIL
  if {$actual_env eq "::constcl::null_env"} {
    return [::list UNBOUND {}]
  } else {
    return [$actual_env get $op]
  }
}
\end{lstlisting}

\textbf{splitlist} procedure

\texttt{splitlist} converts a Lisp list to a Tcl list with Lisp objects.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf splitlist (internal)} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}
\index{splitlist}

\begin{lstlisting}
proc ::constcl::splitlist {vals} {
  set result {}
  while {[T [pair? $vals]]} {
    lappend result [car $vals]
    set vals [cdr $vals]
  }
  return $result
}
\end{lstlisting}

\textbf{eval-list} procedure

\texttt{eval-list} successively evaluates the elements of a Lisp list and returns the collected results as a Lisp list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf eval-list (internal)} \\
exps & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}
\index{eval-list}

\begin{lstlisting}
proc ::constcl::eval-list {exps env} {
  if {[T [pair? $exps]]} {
    return [cons [eval [car $exps] $env] \
      [eval-list [cdr $exps] $env]]
  } else {
    return #NIL
  }
}
\end{lstlisting}

\section{Macros}
\label{macros}
\index{Macros}

Macros that allow concise, abstract expressions that are automatically rewritten into other, more concrete but also more verbose expressions is one of Lisp's strong points. This interpreter does macro expansion, but the user can't define new macros--the ones available are hardcoded in the code below.

A macro expander procedure takes an expression and an environment as a parameter. In the end, the expanded expression is passed back to \texttt{eval}.

\subsection{expand-and procedure}
\label{expandand-procedure}
\index{expand-and procedure}

\texttt{expand-and} expands the \texttt{and} macro. It returns a \texttt{begin}-expression if the macro has 0 or 1 elements, and a nested \texttt{if} construct otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-and (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro and

proc ::constcl::expand-and {expr env} {
  set tail [cdr $expr]
  if {[[length $tail] numval] == 0} {
    list [S begin] #t
  } elseif {[[length $tail] numval] == 1} {
    cons [S begin] $tail
  } else {
    do-and $tail #t $env
  }
}
\end{lstlisting}

\textbf{do-and} procedure

\texttt{do-and} is called recursively for every argument of \texttt{expand-or} if there are more than one.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf do-and (internal)} \\
tail & an expression tail \\
prev & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-and}

\begin{lstlisting}
proc ::constcl::do-and {tail prev env} {
  if {[T [null? $tail]]} {
    return $prev
  } else {
    set env [MkEnv $env]
    /define [S first] [car $tail] $env
    /define [S rest] [do-and [cdr $tail] \
        [car $tail] $env] $env
    set qq "`(if ,first ,rest #f)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{expand-del! procedure}
\label{expanddel-procedure}
\index{expand-del"! procedure}

The macro \texttt{del!} updates a property list. It removes a key-value pair if the key is present, or leaves the list untouched if it isn't.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-del! (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro del!

proc ::constcl::expand-del! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
    ::error "too few arguments, 0 of 2"
  }
  /define [S listname] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
    ::error "too few arguments, 1 of 2"
  }
  /define [S key] [cadr $tail] $env
  set qq "`(set! ,listname
             (delete! ,listname ,key))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-for procedure}
\label{expandfor-procedure}
\index{expand-for procedure}

The \texttt{expand-for} procedure expands the \texttt{for} macro. It returns a \texttt{begin} construct containing the iterations of each clause (multiple clauses weren't implemented for the longest time, but I brought up my strongest brain cells and they did it).

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-for (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for

proc ::constcl::expand-for {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  lappend res [parse "'()"]
  return [list [S begin] {*}$res]
}
\end{lstlisting}

\textbf{for-seq} procedure

\texttt{for-seq} is a helper procedure that sets up the sequence of values that the iteration is based on. First it evaluates the code that generates the sequence, and then it converts it to a Tcl list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf for-seq (internal)} \\
seq & an expression \\
env & an environment \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}
\index{for-seq}

\begin{lstlisting}
proc ::constcl::for-seq {seq env} {
  if {[T [number? $seq]]} {
    set seq [in-range $seq]
  } else {
    set seq [eval $seq $env]
  }
  # make it a Tcl list, one way or another
  if {[T [list? $seq]]} {
    set seq [splitlist $seq]
  } elseif {[T [string? $seq]]} {
    set seq [lmap c [split [$seq value] {}] {
      switch $c {
        " "  { MkChar #\\space }
        "\n" { MkChar #\\newline }
        default {
          MkChar #\\$c
        }
      }
    }]
  } elseif {[T [vector? $seq]]} {
    set seq [$seq value]
  }
}
\end{lstlisting}

\textbf{do-for} procedure

\texttt{do-for} is another helper procedure which does most of the work in the \texttt{for/*} forms. It iterates over the clauses, extracting and preparing the sequence for each, and stores each of the sequence steps in a dictionary under a double key: the identifier and the ordinal of the step.

Then it creates a \texttt{let} construct for each step, in which each of the clauses' identifiers is bound to the step's value. The Tcl list of \texttt{let} constructs is returned.

Each clause's sequence is supposed to be the same length as the others. One weakness of this implementation is that it doesn't ensure this, just hopes that the user does the right thing.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf do-for (internal)} \\
tail & an expression tail \\
env & an environment \\
\textit{Returns:} & a Tcl list of expressions \\
\hline
\end{tabular}
\index{do-for}

\begin{lstlisting}
proc ::constcl::do-for {tail env} {
  # make clauses a Tcl list
  set clauses [splitlist [car $tail]]
  set body [cdr $tail]
  set data [dict create]
  set length 0
  foreach clause $clauses {
    set id [car $clause]
    set sequence [for-seq [cadr $clause] $env]
    set length [llength $sequence]
    # save every id and step of the iteration
    for {set i 0} {$i < $length} {incr i} {
        dict set data $id $i [lindex $sequence $i]
    }
  }
  set res {}
  # for every step of the iteration...
  for {set i 0} {$i < $length} {incr i} {
    set decl {}
    # retrieve the ids
    foreach id [dict keys $data] {
      # list the id and the step
      lappend decl [
        list $id [dict get $data $id $i]]
    }
    # add to the structure of let constructs
    lappend res [list [S let] [
        list {*}$decl] {*}[splitlist $body]]
  }
  return $res
}
\end{lstlisting}

\subsection{expand-for/and procedure}
\label{expandforand-procedure}
\index{expand-for/and procedure}

The \texttt{expand-for/and} procedure expands the \texttt{for/and} macro. It returns an \texttt{and} construct containing the iterations of the clauses.

The only differences from \texttt{expand-for} is that it doesn't add \texttt{(quote ())} and that it wraps the list of iterations in \texttt{and} instead of \texttt{begin}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-for/and (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/and

proc ::constcl::expand-for/and {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S and] {*}$res]
}
\end{lstlisting}

\subsection{expand-for/list procedure}
\label{expandforlist-procedure}
\index{expand-for/list procedure}

The \texttt{expand-for/list} procedure expands the \texttt{for/list} macro. It returns a \texttt{list} construct containing the iterations of each clause.

The only difference from \texttt{expand-for/and} is that it wraps the list of iterations in \texttt{list} instead of \texttt{and}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand for/list (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/list

proc ::constcl::expand-for/list {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S list] {*}$res]
}
\end{lstlisting}

\subsection{expand-for/or procedure}
\label{expandforor-procedure}
\index{expand-for/or procedure}

The \texttt{expand-for/or} procedure expands the \texttt{for/or} macro. It returns an \texttt{or} construct containing the iterations of each clause.

The only difference from \texttt{expand-for/list} is that it wraps the list of iterations in \texttt{or} instead of \texttt{list}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-for/or (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro for/or

proc ::constcl::expand-for/or {expr env} {
  set tail [cdr $expr]
  set res [do-for $tail $env]
  return [list [S or] {*}$res]
}
\end{lstlisting}

\subsection{expand-or procedure}
\label{expandor-procedure}
\index{expand-or procedure}

\texttt{expand-or} expands the \texttt{or} macro. It returns a \texttt{begin}-expression if the macro has 0 or 1 elements, and a nested \texttt{if} construct otherwise.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-or (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro or

proc ::constcl::expand-or {expr env} {
  set tail [cdr $expr]
  if {[T [eq? [length $tail] #0]]} {
    return [list [S begin] #f]
  } elseif {[T [eq? [length $tail] #1]]} {
    return [cons [S begin] $tail]
  } else {
    return [do-or $tail $env]
  }
}
\end{lstlisting}

\textbf{do-or} procedure

\texttt{do-or} is called recursively for each argument to \texttt{expand-or} if there are more than one argument.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf do-or (internal)} \\
tail & an expression tail \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}
\index{do-or}

\begin{lstlisting}
proc ::constcl::do-or {tail env} {
  /if {[null? $tail]} {
    return #f
  } {
    set env [MkEnv $env]
    /define [S first] [car $tail] $env
    /define [S rest] [do-or [cdr $tail] $env] $env
    set qq "`(let ((x ,first)) (if x x ,rest))"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
\end{lstlisting}

\subsection{expand-pop! procedure}
\label{expandpop-procedure}
\index{expand-pop"! procedure}

The macro \texttt{pop!} updates a list. It removes the first element.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-pop! (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro pop!

proc ::constcl::expand-pop! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
      ::error "too few arguments:\n(pop! listname)"
  }
  if {[symbol? [car $tail]] eq "#f"} {
      ::error "SYMBOL expected:\n(pop! listname)"
  }
  /define [S listname] [car $tail] $env
  set qq "`(set! ,listname (cdr ,listname))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-push! procedure}
\label{expandpush-procedure}
\index{expand-push"! procedure}

The macro \texttt{push!} updates a list. It adds a new element as the new first element.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-push! (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro push!

proc ::constcl::expand-push! {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  if {[T [null? $tail]]} {
    ::error \
      "too few arguments:\n(push! obj listname)"
  }
  /define [S obj] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
    ::error \
      "too few arguments:\n(push! obj listname)"
  }
  if {[symbol? [cadr $tail]] eq "#f"} {
    ::error \
      "SYMBOL expected:\n(push! obj listname)"
  }
  /define [S listname] [cadr $tail] $env
  set qq "`(set!
             ,listname
             (cons ,obj ,listname))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-put! procedure}
\label{expandput-procedure}
\index{expand-put"! procedure}

The macro \texttt{put!} updates a property list. It adds a key-value pair if the key isn't present, or changes the value in place if it is.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-put! (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro put!

proc ::constcl::expand-put! {expr env} {
  set tail [cdr $expr]
  set env [::constcl::MkEnv $env]
  if {[T [null? $tail]]} {
      ::error "too few arguments, 0 of 3"
  }
  /define [S name] [car $tail] $env
  if {[T [null? [cdr $tail]]]} {
      ::error "too few arguments, 1 of 3"
  }
  /define [S key] [cadr $tail] $env
  if {[T [null? [cddr $tail]]]} {
      ::error "too few arguments, 2 of 3"
  }
  /define [S val] [caddr $tail] $env
  set qq "`(let ((idx (list-find-key ,name ,key)))
             (if (< idx 0)
               (set!
                 ,name
                 (append (list ,key ,val) ,name))
               (begin
                 (list-set! ,name (+ idx 1) ,val)
                 ,name)))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-quasiquote procedure}
\label{expandquasiquote-procedure}
\index{expand-quasiquote procedure}

A quasi-quote isn't a macro, but we will deal with it in this section anyway. \texttt{expand-quasiquote} traverses the quasi-quoted structure searching for \texttt{unquote} and \texttt{unquote-splicing}. This code is brittle and sprawling and I barely understand it myself.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-quasiquote (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro quasiquote

proc ::constcl::expand-quasiquote {expr env} {
  set tail [cdr $expr]
  set qqlevel 0
  if {[T [list? [car $tail]]]} {
    set node [car $tail]
    return [qq-visit-child $node 0 $env]
  } elseif {[T [vector? [car $tail]]]} {
    set vect [car $tail]
    set res {}
    for {set i 0} {$i < [
        [vector-length $vect] numval]} {incr i} {
      set idx [MkNumber $i]
      set vecref [vector-ref $vect $idx]
      if {[T [pair? $vecref]] &&
          [T [eq? [car $vecref] [
            S unquote]]]} {
        if {$qqlevel == 0} {
          lappend res [eval [cadr $vecref] $env]
        }
      } elseif {[T [pair? $vecref]] &&
          [T [eq? [car $vecref] [
            S unquote-splicing]]]} {
        if {$qqlevel == 0} {
          lappend res {*}[splitlist [
            eval [cadr $vecref] $env]]
        }
      } elseif {[T [atom? $vecref]]} {
        lappend res $vecref
      } else {
      }
    }
    return [list [S "vector"] {*}$res]
  }
}
\end{lstlisting}

\textbf{qq-visit-child} procedure

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf qq-visit-child (internal)} \\
node & a Lisp list of expressions \\
qqlevel & a Tcl number \\
env & an environment \\
\textit{Returns:} & a Tcl list of expressions \\
\hline
\end{tabular}
\index{qq-visit-child}

\begin{lstlisting}
proc ::constcl::qq-visit-child {node qqlevel env} {
  if {$qqlevel < 0} {
    set qqlevel 0
  }
  if {[T [list? $node]]} {
    set res {}
    foreach child [splitlist $node] {
      if {[T [pair? $child]] &&
          [T [eq? [car $child] [S unquote]]]} {
        if {$qqlevel == 0} {
          lappend res [eval [cadr $child] $env]
        } else {
          lappend res [list [S unquote] [
            qq-visit-child [cadr $child] [
            expr {$qqlevel - 1}] $env]]
        }
      } elseif {[T [pair? $child]] &&
          [T [eq? [car $child] [
          S unquote-splicing]]]} {
        if {$qqlevel == 0} {
          lappend res {*}[splitlist [
            eval [cadr $child] $env]]
        }
      } elseif {[T [pair? $child]] &&
          [T [eq? [car $child] [S quasiquote]]]} {
        lappend res [list [S quasiquote] [car [
          qq-visit-child [cdr $child] [
            expr {$qqlevel + 1}] $env]]]
      } elseif {[T [atom? $child]]} {
        lappend res $child
      } else {
        lappend res [
          qq-visit-child $child $qqlevel $env]
      }
    }
  }
  return [list {*}$res]
}
\end{lstlisting}

\subsection{expand-unless procedure}
\label{expandunless-procedure}
\index{expand-unless procedure}

\texttt{unless} is a conditional like \texttt{if}, but it takes a number of expressions. It executes them on a false outcome of \texttt{car \$tail}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-unless (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro unless

proc ::constcl::expand-unless {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  /define [S tail] $tail $env
  set qq "`(if ,(car tail)
             '()
             (begin ,@(cdr tail)))"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\subsection{expand-when procedure}
\label{expandwhen-procedure}
\index{expand-when procedure}

\texttt{when} is a conditional like \texttt{if}, but it takes a number of expressions. It executes them on a true outcome of \texttt{car \$tail}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expand-when (internal)} \\
expr & an expression \\
env & an environment \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
reg macro when

proc ::constcl::expand-when {expr env} {
  set tail [cdr $expr]
  set env [MkEnv $env]
  /define [S tail] $tail $env
  set qq "`(if ,(car tail)
             (begin ,@(cdr tail))
             '())"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
\end{lstlisting}

\section{Resolving local defines}
\label{resolving-local-defines}
\index{Resolving local defines}

This section is ported from 'Scheme 9 from Empty Space'\index{S9fES}. \texttt{resolve-local-defines} is the topmost procedure in rewriting local defines as essentially a \texttt{letrec} form. It takes a list of expressions and extracts variables and values from the defines in the beginning of the list. It builds a double lambda expression with the variables and values, and the rest of the expressions from the original list as body.

\subsection{resolve-local-defines procedure}
\label{resolvelocaldefines-procedure}
\index{resolve-local-defines procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf resolve-local-defines} \\
expr & an expression \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::resolve-local-defines {expr} {
  set exps [cdr $expr]
  set rest [lassign [
    extract-from-defines $exps VALS] a error]
  if {[T $error]} {
    return #NIL
  }
  set rest [lassign [
    extract-from-defines $exps VARS] v error]
  if {[T $error]} {
    return #NIL
  }
  if {$rest eq "#NIL"} {
    set rest [cons #UNS #NIL]
  }
  return [make-lambdas $v $a $rest]
}
\end{lstlisting}

\subsection{extract-from-defines procedure}
\label{extractfromdefines-procedure}
\index{extract-from-defines procedure}

\texttt{extract-from-defines} visits every define in the given list of expressions and extracts either a variable name or a value, depending on the state of the \emph{part} flag, from each one of them. A Tcl list of 1) the resulting list of names or values, 2) error state, and 3) the rest of the expressions in the original list is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf extract-from-defines (internal)} \\
exps & a Lisp list of expressions \\
part & a flag, VARS or VALS \\
\textit{Returns:} & a Tcl list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::extract-from-defines {exps part} {
  set a #NIL
  while {$exps ne "#NIL"} {
    if {[T [atom? $exps]] ||
        [T [atom? [car $exps]]] ||
        ![T [eq? [caar $exps] [S define]]]} {
      break
    }
    set n [car $exps]
    set k [length $n]
    if {![T [list? $n]] ||
        [$k numval] < 3 ||
        ![T [argument-list? [cadr $n]]] ||
        ([T [symbol? [cadr $n]]] &&
        [$k numval] > 3)} {
        return [::list #NIL "#t" #NIL]
      }
      if {[T [pair? [cadr $n]]]} {
        if {$part eq "VARS"} {
          set a [cons [caadr $n] $a]
        } else {
          set a [cons #NIL $a]
          set new [cons [cdadr $n] [cddr $n]]
          set new [cons [S lambda] $new]
          set-car! $a $new
        }
      } else {
        if {$part eq "VARS"} {
          set a [cons [cadr $n] $a]
        } else {
          set a [cons [caddr $n] $a]
        }
      }
      set exps [cdr $exps]
    }
    return [::list $a #f $exps]
}
\end{lstlisting}

\subsection{argument-list? procedure}
\label{argumentlist-procedure}
\index{argument-list? procedure}

\texttt{argument-list?} accepts a Scheme formals list and rejects other values.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf argument-list? (internal)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::argument-list? {val} {
  if {$val eq "#NIL"} {
    return #t
  } elseif {[T [symbol? $val]]} {
    return #t
  } elseif {[T [atom? $val]]} {
    return #f
  }
  while {[T [pair? $val]]} {
    if {[symbol? [car $val]] eq "#f"} {
      return #f
    }
    set val [cdr $val]
  }
  if {$val eq "#NIL"} {
    return #t
  } elseif {[T [symbol? $val]]} {
    return #t
  }
}
\end{lstlisting}

\subsection{make-lambdas procedure}
\label{makelambdas-procedure}
\index{make-lambdas procedure}

\texttt{make-lambdas} builds the \texttt{letrec} structure.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-lambdas (internal)} \\
vars & a Lisp list of symbols \\
args & a Lisp list of expressions \\
body & a Lisp list of expressions \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-lambdas {vars args body} {
  set tmps [make-temporaries $vars]
  set body [append-b [
    make-assignments $vars $tmps] $body]
  set body [cons $body #NIL]
  set n [cons $tmps $body]
  set n [cons [S lambda] $n]
  set n [cons $n $args]
  set n [cons $n #NIL]
  set n [cons $vars $n]
  set n [cons [S lambda] $n]
  set n [cons $n [make-undefineds $vars]]
  return $n
}
\end{lstlisting}

\subsection{make-temporaries procedure}
\label{maketemporaries-procedure}
\index{make-temporaries procedure}

\texttt{make-temporaries} creates the symbols that will act as middlemen in transferring the values to the variables.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-temporaries (internal)} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-temporaries {vals} {
  set res #NIL
  while {$vals ne "#NIL"} {
    set res [cons [gensym "g"] $res]
    set vals [cdr $vals]
  }
  return $res
}
\end{lstlisting}

\subsection{gensym procedure}
\label{gensym-procedure}
\index{gensym procedure}

\texttt{gensym} generates a unique symbol. The candidate symbol is compared to all the symbols in the symbol table to avoid collisions.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf gensym (internal)} \\
prefix & a string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::gensym {prefix} {
  set symbolnames [
    dict keys $::constcl::symbolTable]
  set s $prefix<[incr ::constcl::gensymnum]>
  while {$s in $symbolnames} {
    set s $prefix<[incr ::constcl::gensymnum]>
  }
  return [S $s]
}
\end{lstlisting}

\subsection{append-b procedure}
\label{appendb-procedure}
\index{append-b procedure}

\texttt{append-b} joins two lists together.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf append-b (internal)} \\
a & a Lisp list of values \\
b & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::append-b {a b} {
  if {$a eq "#NIL"} {
    return $b
  }
  set p $a
  while {$p ne "#NIL"} {
    if {[T [atom? $p]]} {
      ::error "append: improper list"
    }
    set last $p
    set p [cdr $p]
  }
  set-cdr! $last $b
  return $a
}
\end{lstlisting}

\subsection{make-assignments procedure}
\label{makeassignments-procedure}
\index{make-assignments procedure}

\texttt{make-assignments} creates the structure that holds the assignment statements. Later on, it will be joined to the body of the finished expression.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-assignments (internal)} \\
vars & a Lisp list of symbols \\
tmps & a Lisp list of symbols \\
\textit{Returns:} & an expression \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-assignments {vars tmps} {
  set res #NIL
  while {$vars ne "#NIL"} {
    set asg [cons [car $tmps] #NIL]
    set asg [cons [car $vars] $asg]
    set asg [cons [S set!] $asg]
    set res [cons $asg $res]
    set vars [cdr $vars]
    set tmps [cdr $tmps]
  }
  return [cons [S begin] $res]
}
\end{lstlisting}

\subsection{make-undefineds procedure}
\label{makeundefineds-procedure}
\index{make-undefineds procedure}

\texttt{make-undefineds} creates a list of quoted undefined values.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-undefineds (internal)} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of nil values \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::make-undefineds {vals} {
  set res #NIL
  while {$vals ne "#NIL"} {
    set res [cons [list [S quote] #UND] $res]
    set vals [cdr $vals]
  }
  return $res
}
\end{lstlisting}

\chapter{Output}
\label{output}

The third thing an interpreter must be able to do is to present the resulting code and data so that the user can know what the outcome of the evaluation was.

\subsection{write procedure}
\label{write-procedure}
\index{write procedure}

As long as the object given to \texttt{write} isn't the empty string, it calls the object's \texttt{write} method and writes a newline.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf write (public)} \\
val & a value \\
?port? & a port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg write

proc ::constcl::write {val args} {
  if {$val ne ""} {
    set oldport $::constcl::Output_port
    if {[llength $args]} {
      lassign $args port
      set ::constcl::Output_port $port
    }
    $val write $::constcl::Output_port
    $::constcl::Output_port newline
    set ::constcl::Output_port $oldport
  }
  return
}
\end{lstlisting}

\subsection{display procedure}
\label{display-procedure}
\index{display procedure}

The \texttt{display} procedure is like \texttt{write} but it calls the object's \texttt{display} method and doesn't print a newline afterwards.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf display (public)} \\
val & a value \\
?port? & a port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg display

proc ::constcl::display {val args} {
  if {$val ne ""} {
    set oldport $::constcl::Output_port
    if {[llength $args]} {
      lassign $args port
      set ::constcl::Output_port $port
    }
    $val display $::constcl::Output_port
    $::constcl::Output_port flush
    set ::constcl::Output_port $oldport
  }
  return
}
\end{lstlisting}

\subsection{write-pair procedure}
\label{writepair-procedure}
\index{write-pair procedure}

The \texttt{write-pair} procedure prints a Pair object except for the beginning and ending parentheses.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf write-pair (internal)} \\
port & an output port \\
pair & a pair \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::write-pair {port pair} {
  # take an object and print the car
  # and the cdr of the stored value
  set a [car $pair]
  set d [cdr $pair]
  # print car
  $a write $port
  if {[T [pair? $d]]} {
    # cdr is a cons pair
    $port put " "
    write-pair $port $d
  } elseif {[T [null? $d]]} {
    # cdr is nil
    return
  } else {
    # it is an atom
    $port put " . "
    $d write $port
  }
  return
}
\end{lstlisting}

\chapter{Identifier validation}
\label{identifier-validation}

\textbf{idcheckinit}

\textbf{idchecksubs}

\textbf{idcheck}

\textbf{varcheck}

Some routines for checking if a string is a valid identifier. \texttt{idcheckinit} checks the first character, \texttt{idchecksubs} checks the rest. \texttt{idcheck} calls the others and raises an error if they fail. A valid symbol is still an invalid identifier if has the name of some keyword, which \texttt{varcheck} checks, for a set of keywords given in the standard.
\index{idcheckinit}

\begin{lstlisting}
proc ::constcl::idcheckinit {init} {
  if {[::string is alpha -strict $init] ||
    $init in {! $ % & * / : < = > ? ^ _ ~}} {
    return true
  } else {
    return false
  }
}
\end{lstlisting}
\index{idchecksubs}

\begin{lstlisting}
proc ::constcl::idchecksubs {subs} {
  foreach c [split $subs {}] {
    if {!([::string is alnum -strict $c] ||
      $c in {! $ % & * / : < = > ? ^ _ ~ + - . @})} {
      return false
    }
  }
  return true
}
\end{lstlisting}
\index{idcheck}

\begin{lstlisting}
proc ::constcl::idcheck {sym} {
  if {$sym eq {}} {return $sym}
  if {(![idcheckinit [::string index $sym 0]] ||
    ![idchecksubs [::string range $sym 1 end]]) &&
    $sym ni {+ - ...}} {
    ::error "Identifier expected ($sym)"
  }
  set sym
}
\end{lstlisting}
\index{varcheck}

\begin{lstlisting}
proc ::constcl::varcheck {sym} {
  if {$sym in {
    else => define unquote unquote-splicing
    quote lambda if set! begin cond and or
    case let let* letrec do delay quasiquote
  }} {
    ::error "Variable name is reserved: $sym"
  }
  return $sym
}
\end{lstlisting}

\chapter{Environment class and objects}
\label{environment-class-and-objects}

The class for environments is called \texttt{Environment}. It is mostly a wrapper around a dictionary, with the added finesse of keeping a link to the outer environment. In this way, there is a chain connecting the latest environment all the way to the global environment and then stopping at the null environment. This chain can be traversed by the \texttt{find} method to find which innermost environment a given symbol is bound in.

Using a dictionary means that name lookup is by hash table lookup. In a typical Lisp implementation, large environments are served by hash lookup, while small ones have name lookup by linear search.

The long and complex constructor is to accommodate the variations of Scheme parameter lists, which can be empty, a proper list, a symbol, or a dotted list.

Names are stored as Lisp symbols, while values are stored as they are, as Lisp or Tcl values. This means that a name might have to be converted to a symbol before lookup, and the result of lookup may have to be converted afterwards. Note that in the two cases where a number of values are stored under one name (a formals list of a single symbol or a dotted list), then the values are stored as a Lisp list of values.

\subsection{Environment class}
\label{environment-class}
\index{Environment class}

\begin{lstlisting}
catch { ::constcl::Environment destroy }

oo::class create ::constcl::Environment {
  variable bindings outer_env
  constructor {syms vals {outer {}}} {
    set bindings [dict create]
    if {[T [::constcl::null? $syms]]} {
      if {[llength $vals]} {
        error "too many arguments"
      }
    } elseif {[T [::constcl::list? $syms]]} {
      set syms [::constcl::splitlist $syms]
      set symsn [llength $syms]
      set valsn [llength $vals]
      if {$symsn != $valsn} {
        error [
          ::append --> "wrong # of arguments, " \
            "$valsn instead of $symsn"]
      }
      foreach sym $syms val $vals {
        my bind $sym [lindex $val 0] [lindex $val 1]
      }
    } elseif {[T [::constcl::symbol? $syms]]} {
      my bind $syms VARIABLE [
        ::constcl::list {*}[lmap v $vals {
          lindex $v 1
        }]]
    } else {
      while true {
        if {[llength $vals] < 1} {
          error "too few arguments"
        }
        my bind [::constcl::car $syms] \
          [lindex $vals 0 0] [lindex $vals 0 1]
        set vals [lrange $vals 1 end]
        if {[T [
          ::constcl::symbol? [
            ::constcl::cdr $syms]]]} {
          my bind [::constcl::cdr $syms] \
            VARIABLE [
              ::constcl::list {*}[lmap v $vals {
                lindex $v 1
              }]]
          set vals {}
          break
        } else {
          set syms [::constcl::cdr $syms]
        }
      }
    }
    set outer_env $outer
  }
  method find {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment find"
    }
    if {[dict exists $bindings $sym]} {
      self
    } else {
      $outer_env find $sym
    }
  }
  method get {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment get"
    }
    dict get $bindings $sym
  }
  method unbind {sym} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment unbind"
    }
    dict unset bindings $sym
  }
  method bind {sym type info} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment bind"
    }
    if {[dict exists $bindings $sym]} {
      set bi [my get $sym]
      lassign $bi bt in
      if {$bt in {SPECIAL VARIABLE SYNTAX}} {
        error "[$sym name] is already bound"
      }
    }
    dict set bindings $sym [::list $type $info]
  }
  method assign {sym type info} {
    ::constcl::check {::constcl::symbol? $sym} {
      "SYMBOL expected\nEnvironment assign"
    }
    if {![dict exists $bindings $sym]} {
      error "[$sym name] is not bound"
    }
    set bi [my get $sym]
    lassign $bi bt in
    if {$bt ne "VARIABLE"} {
      error "[$sym name] is not assignable"
    }
    dict set bindings $sym [::list $type $info]
  }
  method parent {} {
    set outer_env
  }
  method names {} {
    dict keys $bindings
  }
  method values {} {
    dict values $bindings
  }
  method write {port} {
    regexp {(\d+)} [self] -> num
    $port put "#<env-$num>"
  }
  method display {port} {
    my write $port
  }
}
\end{lstlisting}

\subsection{MkEnv generator}
\label{mkenv-generator}
\index{MkEnv generator}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkEnv (internal)} \\
?parms? & a Scheme formals list \\
?vals? & a Tcl list of values \\
env & an environment \\
\textit{Returns:} & an environment \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkEnv {args} {
  if {[llength $args] == 1} {
    set parms #NIL
    set vals {}
    lassign $args env
  } elseif {[llength $args] == 3} {
    lassign $args parms vals env
  } else {
    error "wrong number of arguments"
  }
  Environment new $parms $vals $env
}
\end{lstlisting}

\subsection{environment? procedure}
\label{environment-procedure}
\index{environment? procedure}

Recognizes an environment by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf environment? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg environment?

proc ::constcl::environment? {val} {
  typeof? $val Environment
}
\end{lstlisting}

\section{Lexical scoping}
\label{lexical-scoping}
\index{Lexical scoping}

Example:

\begin{verbatim}
ConsTcl> (define (circle-area r) (* pi (* r r)))
ConsTcl> (circle-area 10)
314.1592653589793
\end{verbatim}

During a call to the procedure \texttt{circle-area}, the symbol \texttt{r} is bound to the value 10. But we don't want the binding to go into the global environment, possibly clobbering an earlier definition of \texttt{r}. The solution is to use separate (but linked) environments, making \texttt{r}'s binding a local variable\footnote{See \texttt{https://en.wikipedia.org/wiki/Local\_variable}}\index{local variable} in its own environment, which the procedure will be evaluated in. The symbols \texttt{*} and \texttt{pi} will still be available through the local environment's link to the outer global environment. This is all part of lexical scoping\footnote{See \texttt{https://en.wikipedia.org/wiki/Scope\_(computer\_science)\#Lexical\_scope}}\index{lexical scope}.

In the first image, we see the global environment before we call \texttt{circle-area} (and also the empty null environment which the global environment links to):

\includegraphics{images/env1.png}

During the call. Note how the global \texttt{r} is shadowed by the local one, and how the local environment links to the global one to find \texttt{*} and \texttt{pi}.

\includegraphics{images/env2.png}

After the call, we are back to the first state again.

\includegraphics{images/env1.png}

\chapter{The REPL}
\label{the-repl}

The REPL (read-eval-print loop) is a loop that repeatedly \emph{reads} a Scheme source string from the user through the command \texttt{::constcl::input} (breaking the loop if given an empty line) and \texttt{::constcl::parse}, \emph{evaluates} it using \texttt{::constcl::eval}, and \emph{prints} using \texttt{::constcl::write}.

\textbf{input}

\texttt{input} is modelled after the Python 3 function. It displays a prompt and reads a string.
\index{input}

\begin{lstlisting}
proc ::constcl::input {prompt} {
  puts -nonewline $prompt
  flush stdout
  set buf [gets stdin]
  set openpars [regexp -all -inline {\(} $buf]
  set clsepars [regexp -all -inline {\)} $buf]
  set openbrak [regexp -all -inline {\[} $buf]
  set clsebrak [regexp -all -inline {\]} $buf]
  while {[llength $openpars] > [llength $clsepars] ||
         [llength $openbrak] > [llength $clsebrak]} {
    ::append buf [gets stdin]
    set openpars [regexp -all -inline {\(} $buf]
    set clsepars [regexp -all -inline {\)} $buf]
    set openbrak [regexp -all -inline {\[} $buf]
    set clsebrak [regexp -all -inline {\]} $buf]
  }
  return $buf
}
\end{lstlisting}

\textbf{repl}

\texttt{repl} puts the `loop' in the read-eval-print loop. It repeats prompting for a string until given a blank input. Given non-blank input, it parses and evaluates the string, printing the resulting value.
\index{repl}

\begin{lstlisting}
proc ::repl {{prompt "ConsTcl> "}} {
  set cur_env [::constcl::MkEnv ::constcl::global_env]
  set str [::constcl::input $prompt]
  while {$str ne ""} {
    set expr [::constcl::parse $str]
    set val [::constcl::eval $expr $cur_env]
    ::constcl::write $val
    set str [::constcl::input $prompt]
  }
  $cur_env destroy
}
\end{lstlisting}

Well!

After 1876 lines of code, the interpreter is done.

Now for the built-in procedures!

\chapter{Built-in procedures}
\label{builtin-procedures}

\section{Equivalence predicates}
\label{equivalence-predicates}
\index{equivalence predicates}

One of the fundamental questions in programming is ``is A equal to B?'' Whether the algorithm is about searching, sorting, or almost anything else, an equality test comes up sooner rather than later. Lisp takes the question and adds ``what does it mean to be equal?''

Lisp has a number of equivalence predicates, ConsTcl, like Scheme, has three. Of the three, \texttt{eq} generally tests for identity (with exception for numbers), \texttt{eqv} tests for value equality (except for booleans and procedures, where it tests for identity), and \texttt{equal} tests for whether the output strings are equal.

\subsection{eq? procedure}
\label{eq-procedure}
\index{eq? procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf eq?, eqv?, equal? (public)} \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg eq?

proc ::constcl::eq? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq symbol? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq char? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq null? $expr1 $expr2]} {
    return #t
  } elseif {[teq pair? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq string? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq vector? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\textbf{teq} procedure

\texttt{teq} tests for type equality, i.e. that the expressions have the same type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf teq (internal)} \\
typep & a procedure \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}
\index{teq}

\begin{lstlisting}
proc ::constcl::teq {typep expr1 expr2} {
    return [expr {[T [$typep $expr1]] &&
      [T [$typep $expr2]]}]
}
\end{lstlisting}

\textbf{veq} procedure

\texttt{veq} tests for value equality, i.e. that the expressions have the same value.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf veq (internal)} \\
expr1 & an expression \\
expr2 & an expression \\
\textit{Returns:} & a Tcl truth value (1 or 0) \\
\hline
\end{tabular}
\index{veq}

\begin{lstlisting}
proc ::constcl::veq {expr1 expr2} {
    return [expr {[$expr1 value] eq [$expr2 value]}]
}
\end{lstlisting}

\subsection{eqv? procedure}
\label{eqv-procedure}
\index{eqv? procedure}

\begin{lstlisting}
reg eqv?

proc ::constcl::eqv? {expr1 expr2} {
  if {[teq boolean? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } elseif {[teq symbol? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq number? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq char? $expr1 $expr2] &&
      [veq $expr1 eq $expr2]} {
    return #t
  } elseif {[teq null? $expr1 $expr2]} {
    return #t
  } elseif {[T [pair? $expr1]] &&
      [T [pair? $expr2]] &&
      [$expr1 car] eq [$expr2 car] &&
      [$expr1 cdr] eq [$expr2 cdr]} {
    return #t
  } elseif {[teq string? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq vector? $expr1 $expr2] &&
      [veq $expr1 $expr2]} {
    return #t
  } elseif {[teq procedure? $expr1 $expr2] &&
      $expr1 eq $expr2} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{equal? procedure}
\label{equal-procedure}
\index{equal? procedure}

\begin{lstlisting}
reg equal?

proc ::constcl::equal? {expr1 expr2} {
  if {[$expr1 show] eq [$expr2 show]} {
    return #t
  } else {
    return #f
  }
  # TODO
}
\end{lstlisting}

\section{Numbers}
\label{numbers}
\index{numbers}

The word `computer' suggests numerical calculations. A programming language is almost no use if it doesn't support arithmetic. Scheme has a rich numerical library and many number types that support advanced calculations.

I have only implemented a bare-bones version of Scheme's numerical library, though. The following is a reasonably complete framework for operations on integers and floating-point numbers. No rationals, no complex numbers, no gcd or lcm.

\subsection{Number class}
\label{number-class}
\index{Number class}

\begin{lstlisting}
oo::class create ::constcl::Number {
  superclass ::constcl::NIL
  variable value
  constructor {v} {
    if {[::string is double -strict $v]} {
      set value $v
    } else {
      ::error "NUMBER expected\n$v"
    }
  }
  method zero? {} {
    if {$value == 0} {return #t} {return #f}
  }
  method positive? {} {
    if {$value > 0} {return #t} {return #f}
  }
  method negative? {} {
    if {$value < 0} {return #t} {return #f}
  }
  method even? {} {
    if {$value % 2 == 0} {return #t} {return #f}
  }
  method odd? {} {
    if {$value % 2 == 1} {return #t} {return #f}
  }
  method value {} {
    set value
  }
  method numval {} {
    set value
  }
  method constant {} {
    return 1
  }
  method write {port} {
    $port put [my value]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    set value
  }
}
\end{lstlisting}

\subsection{MkNumber generator}
\label{mknumber-generator}
\index{MkNumber generator}

\texttt{MkNumber} generates a Number object. Short form: \texttt{N}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkNumber (internal)} \\
str & a string \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkNumber \
  {} ::constcl::Number new
interp alias {} N {} ::constcl::Number new
\end{lstlisting}

\subsection{number? procedure}
\label{number-procedure}
\index{number? procedure}

\texttt{number?} recognizes a number by object type, not by content.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf number? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg number?

proc ::constcl::number? {val} {
  return [typeof? $val Number]
}
\end{lstlisting}

\subsection{= procedure}
\label{-procedure}
\index{= procedure}

\noindent \textbf{<} procedure

\noindent \textbf{>} procedure

\noindent \textbf{<=} procedure

\noindent \textbf{>=} procedure

The predicates \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, and \texttt{>=} are implemented.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf =, <, >, <=, >= (public)} \\
nums & some numbers \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg =

proc ::constcl::= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(= [
      [lindex $args 0] show] ...)"
  }
  if {[::tcl::mathop::== {*}$nums]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{<}

\begin{lstlisting}
reg <

proc ::constcl::< {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(< num ...)"
  }
  if {[::tcl::mathop::< {*}$nums]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{>}

\begin{lstlisting}
reg >

proc ::constcl::> {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(> num ...)"
  }
  if {[::tcl::mathop::> {*}$nums]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{<=}

\begin{lstlisting}
reg <=

proc ::constcl::<= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(<= num ...)"
  }
  if {[::tcl::mathop::<= {*}$nums]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{>=}

\begin{lstlisting}
reg >=

proc ::constcl::>= {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(>= num ...)"
  }
  if {[::tcl::mathop::>= {*}$nums]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{zero? procedure}
\label{zero-procedure}
\index{zero? procedure}

The \texttt{zero?} predicate tests if a given number is equal to zero.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf zero? (public)} \\
num & a number \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg zero?

proc ::constcl::zero? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  return [$num zero?]
}
\end{lstlisting}

\subsection{positive? procedure}
\label{positive-procedure}
\index{positive? procedure}

\noindent \textbf{negative?} procedure

\noindent \textbf{even?} procedure

\noindent \textbf{odd?} procedure

The \texttt{positive?}/\texttt{negative?}/\texttt{even?}/\texttt{odd?} predicates test a number for those traits.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf positive?, negative?, even?, odd? (public)} \\
num & a number \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg positive?

proc ::constcl::positive? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  return [$num positive?]
}
\end{lstlisting}
\index{negative? procedure}

\begin{lstlisting}
reg negative?

proc ::constcl::negative? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  return [$num negative?]
}
\end{lstlisting}
\index{even? procedure}

\begin{lstlisting}
reg even?

proc ::constcl::even? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  return [$num even?]
}
\end{lstlisting}
\index{odd? procedure}

\begin{lstlisting}
reg odd?

proc ::constcl::odd? {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  return [$num odd?]
}
\end{lstlisting}

\subsection{max procedure}
\label{max-procedure}
\index{max procedure}

\textbf{min} procedure

The \texttt{max} function selects the largest number, and the \texttt{min} function selects the smallest number.

Example:

\begin{verbatim}
(max 7 1 10 3)   =>  10
(min 7 1 10 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf max, min (public)} \\
num & a number \\
nums & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg max

proc ::constcl::max {num args} {
  lappend args $num
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(max num...)"
  }
  N [::tcl::mathfunc::max {*}$nums]
}
\end{lstlisting}
\index{min procedure}

\begin{lstlisting}
reg min

proc ::constcl::min {num args} {
  lappend args $num
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(min num...)"
  }
  N [::tcl::mathfunc::min {*}$nums]
}
\end{lstlisting}

\subsection{+ procedure}
\label{-procedure1}
\index{+ procedure}

\noindent \textbf{*} procedure

\noindent \textbf{-} procedure

\noindent \textbf{/} procedure

The operators \texttt{+}, \texttt{*}, \texttt{-}, and \texttt{/} stand for the respective mathematical operations. They take a number of operands, but at least one for \texttt{-} and \texttt{/}.

Example:

\begin{verbatim}
(list (+ 2 2) (* 2 2) (- 10 6) (/ 20 5))   =>  (4 4 4 4)
(+ 21 7 3)                                 =>  31
(* 21 7 3)                                 =>  441
(- 21 7 3)                                 =>  11
(/ 21 7 3)                                 =>  1
(- 5)                                      =>  -5
(/ 5)                                      =>  0.2
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf +, * (public)} \\
?nums? & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf -, / (public)} \\
num & a number \\
?nums? & some numbers \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg +

proc ::constcl::+ {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(+ num ...)"
  }
  N [::tcl::mathop::+ {*}$nums]
}
\end{lstlisting}
\index{* procedure}

\begin{lstlisting}
reg *

proc ::constcl::* {args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(* num ...)"
  }
  N [::tcl::mathop::* {*}$nums]
}
\end{lstlisting}
\index{- procedure}

\begin{lstlisting}
reg -

proc ::constcl::- {num args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(- num ...)"
  }
  N [::tcl::mathop::- [$num numval] {*}$nums]
}
\end{lstlisting}
\index{/ procedure}

\begin{lstlisting}
reg /

proc ::constcl::/ {num args} {
  try {
    set nums [lmap arg $args {$arg numval}]
  } on error {} {
    ::error "NUMBER expected\n(/ num ...)"
  }
  N [::tcl::mathop::/ [$num numval] {*}$nums]
}
\end{lstlisting}

\subsection{abs procedure}
\label{abs-procedure}
\index{abs procedure}

The \texttt{abs} function yields the absolute value of a number.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf abs (public)} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg abs

proc ::constcl::abs {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  if {[T [$num negative?]]} {
    return [N [expr {[$num numval] * -1}]]
  } else {
    return $num
  }
}
\end{lstlisting}

\subsection{quotient procedure}
\label{quotient-procedure}
\index{quotient procedure}

\texttt{quotient} calculates the quotient between two numbers.

Example:

\begin{verbatim}
(quotient 7 3)   =>  2.0
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf quotient (public)} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg quotient

proc ::constcl::quotient {num1 num2} {
  set q [::tcl::mathop::/ [$num1 numval] \
    [$num2 numval]]
  if {$q > 0} {
    return [N [::tcl::mathfunc::floor $q]]
  } elseif {$q < 0} {
    return [N [::tcl::mathfunc::ceil $q]]
  } else {
    return #0
  }
}
\end{lstlisting}

\subsection{remainder procedure}
\label{remainder-procedure}
\index{remainder procedure}

\texttt{remainder} is a variant of the modulus function. (I'm a programmer, not a mathematician!)

Example:

\begin{verbatim}
(remainder 7 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf remainder (public)} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg remainder

proc ::constcl::remainder {num1 num2} {
  set n [::tcl::mathop::% [[abs $num1] numval] \
    [[abs $num2] numval]]
  if {[T [$num1 negative?]]} {
    set n -$n
  }
  return [N $n]
}
\end{lstlisting}

\subsection{modulo procedure}
\label{modulo-procedure}
\index{modulo procedure}

Example:

\begin{verbatim}
(modulo 7 3)   =>  1
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf modulo (public)} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg modulo

proc ::constcl::modulo {num1 num2} {
  return [N [::tcl::mathop::% [$num1 numval] \
    [$num2 numval]]]
}
\end{lstlisting}

\subsection{floor procedure}
\label{floor-procedure}
\index{floor procedure}

\noindent \textbf{ceiling} procedure

\noindent \textbf{truncate} procedure

\noindent \textbf{round} procedure

\texttt{floor}, \texttt{ceiling}, \texttt{truncate}, and \texttt{round} are different methods for converting a real number to an integer.

Example:

\begin{verbatim}
(floor 7.5)      =>  7.0
(ceiling 7.5)    =>  8.0
(truncate 7.5)   =>  7.0
(round 7.5)      =>  8
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf floor, ceiling, truncate, round (public)} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg floor

proc ::constcl::floor {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::floor [$num numval]]
}
\end{lstlisting}
\index{ceiling procedure}

\begin{lstlisting}
reg ceiling

proc ::constcl::ceiling {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::ceil [$num numval]]
}
\end{lstlisting}
\index{truncate procedure}

\begin{lstlisting}
reg truncate

proc ::constcl::truncate {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  if {[T [$num negative?]]} {
    N [::tcl::mathfunc::ceil [$num numval]]
  } else {
    N [::tcl::mathfunc::floor [$num numval]]
  }
}
\end{lstlisting}
\index{round procedure}

\begin{lstlisting}
reg round

proc ::constcl::round {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::round [$num numval]]
}
\end{lstlisting}

\subsection{exp procedure}
\label{exp-procedure}
\index{exp procedure}

\noindent \textbf{log} procedure

\noindent \textbf{sin} procedure

\noindent \textbf{cos} procedure

\noindent \textbf{tan} procedure

\noindent \textbf{asin} procedure

\noindent \textbf{acos} procedure

\noindent \textbf{atan} procedure

The mathematical functions ${e}^{x}$, natural logarithm, sine, cosine, tangent, arcsine, arccosine, and arctangent are calculated by \texttt{exp}, \texttt{log}, \texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{asin}, \texttt{acos}, and \texttt{atan}, respectively. \texttt{atan} can be called both as a unary (one argument) function and a binary (two arguments) one.

Example:

\begin{verbatim}
(let ((x (log 2))) (= 2 (exp x)))        =>  #t
(let* ((a (/ pi 3)) (s (sin a)))
  (= a (asin s)))                        =>  #t
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf exp, log, sin, cos, tan, asin, acos, atan (public)} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf (binary) atan (public)} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg exp

proc ::constcl::exp {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::exp [$num numval]]
}
\end{lstlisting}
\index{log procedure}

\begin{lstlisting}
reg log

proc ::constcl::log {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::log [$num numval]]
}
\end{lstlisting}
\index{sin procedure}

\begin{lstlisting}
reg sin

proc ::constcl::sin {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::sin [$num numval]]
}
\end{lstlisting}
\index{cos procedure}

\begin{lstlisting}
reg cos

proc ::constcl::cos {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::cos [$num numval]]
}
\end{lstlisting}
\index{tan procedure}

\begin{lstlisting}
reg tan

proc ::constcl::tan {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::tan [$num numval]]
}
\end{lstlisting}
\index{asin procedure}

\begin{lstlisting}
reg asin

proc ::constcl::asin {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::asin [$num numval]]
}
\end{lstlisting}
\index{acos procedure}

\begin{lstlisting}
reg acos

proc ::constcl::acos {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::acos [$num numval]]
}
\end{lstlisting}
\index{atan procedure}

\begin{lstlisting}
reg atan

proc ::constcl::atan {args} {
  if {[llength $args] == 1} {
    set num [lindex $args 0]
    check {number? $num} {
        NUMBER expected\n([pn] [$num show])
    }
    N [::tcl::mathfunc::atan [$num numval]]
  } else {
    lassign $args num1 num2
    check {number? $num1} {
        NUMBER expected\n([pn] [$num1 show])
    }
    check {number? $num2} {
        NUMBER expected\n([pn] [$num2 show])
    }
    N [::tcl::mathfunc::atan2 \
      [$num1 numval] [$num2 numval]]
  }
}
\end{lstlisting}

\subsection{sqrt procedure}
\label{sqrt-procedure}
\index{sqrt procedure}

\texttt{sqrt} calculates the square root.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf sqrt (public)} \\
num & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg sqrt

proc ::constcl::sqrt {num} {
  check {number? $num} {
      NUMBER expected\n([pn] [$num show])
  }
  N [::tcl::mathfunc::sqrt [$num numval]]
}
\end{lstlisting}

\subsection{expt procedure}
\label{expt-procedure}
\index{expt procedure}

\texttt{expt} calculates the x to the power of y, or ${x}^{y}$.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf expt (public)} \\
num1 & a number \\
num2 & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg expt

proc ::constcl::expt {num1 num2} {
  check {number? $num1} {
      NUMBER expected\n([pn] [$num1 show] \
        [$num2 show])
  }
  check {number? $num2} {
      NUMBER expected\n([pn] [$num1 show] \
        [$num2 show])
  }
  N [::tcl::mathfunc::pow [$num1 numval] \
    [$num2 numval]]
}
\end{lstlisting}

\subsection{number->string procedure}
\label{numberstring-procedure}
\index{number->string procedure}

The procedures \texttt{number->string} and \texttt{string->number} convert between number and string with optional radix conversion.

Example:

\begin{verbatim}
(number->string 23)      =>  "23"
(number->string 23 2)    =>  "10111"
(number->string 23 8)    =>  "27"
(number->string 23 16)   =>  "17"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf number->string (public)} \\
num & a number \\
?radix? & a number \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg number->string

proc ::constcl::number->string {num args} {
  if {[llength $args] == 0} {
    check {number? $num} {
      NUMBER expected\n([pn] [$num show])
    }
    return [MkString [$num numval]]
  } else {
    lassign $args radix
    check {number? $num} {
      NUMBER expected\n([pn] [$num show])
    }
    check {number? $radix} {
      NUMBER expected\n([pn] [$num show] \
        [$radix show])
    }
    set radices [list [N 2] [N 8] [N 10] [N 16]]
    check {memv $radix $radices} {
      Radix not in 2, 8, 10, 16\n([pn] \
        [$num show] [$radix show])
    }
    if {[$radix numval] == 10} {
      return [MkString [$num numval]]
    } else {
      return [MkString [base [$radix numval] \
        [$num numval]]]
    }
  }
}
\end{lstlisting}

\texttt{base} is due to Richard Suchenwirth\footnote{See \texttt{https://wiki.tcl-lang.org/page/Based+numbers}}\index{Suchenwirth, Richard}.
\index{base}

\begin{lstlisting}
proc base {base number} {
  set negative [regexp ^-(.+) $number -> number]
  set digits {0 1 2 3 4 5 6 7 8 9 A B C D E F}
  set res {}
  while {$number} {
    set digit [expr {$number % $base}]
    set res [lindex $digits $digit]$res
    set number [expr {$number / $base}]
  }
  if $negative {set res -$res}
  set res
}
\end{lstlisting}

\subsection{string->number procedure}
\label{stringnumber-procedure}
\index{string->number procedure}

As with \texttt{number->string}, above.

Example:

\begin{verbatim}
(string->number "23")        =>  23
(string->number "10111" 2)   =>  23
(string->number "27" 8)      =>  23
(string->number "17" 16)     =>  23
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string->number (public)} \\
str & a string \\
?radix? & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->number

proc ::constcl::string->number {str args} {
  if {[llength $args] == 0} {
    check {string? $str} {
      STRING expected\n([pn] [$str show])
    }
    return [N [$str value]]
  } else {
    lassign $args radix
    check {string? $str} {
      STRING expected\n([pn] [$str show])
    }
    set radices [list [N 2] [N 8] [N 10] [N 16]]
    check {memv $radix $radices} {
      Radix not in 2, 8, 10, 16\n([pn] [$str show] \
        [$radix show])
    }
    if {[$radix numval] == 10} {
      return [N [$str value]]
    } else {
      return [N [
        frombase [$radix numval] [$str value]]]
    }
  }
}
\end{lstlisting}

\texttt{frombase} is due to Richard Suchenwirth\footnote{See \texttt{https://wiki.tcl-lang.org/page/Based+numbers}}\index{Suchenwirth, Richard}.
\index{frombase}

\begin{lstlisting}
proc frombase {base number} {
  set digits {0 1 2 3 4 5 6 7 8 9 A B C D E F}
  set negative [regexp ^-(.+) $number -> number]
  set res 0
  foreach digit [split $number {}] {
    # dv = decimal value
    set dv [lsearch $digits $digit]
    if {$dv < 0 || $dv >= $base} {
      ::error "bad digit $dv for base $base"
    }
    set res [expr {$res * $base + $dv}]
  }
  if $negative {set res -$res}
  set res
}
\end{lstlisting}

\section{Booleans}
\label{booleans}
\index{Booleans}

Booleans are logic values, either true (\texttt{\#t}) or false (\texttt{\#f}). All predicates (procedures whose name end with -?) return boolean values. It's not just the boolean values that have truth value, though. Scheme's conditional \texttt{if} operator considers all values except for \texttt{\#f} to be true.

\subsection{Boolean class}
\label{boolean-class}
\index{Boolean class}

\begin{lstlisting}
oo::class create ::constcl::Boolean {
  superclass ::constcl::NIL
  variable boolval
  constructor {v} {
    if {$v ni {#t #f}} {
      ::error "bad boolean value $v"
    }
    set boolval $v
  }
  method constant {} {
    return 1
  }
  method boolval {} {
    set boolval
  }
  method value {} {
    set boolval
  }
  method write {port} {
    $port put [my boolval]
  }
  method display {port} {
    $port put [my boolval]
  }
  method show {} {
    set boolval
  }
}
\end{lstlisting}

\subsection{MkBoolean generator}
\label{mkboolean-generator}
\index{MkBoolean generator}

\texttt{MkBoolean} generates a boolean. If a boolean with the same name already exists (which is the case at run time, because there are only two valid boolean values, and they're both pre-generated) that boolean will be returned, otherwise a fresh boolean will be created.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkBoolean (internal)} \\
bool & an external rep of a bool \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkBoolean {bool} {
  foreach instance [info class instances \
    ::constcl::Boolean] {
    if {[$instance boolval] eq $bool} {
      return $instance
    }
  }
  return [::constcl::Boolean new $bool]
}
\end{lstlisting}

\subsection{boolean? procedure}
\label{boolean-procedure}
\index{boolean? procedure}

The \texttt{boolean?} predicate recognizes a Boolean by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf boolean? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg boolean?

proc ::constcl::boolean? {val} {
  return [typeof? $val Boolean]
}
\end{lstlisting}

\subsection{not procedure}
\label{not-procedure}
\index{not procedure}

The only operation on booleans: \texttt{not}, or logical negation.

Example:

\begin{verbatim}
(not #f)    ==>  #t   ; #f yields #t, all others #f
(not nil)   ==>  #f   ; see?
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf not (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg not

proc ::constcl::not {val} {
  if {[$val boolval] eq "#f"} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\section{Characters}
\label{characters}
\index{Characters}

Characters are any Unicode printing character, and also space and newline space characters. External representation is \texttt{\#\textbackslash A} (A stands for any character) or \texttt{\#\textbackslash space} or \texttt{\#\textbackslash newline}. Internal representation is simply a Tcl character.

\subsection{Char class}
\label{char-class}
\index{Char class}

\begin{lstlisting}
oo::class create ::constcl::Char {
  superclass ::constcl::NIL
  variable value
  constructor {v} {
    switch -regexp $v {
      {(?i)#\\space} {
        set v " "
      }
      {(?i)#\\newline} {
        set v "\n"
      }
      {#\\[[:graph:]]} {
        set v [::string index $v 2]
      }
    }
    set value $v
  }
  method char {} {
    set value
  }
  method alphabetic? {} {
    if {[::string is alpha -strict [my char]]} {
      return #t
    } else {
      return #f
    }
  }
  method numeric? {} {
    if {[::string is digit -strict [my char]]} {
      return #t
    } else {
      return #f
    }
  }
  method whitespace? {} {
    if {[::string is space -strict [my char]]} {
      return #t
    } else {
      return #f
    }
  }
  method upper-case? {} {
    if {[::string is upper -strict [my char]]} {
      return #t
    } else {
      return #f
    }
  }
  method lower-case? {} {
    if {[::string is lower -strict [my char]]} {
      return #t
    } else {
      return #f
    }
  }
  method constant {} {
    return 1
  }
  method value {} {
    return $value
  }
  method external {} {
    switch $value {
      " " {
        return "#\\space"
      }
      "\n" {
        return "#\\newline"
      }
      default {
        return "#\\$value"
      }
    }
  }
  method write {port} {
    $port put [my external]
  }
  method display {port} {
    $port put [my char]
  }
  method show {} {
    my external
  }
}
\end{lstlisting}

\subsection{MkChar generator}
\label{mkchar-generator}
\index{MkChar generator}

\texttt{MkChar} generates a character object. If a character object with the same name already exists, that character will be returned, otherwise a fresh character will be created.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkChar (internal)} \\
char & an external rep of a char \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkChar {char} {
  if {[regexp -nocase {space|newline} $char]} {
      set char [::string tolower $char]
  }
  foreach instance [
    info class instances Char] {
    if {[$instance external] eq $char} {
      return $instance
    }
  }
  return [::constcl::Char new $char]
}
\end{lstlisting}

\subsection{char? procedure}
\label{char-procedure}
\index{char? procedure}

\texttt{char?} recognizes Char values by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char?

proc ::constcl::char? {val} {
  return [typeof? $val Char]
}
\end{lstlisting}

\subsection{char=? procedure}
\label{char-procedure1}
\index{char=? procedure}

\noindent \textbf{char<?} procedure

\noindent \textbf{char>?} procedure

\noindent \textbf{char<=?} procedure

\noindent \textbf{char>=?} procedure

\texttt{char=?}, \texttt{char<?}, \texttt{char>?}, \texttt{char<=?}, and \texttt{char>=?} compare character values. They only compare two characters at a time.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char=?, char<?, char>?, char<=?, char>=? (public)} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char=?

proc ::constcl::char=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {$char1 eq $char2} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char<? procedure}

\begin{lstlisting}
reg char<?

proc ::constcl::char<? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[$char1 char] < [$char2 char]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char>? procedure}

\begin{lstlisting}
reg char>?

proc ::constcl::char>? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[$char1 char] > [$char2 char]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char<=? procedure}

\begin{lstlisting}
reg char<=?

proc ::constcl::char<=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[$char1 char] <= [$char2 char]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char>=? procedure}

\begin{lstlisting}
reg char>=?

proc ::constcl::char>=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[$char1 char] >= [$char2 char]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{char-ci=? procedure}
\label{charci-procedure}
\index{char-ci=? procedure}

\noindent \textbf{char-ci<?} procedure

\noindent \textbf{char-ci>?} procedure

\noindent \textbf{char-ci<=?} procedure

\noindent \textbf{char-ci>=?} procedure

\texttt{char-ci=?}, \texttt{char-ci<?}, \texttt{char-ci>?}, \texttt{char-ci<=?}, and \texttt{char-ci>=?} compare character values in a case insensitive manner. They only compare two characters at a time.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char-ci=?, char-ci<?, char-ci>?, char-ci<=?, char-ci>=? (public)} \\
char1 & a character \\
char2 & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-ci=?

proc ::constcl::char-ci=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[::string tolower [$char1 char]] eq
      [::string tolower [$char2 char]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char-ci<? procedure}

\begin{lstlisting}
reg char-ci<?

proc ::constcl::char-ci<? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[::string tolower [$char1 char]] <
      [::string tolower [$char2 char]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char-ci>? procedure}

\begin{lstlisting}
reg char-ci>?

proc ::constcl::char-ci>? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[::string tolower [$char1 char]] >
      [::string tolower [$char2 char]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char-ci<=? procedure}

\begin{lstlisting}
reg char-ci<=?

proc ::constcl::char-ci<=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[::string tolower [$char1 char]] <=
      [::string tolower [$char2 char]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{char-ci>=? procedure}

\begin{lstlisting}
reg char-ci>=?

proc ::constcl::char-ci>=? {char1 char2} {
  check {char? $char1} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  check {char? $char2} {
    CHAR expected\n([pn] [$char1 show] [$char2 show])
  }
  if {[::string tolower [$char1 char]] >=
      [::string tolower [$char2 char]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{char-alphabetic? procedure}
\label{charalphabetic-procedure}
\index{char-alphabetic? procedure}

\noindent \textbf{char-numeric?} procedure

\noindent \textbf{char-whitespace?} procedure

\noindent \textbf{char-upper-case?} procedure

\noindent \textbf{char-lower-case?} procedure

The predicates \texttt{char-alphabetic?}, \texttt{char-numeric?}, and \texttt{char-whitespace?} test a character for these conditions.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char-alphabetic?, char-numeric?, char-whitespace? (public)} \\
char & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\texttt{char-upper-case?} and \texttt{char-lower-case?} too.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char-upper-case?, char-lower-case? (public)} \\
char & a character \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-alphabetic?

proc ::constcl::char-alphabetic? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [$char alphabetic?]
}
\end{lstlisting}
\index{char-numeric? procedure}

\begin{lstlisting}
reg char-numeric?

proc ::constcl::char-numeric? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [$char numeric?]
}
\end{lstlisting}
\index{char-whitespace? procedure}

\begin{lstlisting}
reg char-whitespace?

proc ::constcl::char-whitespace? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [$char whitespace?]
}
\end{lstlisting}
\index{char-upper-case? procedure}

\begin{lstlisting}
reg char-upper-case?

proc ::constcl::char-upper-case? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [$char upper-case?]
}
\end{lstlisting}
\index{char-lower-case? procedure}

\begin{lstlisting}
reg char-lower-case?

proc ::constcl::char-lower-case? {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [$char lower-case?]
}
\end{lstlisting}

\subsection{char->integer procedure}
\label{charinteger-procedure}
\index{char->integer procedure}

\texttt{char->integer} and \texttt{integer->char} convert between characters and their 16-bit numeric codes.

Example:

\begin{verbatim}
(char->integer #\A)   =>  65
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char->integer (public)} \\
char & a character \\
\textit{Returns:} & an integer \\
\hline
\end{tabular}

\begin{lstlisting}
reg char->integer

proc ::constcl::char->integer {char} {
  return [MkNumber [scan [$char char] %c]]
}
\end{lstlisting}

\subsection{integer->char procedure}
\label{integerchar-procedure}
\index{integer->char procedure}

Example:

\begin{verbatim}
(integer->char 97)   =>  #\a
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf integer->char (public)} \\
int & an integer \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg integer->char

proc ::constcl::integer->char {int} {
  if {$int == 10} {
    return [MkChar #\\newline]
  } elseif {$int == 32} {
    return [MkChar #\\space]
  } else {
    return [MkChar #\\[format %c [$int numval]]]
  }
}
\end{lstlisting}

\subsection{char-upcase procedure}
\label{charupcase-procedure}
\index{char-upcase procedure}

\textbf{char-downcase} procedure

\texttt{char-upcase} and \texttt{char-downcase} alter the case of a character.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf char-upcase, char-downcase (public)} \\
char & a character \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg char-upcase

proc ::constcl::char-upcase {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [MkChar [
    ::string toupper [$char value]]]
}
\end{lstlisting}
\index{char-downcase procedure}

\begin{lstlisting}
reg char-downcase

proc ::constcl::char-downcase {char} {
  check {char? $char} {
    CHAR expected\n([pn] [$char show])
  }
  return [MkChar [
    ::string tolower [$char value]]]
}
\end{lstlisting}

\section{Control}
\label{control}
\index{Control}

This section concerns itself with procedures and the application of the same.

A \texttt{Procedure} object is a closure\footnote{See \texttt{https://en.wikipedia.org/wiki/Closure\_(computer\_programming)}}\index{closure}, storing the procedure's parameter list, the body, and the environment that is current when the object is created, i.e. when the procedure is defined (see page \pageref{procedure-definition}).

When a \texttt{Procedure} object is called, the body is evaluated in a new environment where the parameters are given values from the argument list and the outer link goes to the closure environment.

\subsection{Procedure class}
\label{procedure-class}
\index{Procedure class}

\begin{lstlisting}
catch { ::constcl::Procedure destroy }

oo::class create ::constcl::Procedure {
  superclass ::constcl::NIL
  variable parms body env
  constructor {p b e} {
    set parms $p
    set body $b
    set env $e
  }
}
oo::define ::constcl::Procedure method call {args} {
  set vals [lmap a $args {list VARIABLE $a}]
  ::constcl::eval $body [
    ::constcl::MkEnv $parms $vals $env]
}
oo::define ::constcl::Procedure method value {} {}
oo::define ::constcl::Procedure method write {port} {
  regexp {(\d+)} [self] -> num
  $port put "#<proc-$num>"
}
oo::define ::constcl::Procedure method display {port} {
  my write $port
}
oo::define ::constcl::Procedure method show {} {
  return [self]
}
\end{lstlisting}

\subsection{MkProcedure generator}
\label{mkprocedure-generator}
\index{MkProcedure generator}

\texttt{MkProcedure} generates a Procedure object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkProcedure (internal)} \\
parms & a Scheme formals list \\
body & a Lisp list of expressions \\
env & an environment \\
\textit{Returns:} & a procedure \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkProcedure \
  {} ::constcl::Procedure new
\end{lstlisting}

\subsection{procedure? procedure}
\label{procedure-procedure}
\index{procedure? procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf procedure? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg procedure?

proc ::constcl::procedure? {val} {
  if {[typeof? $val Procedure] eq "#t"} {
    return #t
  } elseif {[::string match "::constcl::*" $val]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{apply procedure}
\label{apply-procedure}
\index{apply procedure}

\texttt{apply} applies a procedure to a Lisp list of Lisp arguments.

Example:

\begin{verbatim}
(apply + (list 2 3))   =>  5
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf apply (public)} \\
pr & a procedure \\
vals & a Lisp list of values \\
\textit{Returns:} & what pr returns \\
\hline
\end{tabular}

\begin{lstlisting}
reg apply

proc ::constcl::apply {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([pn] [$pr show] ...)
  }
  invoke $pr $vals
}
\end{lstlisting}

\subsection{map procedure}
\label{map-procedure}
\index{map procedure}

\texttt{map} iterates over one or more lists, taking an element from each list to pass to a procedure as an argument. The Lisp list of the results of the invocations is returned.

Example:

\begin{verbatim}
(map + '(1 2 3) '(5 6 7))   => (6 8 10)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf map (public)} \\
pr & a procedure \\
args & some lists \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg map

proc ::constcl::map {pr args} {
  check {procedure? $pr} {
    PROCEDURE expected\n([pn] [$pr show] ...)
  }
  set arglists $args
  for {set i 0} \
    {$i < [llength $arglists]} \
    {incr i} {
    lset arglists $i [
      splitlist [lindex $arglists $i]]
  }
  set res {}
  for {set item 0} \
    {$item < [llength [lindex $arglists 0]]} \
    {incr item} {
    set arguments {}
    for {set arg 0} \
      {$arg < [llength $arglists]} \
      {incr arg} {
      lappend arguments [
        lindex $arglists $arg $item]
    }
    lappend res [invoke $pr [list {*}$arguments]]
  }
  return [list {*}$res]
}
\end{lstlisting}

\subsection{for-each procedure}
\label{foreach-procedure}
\index{for-each procedure}

\texttt{for-each} iterates over one or more lists, taking an element from each list to pass to a procedure as an argument. The empty list is returned.

Example: (from R5RS; must be pasted as a oneliner for the ConsTcl repl to stomach it.)

\begin{verbatim}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                        =>  #(0 1 4 9 16)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf for-each (public)} \\
pr & a procedure \\
args & some lists \\
\textit{Returns:} & the empty list \\
\hline
\end{tabular}

\begin{lstlisting}
reg for-each

proc ::constcl::for-each {proc args} {
  check {procedure? $proc} {
    PROCEDURE expected\n([pn] [$proc show] ...)
  }
  set arglists $args
  for {set i 0} \
    {$i < [llength $arglists]} \
    {incr i} {
    lset arglists $i [
      splitlist [lindex $arglists $i]]
  }
  for {set item 0} \
    {$item < [llength [lindex $arglists 0]]} \
    {incr item} {
    set arguments {}
    for {set arg 0} \
      {$arg < [llength $arglists]} \
      {incr arg} {
      lappend arguments [
        lindex $arglists $arg $item]
    }
    invoke $proc [list {*}$arguments]
  }
  return #NIL
}
\end{lstlisting}

\section{Input and output}
\label{input-and-output}
\index{Input and output}

Like most programming languages, Scheme has input and output facilities beyond direct \texttt{read} and \texttt{write}. I/O is based on the \emph{port} abstraction of a character supplying or receiving device. There are four kinds of ports:

\begin{enumerate}
\item file input (InputPort)
\item file output (OutputPort)
\item string input (StringInputPort)
\item string output (StringOutputPort)
\end{enumerate}

and there is also the \texttt{Port} type, which isn't used other than as a base class.

\subsection{Port class}
\label{port-class}
\index{Port class}

\begin{lstlisting}
catch { ::constcl::Port destroy }

oo::class create ::constcl::Port {
  superclass ::constcl::NIL
  variable handle
  constructor {args} {
    if {[llength $args]} {
      lassign $args handle
    } else {
      set handle #NIL
    }
  }
  method handle {} {
    set handle
  }
  method close {} {
    close $handle
    set handle #NIL
    return
  }
  method write {p} {
    regexp {(\d+)} [self] -> num
    $p put "#<port-$num>"
  }
  method display {p} {
    my write $p
  }
}
\end{lstlisting}

\subsection{InputPort class}
\label{inputport-class}
\index{InputPort class}

\begin{lstlisting}
oo::class create ::constcl::InputPort {
  superclass ::constcl::Port
  variable handle
  method open {name} {
    try {
      set handle [open [$name value] "r"]
    } on error {} {
      set handle #NIL
      return -1
    }
    return $handle
  }
  method get {} {
    chan read $handle 1
  }
  method eof {} {
    chan eof $handle
  }
  method copy {} {
    ::constcl::InputPort new $handle
  }
  method write {p} {
    regexp {(\d+)} [self] -> num
    $p put "#<input-port-$num>"
  }
  method display {p} {
    my write $p
  }
}
\end{lstlisting}

\subsection{MkInputPort generator}
\label{mkinputport-generator}
\index{MkInputPort generator}

\texttt{MkInputPort} generates an InputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkInputPort (internal)} \\
\textit{Returns:} & an input port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkInputPort \
  {} ::constcl::InputPort new
\end{lstlisting}

\subsection{StringInputPort class}
\label{stringinputport-class}
\index{StringInputPort class}

\begin{lstlisting}
oo::class create ::constcl::StringInputPort {
  superclass ::constcl::Port
  variable buffer read_eof
  constructor {str} {
    set buffer $str
    set read_eof 0
  }
  method open {name} {}
  method close {} {}
  method get {} {
    if {[::string length $buffer] == 0} {
      set read_eof 1
      return #EOF
    }
    set c [::string index $buffer 0]
    set buffer [::string range $buffer 1 end]
    return $c
  }
  method eof {} {
    if {$read_eof} {
      return 1
    } else {
      return 0
    }
  }
  method copy {} {
    ::constcl::StringInputPort new $buffer
  }
  method write {p} {
    regexp {(\d+)} [self] -> num
    $p put "#<string-input-port-$num>"
  }
  method display {p} {
    my write $p
  }
}
\end{lstlisting}

\subsection{OutputPort class}
\label{outputport-class}
\index{OutputPort class}

\begin{lstlisting}
oo::class create ::constcl::OutputPort {
  superclass ::constcl::Port
  variable handle
  method open {name} {
    try {
      set handle [open [$name value] "w"]
    } on error {} {
      set handle #NIL
      return -1
    }
    return $handle
  }
  method put {c} {
    puts -nonewline $handle $c
  }
  method newline {} {
    puts $handle {}
  }
  method flush {} {
    flush $handle
  }
  method copy {} {
    ::constcl::OutputPort new $handle
  }
  method write {p} {
    regexp {(\d+)} [self] -> num
    $p put "#<output-port-$num>"
  }
  method display {p} {
    my write $p
  }
}
\end{lstlisting}

\subsection{MkOutputPort generator}
\label{mkoutputport-generator}
\index{MkOutputPort generator}

\texttt{MkOutputPort} generates an OutputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkOutputPort (internal)} \\
\textit{Returns:} & an output port \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkOutputPort \
  {} ::constcl::OutputPort new
\end{lstlisting}

\subsection{StringOutputPort class}
\label{stringoutputport-class}
\index{StringOutputPort class}

\begin{lstlisting}
oo::class create ::constcl::StringOutputPort {
  superclass ::constcl::Port
  variable buffer
  constructor {} {
    set buffer {}
  }
  method open {name} {}
  method close {} {}
  method put {s} {
    append buffer $s
  }
  method newline {} {
    append buffer \n
  }
  method flush {} {}
  method tostring {} {
    set buffer
  }
  method copy {} {
    ::constcl::StringOutputPort new $buffer
  }
  method write {p} {
    regexp {(\d+)} [self] -> num
    $p put "#<string-output-port-$num>"
  }
  method display {p} {
    my write $p
  }
}
\end{lstlisting}

\textbf{Input\_Port} variable

\textbf{Output\_port} variable

These two variables store globally the current configuration of the shared input and output ports. They are initially set to standard input and output respectively.

\begin{lstlisting}
set ::constcl::Input_port [
  ::constcl::MkInputPort stdin]
set ::constcl::Output_port [
  ::constcl::MkOutputPort stdout]
\end{lstlisting}

\subsection{port? procedure}
\label{port-procedure}
\index{port? procedure}

\texttt{port?} recognizes Port objects, i.e. all kinds of ports.

\begin{lstlisting}
reg port?

proc ::constcl::port? {val} {
  typeof? $val Port
}
\end{lstlisting}

\subsection{call-with-input-file procedure}
\label{callwithinputfile-procedure}
\index{call-with-input-file procedure}

\texttt{call-with-input-file} opens a file for input and passes the port to \texttt{proc}. The file is closed again once \texttt{proc} returns. The result of the call is returned.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf call-with-input-file (public)} \\
filename & a filename string \\
proc & a procedure \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg call-with-input-file

proc ::constcl::call-with-input-file {filename proc} {
  set port [open-input-file $filename]
  set res [invoke $proc [list $port]]
  close-input-port $port
  $port destroy
  return $res
}
\end{lstlisting}

\subsection{call-with-output-file procedure}
\label{callwithoutputfile-procedure}
\index{call-with-output-file procedure}

\texttt{call-with-output-file} opens a file for output and passes the port to \texttt{proc}. The file is closed again once \texttt{proc} returns. The result of the call is returned.

You can't use this procedure without deleting the first line. I take no responsibility for damage to your files due to overwriting the contents.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf call-with-output-file (public)} \\
filename & a filename string \\
proc & a procedure \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg call-with-output-file

proc ::constcl::call-with-output-file {filename proc} {
  ::error "remove this line to use"
  set port [open-output-file $filename]
  set res [invoke $proc [list $port]]
  close-output-port $port
  $port destroy
  return $res
}
\end{lstlisting}

\subsection{input-port? procedure}
\label{inputport-procedure}
\index{input-port? procedure}

\texttt{input-port?} recognizes an InputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf input-port? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg input-port?

proc ::constcl::input-port? {val} {
  if {[T typeof? $val InputPort]} {
    return #t
  } elseif {[T typeof? $val StringInputPort]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{output-port? procedure}
\label{outputport-procedure}
\index{output-port? procedure}

\texttt{output-port?} recognizes an OutputPort object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf output-port? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg output-port?

proc ::constcl::output-port? {val} {
  if {[T typeof? $val OutputPort]} {
    return #t
  } elseif {[T typeof? $val StringOutputPort]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{current-input-port procedure}
\label{currentinputport-procedure}
\index{current-input-port procedure}

\texttt{current-input-port} makes a copy of the current shared input port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf current-input-port (public)} \\
\textit{Returns:} & a port \\
\hline
\end{tabular}

\begin{lstlisting}
reg current-input-port

proc ::constcl::current-input-port {} {
  return [$::constcl::Input_port copy]
}
\end{lstlisting}

\subsection{current-output-port procedure}
\label{currentoutputport-procedure}
\index{current-output-port procedure}

\texttt{current-output-port} makes a copy of the current shared output port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf current-output-port (public)} \\
\textit{Returns:} & a port \\
\hline
\end{tabular}

\begin{lstlisting}
reg current-output-port

proc ::constcl::current-output-port {} {
  return [$::constcl::Output_port copy]
}
\end{lstlisting}

\subsection{with-input-from-file procedure}
\label{withinputfromfile-procedure}
\index{with-input-from-file procedure}

\texttt{with-input-from-file} opens a file for input and calls a `thunk' while the file is open. The file is closed again when the call is done.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf with-input-from-file (public)} \\
filename & a filename string \\
thunk & a procedure \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg with-input-from-file

proc ::constcl::with-input-from-file {filename thunk} {
  set newport [open-input-file $filename]
  if {[$newport handle] ne "#NIL"} {
    set oldport $::constcl::Input_port
    set ::constcl::Input_port $newport
    $thunk call
    set ::constcl::Input_port $oldport
    close-input-port $newport
  }
  $newport destroy
}
\end{lstlisting}

\subsection{with-output-to-file procedure}
\label{withoutputtofile-procedure}
\index{with-output-to-file procedure}

\texttt{with-output-to-file} opens a file for output and calls a `thunk' while the file is open. The file is closed again when the call is done.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf with-output-to-file (public)} \\
filename & a filename string \\
thunk & a procedure \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg with-output-to-file

proc ::constcl::with-output-to-file {filename thunk} {
  ::error "remove this line to use"
  set newport [open-output-file $filename]
  if {[$newport handle] ne "#NIL"} {
    set oldport $::constcl::Output_port
    set ::constcl::Output_port $newport
    $thunk call
    set ::constcl::Output_port $oldport
    close-input-port $newport
  }
  $newport destroy
}
\end{lstlisting}

\subsection{open-input-file procedure}
\label{openinputfile-procedure}
\index{open-input-file procedure}

\texttt{open-input-file} opens a file for input and returns the port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf open-input-file (public)} \\
filename & a filename string \\
\textit{Returns:} & an input port \\
\hline
\end{tabular}

\begin{lstlisting}
reg open-input-file

proc cnof {} {return "could not open file"}
proc fae {} {return "file already exists"}

proc ::constcl::open-input-file {filename} {
  set p [MkInputPort]
  $p open $filename
  if {[$p handle] eq "#NIL"} {
    set fn [$filename value]
    error "open-input-file: [cnof] $fn"
  }
  return $p
}
\end{lstlisting}

\subsection{open-output-file procedure}
\label{openoutputfile-procedure}
\index{open-output-file procedure}

\texttt{open-output-file} opens a file for output and returns the port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf open-output-file (public)} \\
filename & a filename string \\
\textit{Returns:} & an output port \\
\hline
\end{tabular}

\begin{lstlisting}
reg open-output-file

proc ::constcl::open-output-file {filename} {
  ::error "remove this line to use"
  if {[file exists $filename]} {
    error "open-output-file: [fae] $filename"
  }
  set p [MkOutputPort]
  $p open $filename
  if {[$p handle] eq "#NIL"} {
    error "open-output-file: [cnof] $filename"
  }
  return $p
}
\end{lstlisting}

\subsection{close-input-port procedure}
\label{closeinputport-procedure}
\index{close-input-port procedure}

\texttt{close-input-port} closes an input port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf close-input-port (public)} \\
port & an input port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg close-input-port

proc ::constcl::close-input-port {port} {
  if {[$port handle] eq "stdin"} {
    error "don't close the standard input port"
  }
  $port close
}
\end{lstlisting}

\subsection{close-output-port procedure}
\label{closeoutputport-procedure}
\index{close-output-port procedure}

\texttt{close-output-port} closes an output port.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf close-output-port (public)} \\
port & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg close-output-port

proc ::constcl::close-output-port {port} {
  if {[$port handle] eq "stdout"} {
    error "don't close the standard output port"
  }
  $port close
}
\end{lstlisting}

\texttt{write} is implemented in the output (see page \pageref{output}) chapter.

\texttt{display} is implemented in the output chapter.

\subsection{newline procedure}
\label{newline-procedure}
\index{newline procedure}

\texttt{newline} outputs a newline character. Especially helpful when using \texttt{display} for output, since it doesn't end lines with newline.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf newline (public)} \\
?port? & an output port \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg newline

proc ::constcl::newline {args} {
  if {[llength $args]} {
    lassign $args port
  } else {
    set port [current-output-port]
  }
  pe "(display #\\newline '$port)"
}
\end{lstlisting}

\textbf{load}

\texttt{load} reads a Lisp source file and evals the expressions in it in the global environment. The procedure is a ConsTcl mix of Scheme calls and Tcl syntax.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf load (public)} \\
filename & a filename string \\
\textit{Returns:} & nothing \\
\hline
\end{tabular}

\begin{lstlisting}
reg load

proc ::constcl::load {filename} {
  set p [open-input-file $filename]
  if {[$p handle] ne "#NIL"} {
    set n [read $p]
    while {$n ne "#EOF"} {
      eval $n
      set n [read $p]
    }
    close-input-port $p
  }
  $p destroy
}
\end{lstlisting}

\section{Pairs and lists}
\label{pairs-and-lists}
\index{Pairs and lists}

List processing is another of Lisp's great strengths. In Lisp, lists (which are actually tree structures) are composed of \emph{pairs}, which in the most elementary case are constructed using calls to the \texttt{cons} function. Example:

\begin{verbatim}
(cons 'a (cons 'b (cons (cons 'c '()) '())))   ==> (a b (c))
\end{verbatim}

A \emph{pair} consists of a pair of pointers, named the \emph{car} and the \emph{cdr} (there are historical, not very interesting, reasons for this naming).

\includegraphics{images/pair.png}

The example above would look like this (we'll name it L). \texttt{car L} is the symbol \texttt{a}, and \texttt{cdr L} is the list \texttt{(b (c))}. \texttt{cadr L} (the \texttt{car} of \texttt{cdr L}) is \texttt{b}.

\includegraphics{images/tree.png}

All program source code has a tree structure, even though this is usually mostly hidden by the language. Lisp, on the other hand, makes the tree structure fully explicit by using the same notation for source code as for list data (hence all the parentheses).

\subsection{Pair class}
\label{pair-class}
\index{Pair class}

\begin{lstlisting}
catch { ::constcl::Pair destroy }

oo::class create ::constcl::Pair {
  superclass ::constcl::NIL
  variable car cdr constant
  constructor {a d} {
    set car $a
    set cdr $d
    set constant 0
  }
  method name {} {}
  method value {} {
    my show
  }
  method car {} {
    set car
  }
  method cdr {} {
    set cdr
  }
  method set-car! {val} {
    ::constcl::check {my mutable?} {
      Can't modify a constant pair
    }
    set car $val
    self
  }
  method set-cdr! {val} {
    ::constcl::check {my mutable?} {
      Can't modify a constant pair
    }
    set cdr $val
    self
  }
  method mkconstant {} {
    set constant 1
  }
  method constant {} {
    return $constant
  }
  method mutable? {} {
    expr {$constant ? "#f" : "#t"}
  }
  method write {port} {
    $port put "("
    ::constcl::write-pair $port [self]
    $port put ")"
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "(%s)" [::constcl::show-pair [self]]
  }
}
\end{lstlisting}

\subsection{MkPair generator}
\label{mkpair-generator}
\index{MkPair generator}

\texttt{MkPair} generates a Pair object. Shorter form: \texttt{cons}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkPair (internal)} \\
car & a value \\
cdr & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkPair \
  {} ::constcl::Pair new
\end{lstlisting}

\subsection{pair? procedure}
\label{pair-procedure}
\index{pair? procedure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pair? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg pair?

proc ::constcl::pair? {val} {
  typeof? $val Pair
}
\end{lstlisting}

\subsection{show-pair procedure}
\label{showpair-procedure}
\index{show-pair procedure}

Helper procedure to make a string representation of a list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf show-pair (internal)} \\
pair & a pair \\
\textit{Returns:} & a Tcl string \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::show-pair {pair} {
  # take an object and print the car
  # and the cdr of the stored value
  set str {}
  set a [car $pair]
  set d [cdr $pair]
  # print car
  ::append str [$a show]
  if {[T [pair? $d]]} {
    # cdr is a cons pair
    ::append str " "
    ::append str [show-pair $d]
  } elseif {[T [null? $d]]} {
    # cdr is nil
    return $str
  } else {
    # it is an atom
    ::append str " . "
    ::append str [$d show]
  }
  return $str
}
\end{lstlisting}

\subsection{cons procedure}
\label{cons-procedure}
\index{cons procedure}

\texttt{cons} joins two values in a pair; useful in many operations such as pushing a new value onto a list.

Example:

\begin{verbatim}
(cons 'a 'b)              ==>  (a . b)
(cons 'a nil)             ==>  (a)
(cons 'a (cons 'b nil))   ==>  (a b)
\end{verbatim}

\begin{figure}[h!]\includegraphics{images/consing.png}\captionsetup{labelformat=empty}\caption{Examples of consing}\label{fig:examples-of-consing}\end{figure}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf cons (public)} \\
car & a value \\
cdr & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg cons

proc ::constcl::cons {car cdr} {
  MkPair $car $cdr
}
\end{lstlisting}

\subsection{car procedure}
\label{car-procedure}
\index{car procedure}

\texttt{car} gets the contents of the first cell in a pair.

Example:

\begin{verbatim}
(car '(a b))   ==>  a
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf car (public)} \\
pair & a pair \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg car

proc ::constcl::car {pair} {
  $pair car
}
\end{lstlisting}

\subsection{cdr procedure}
\label{cdr-procedure}
\index{cdr procedure}

\texttt{cdr} gets the contents of the second cell in a pair.

Example:

\begin{verbatim}
(cdr '(a b))   ==>  (b)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf cdr (public)} \\
pair & a pair \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg cdr

proc ::constcl::cdr {pair} {
  $pair cdr
}
\end{lstlisting}

\textbf{caar} to \textbf{cddddr}

\texttt{car} and \texttt{cdr} can be combined to form 28 composite access operations.
\index{caar}

\begin{lstlisting}
foreach ads {
  aa
  ad
  da
  dd
  aaa
  ada
  daa
  dda
  aad
  add
  dad
  ddd
  aaaa
  adaa
  daaa
  ddaa
  aada
  adda
  dada
  ddda
  aaad
  adad
  daad
  ddad
  aadd
  addd
  dadd
  dddd
} {
    reg c${ads}r

    proc ::constcl::c${ads}r {pair} "
        foreach c \[lreverse \[split $ads {}\]\] {
            if {\$c eq \"a\"} {
                set pair \[car \$pair\]
            } else {
                set pair \[cdr \$pair\]
            }
        }
        return \$pair
    "

}
\end{lstlisting}

\subsection{set-car! procedure}
\label{setcar-procedure}
\index{set-car"! procedure}

\texttt{set-car!} sets the contents of the first cell in a pair.

Example:

\begin{verbatim}
(let ((pair (cons 'a 'b)) (val 'x))
  (set-car! pair val))                ==>  (x . b)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf set-car! (public)} \\
pair & a pair \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg set-car!

proc ::constcl::set-car! {pair val} {
  $pair set-car! $val
}
\end{lstlisting}

\subsection{set-cdr! procedure}
\label{setcdr-procedure}
\index{set-cdr"! procedure}

\texttt{set-cdr!} sets the contents of the second cell in a pair.

Example:

\begin{verbatim}
(let ((pair (cons 'a 'b)) (val 'x))
  (set-cdr! pair val))                ==>  (a . x)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf set-cdr! (public)} \\
pair & a pair \\
val & a value \\
\textit{Returns:} & a pair \\
\hline
\end{tabular}

\begin{lstlisting}
reg set-cdr!

proc ::constcl::set-cdr! {pair val} {
  $pair set-cdr! $val
}
\end{lstlisting}

\subsection{list? procedure}
\label{list-procedure}
\index{list? procedure}

The \texttt{list?} predicate tests if a pair is part of a proper list, one that ends with NIL. See figure showing proper and improper lists (see page \pageref{fig:-a-proper-list-and-two-improper-ones}).

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg list?

proc ::constcl::list? {val} {
  set visited {}
  if {[T [null? $val]]} {
      return #t
  } elseif {[T [pair? $val]]} {
      return [listp $val]
  } else {
      return #f
  }
}
\end{lstlisting}

\textbf{listp} procedure

\texttt{listp} is a helper procedure that recursively traverses a cons trail to find out if it is cyclic or ends in an atom, which means that the procedure returns false, or if it ends in \texttt{\#NIL}, which means that it returns true.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf listp (internal)} \\
pair & a pair \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{listp}

\begin{lstlisting}
proc ::constcl::listp {pair} {
  upvar visited visited
  if {$pair in $visited} {
    return #f
  }
  lappend visited $pair
  if {[T [null? $pair]]} {
    return #t
  } elseif {[T [pair? $pair]]} {
    return [listp [cdr $pair]]
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{list procedure}
\label{list-procedure1}
\index{list procedure}

\texttt{list} constructs a Lisp list from a number of values.

Example:

\begin{verbatim}
(list 1 2 3)   ==>  (1 2 3)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list (public)} \\
args & some values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg list

proc ::constcl::list {args} {
  if {[llength $args] == 0} {
    return #NIL
  } else {
    set prev #NIL
    foreach obj [lreverse $args] {
      set prev [cons $obj $prev]
    }
    return $prev
  }
}
\end{lstlisting}

\subsection{length procedure}
\label{length-procedure}
\index{length procedure}

\texttt{length} reports the length of a Lisp list.

Example:

\begin{verbatim}
(length '(a b c d))   ==>  4
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf length (public)} \\
pair & a pair \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg length

proc ::constcl::length {pair} {
  check {list? $pair} {
    LIST expected\n([pn] lst)
  }
  MkNumber [length-helper $pair]
}
\end{lstlisting}

\textbf{length-helper} procedure

\texttt{length-helper} is a helper procedure which measures a list recursively.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf length-helper (internal)} \\
pair & a pair \\
\textit{Returns:} & a Tcl number \\
\hline
\end{tabular}
\index{length-helper}

\begin{lstlisting}
proc ::constcl::length-helper {pair} {
  if {[T [null? $pair]]} {
    return 0
  } else {
    return [expr {1 +
      [length-helper [cdr $pair]]}]
  }
}
\end{lstlisting}

\subsection{append procedure}
\label{append-procedure}
\index{append procedure}

\texttt{append} joins lists together.

Example:

\begin{verbatim}
(append '(a b) '(c d))   ==>  (a b c d)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf append (public)} \\
args & some lists \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg append

proc ::constcl::append {args} {
  set prev [lindex $args end]
  foreach r [lreverse [lrange $args 0 end-1]] {
    check {list? $r} {
      LIST expected\n([pn] [$r show])
    }
    set prev [copy-list $r $prev]
  }
  set prev
}
\end{lstlisting}

\textbf{copy-list} procedure

\texttt{copy-list} joins together two lists by recursively consing items from the first list towards the second.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf copy-list (internal)} \\
pair & a pair \\
next & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}
\index{copy-list}

\begin{lstlisting}
proc ::constcl::copy-list {pair next} {
  # TODO only fresh conses in the direct chain to NIL
  if {[T [null? $pair]]} {
    set next
  } elseif {[T [null? [cdr $pair]]]} {
    cons [car $pair] $next
  } else {
    cons [car $pair] [copy-list [cdr $pair] $next]
  }
}
\end{lstlisting}

\subsection{reverse procedure}
\label{reverse-procedure}
\index{reverse procedure}

\texttt{reverse} produces a reversed copy of a Lisp list.

Example:

\begin{verbatim}
(reverse '(a b c))   ==>  (c b a)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf reverse (public)} \\
vals & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg reverse

proc ::constcl::reverse {vals} {
  list {*}[lreverse [splitlist $vals]]
}
\end{lstlisting}

\subsection{list-tail procedure}
\label{listtail-procedure}
\index{list-tail procedure}

Given a list index, \texttt{list-tail} yields the sublist starting from that index.

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (k 3))
  (list-tail lst k))                ==>  (d e f)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list-tail (public)} \\
vals & a Lisp list of values \\
k & a number \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg list-tail

proc ::constcl::list-tail {vals k} {
  if {[T [zero? $k]]} {
    return $vals
  } else {
    list-tail [cdr $vals] [- $k #1]
  }
}
\end{lstlisting}

\subsection{list-ref procedure}
\label{listref-procedure}
\index{list-ref procedure}

\texttt{list-ref} yields the list item at a given index.

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (k 3))
  (list-ref lst k))                 ==>  d
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list-ref (public)} \\
vals & a Lisp list of values \\
k & a number \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg list-ref

proc ::constcl::list-ref {vals k} {
  car [list-tail $vals $k]
}
\end{lstlisting}

\subsection{memq procedure}
\label{memq-procedure}
\index{memq procedure}

\noindent \textbf{memv} procedure

\noindent \textbf{member} procedure

\texttt{memq}, \texttt{memv}, and \texttt{member} return the sublist starting with a given item, or \texttt{\#f} if there is none. They use \texttt{eq?}, \texttt{eqv?}, and \texttt{equal?}, respectively, for the comparison.

Example:

\begin{verbatim}
(let ((lst '(a b c d e f)) (val 'd))
  (memq val lst))                      ==>  (d e f)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf memq (public)} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}

\begin{lstlisting}
reg memq

proc ::constcl::memq {val1 val2} {
  return [member-proc eq? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf memv (public)} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{memv}

\begin{lstlisting}
reg memv

proc ::constcl::memv {val1 val2} {
  return [member-proc eqv? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf member (public)} \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{member}

\begin{lstlisting}
reg member

proc ::constcl::member {val1 val2} {
  return [member-proc equal? $val1 $val2]
}
\end{lstlisting}

\textbf{member-proc} procedure

The \texttt{member-proc} helper procedure does the work for the \texttt{memq}, \texttt{memv}, and \texttt{member} procedures. It works by comparing against the \texttt{car} of the list, then recursively taking the \texttt{cdr} of the list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf member-proc (internal)} \\
epred & an equivalence predicate \\
val1 & a value \\
val2 & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values OR \#f \\
\hline
\end{tabular}
\index{member-proc}

\begin{lstlisting}
proc ::constcl::member-proc {epred val1 val2} {
  switch $epred {
    eq? { set name "memq" }
    eqv? { set name "memv" }
    equal? { set name "member" }
  }
  check {list? $val2} {
    LIST expected\n($name [$val1 show] [$val2 show])
  }
  if {[T [null? $val2]]} {
    return #f
  } elseif {[T [pair? $val2]]} {
    if {[T [$epred $val1 [car $val2]]]} {
      return $val2
    } else {
      return [member-proc $epred $val1 [cdr $val2]]
    }
  }
}
\end{lstlisting}

\subsection{assq procedure}
\label{assq-procedure}
\index{assq procedure}

\noindent \textbf{assv} procedure

\noindent \textbf{assoc} procedure

\texttt{assq}, \texttt{assv}, and \texttt{assoc} scan an association list and return the association pair with a given key, or \texttt{\#f} if there is none. They use \texttt{eq?}, \texttt{eqv?}, and \texttt{equal?}, respectively, for the comparison. They implement lookup in the kind of lookup table known as an association list, or \emph{alist}.

Example:

\begin{verbatim}
(let ((e '((a . 1) (b . 2) (c . 3)))
      (key 'a))
  (assq key e))                        ==> (a . 1)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf assq (public)} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}

\begin{lstlisting}
reg assq

proc ::constcl::assq {val1 val2} {
  return [assoc-proc eq? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf assv (public)} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assv}

\begin{lstlisting}
reg assv

proc ::constcl::assv {val1 val2} {
  return [assoc-proc eqv? $val1 $val2]
}
\end{lstlisting}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf assoc (public)} \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assoc}

\begin{lstlisting}
reg assoc

proc ::constcl::assoc {val1 val2} {
  return [assoc-proc equal? $val1 $val2]
}
\end{lstlisting}

\textbf{assoc-proc} procedure

\texttt{assoc-proc} is a helper procedure which does the work for \texttt{assq}, \texttt{assv}, and \texttt{assoc}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf assoc-proc (internal)} \\
epred & an equivalence predicate \\
val1 & a value \\
val2 & an association list \\
\textit{Returns:} & an association pair or \#f \\
\hline
\end{tabular}
\index{assoc-proc}

\begin{lstlisting}
proc ::constcl::assoc-proc {epred val1 val2} {
  switch $epred {
    eq? { set name "assq" }
    eqv? { set name "assv" }
    equal? { set name "assoc" }
  }
  check {list? $val2} {
    LIST expected\n($name [$val1 show] [$val2 show])
  }
  if {[T [null? $val2]]} {
    return #f
  } elseif {[T [pair? $val2]]} {
    if {[T [pair? [car $val2]]] &&
      [T [$epred $val1 [caar $val2]]]} {
      return [car $val2]
    } else {
      return [assoc-proc $epred $val1 [cdr $val2]]
    }
  }
}
\end{lstlisting}

\section{Strings}
\label{strings}
\index{Strings}

Procedures for dealing with strings of characters. Strings are sequences of characters. After numbers, strings are the most common form of real-world data in computing. Lisp has strings, both constant and mutable, but some of the uses for strings in other languages are instead taken up by symbols.

\subsection{String class}
\label{string-class}
\index{String class}

Strings have the internal representation of a vector of character objects, with the data elements of 1) the vector address of the first element, and 2) the length of the vector. External representation is enclosed within double quotes, with double quotes and backslashes within the string escaped with a backslash.

As a ConsTcl extension, a \texttt{\textbackslash n} pair in the external representation is stored as a newline character. It is restored to \texttt{\textbackslash n} if the string is printed using \texttt{write}, but remains a newline character if the string is printed using \texttt{display}.

\begin{lstlisting}
oo::class create ::constcl::String {
  superclass ::constcl::NIL
  variable data constant
  constructor {v} {
    set v [::string trim $v "\""]
    set v [string map {\\\\ \\ \\\" \" \\n \n} $v]
    set len [::string length $v]
    set vsa [::constcl::vsAlloc $len]
    set idx $vsa
    foreach elt [split $v {}] {
      if {$elt eq " "} {
        set c #\\space
      } elseif {$elt eq "\n"} {
        set c #\\newline
      } else {
        set c #\\$elt
      }
      lset ::constcl::vectorSpace $idx \
        [::constcl::MkChar $c]
      incr idx
    }
    set data [
      ::constcl::cons [N $vsa] [N $len]]
    set constant 0
  }
  method = {str} {
    ::string equal [my value] [$str value]
  }
  method cmp {str} {
    ::string compare [my value] [$str value]
  }
  method length {} {
    ::constcl::cdr $data
  }
  method ref {k} {
    set k [$k numval]
    if {$k < 0 || $k >= [[my length] numval]} {
      ::error "index out of range\n$k"
    }
    lindex [my store] $k
  }
  method store {} {
    set base [[::constcl::car $data] numval]
    set end [expr {[[my length] numval] +
      $base - 1}]
    lrange $::constcl::vectorSpace $base $end
  }
  method value {} {
    join [lmap c [my store] {$c char}] {}
  }
  method set! {k c} {
    if {[my constant]} {
      ::error "string is constant"
    } else {
      set k [$k numval]
      if {$k < 0 ||
        $k >= [[my length] numval]} {
        ::error "index out of range\n$k"
      }
      set base [[::constcl::car $data] numval]
      lset ::constcl::vectorSpace $k+$base $c
    }
    return [self]
  }
  method fill! {c} {
    if {[my constant]} {
      ::error "string is constant"
    } else {
      set base [[::constcl::car $data] numval]
      set len [[my length] numval]
      for {set idx $base} \
        {$idx < $len+$base} \
        {incr idx} {
        lset ::constcl::vectorSpace $idx $c
      }
    }
    return [self]
  }
  method substring {from to} {
    join [lmap c [lrange [my store] \
      [$from numval] [$to numval]] {$c char}] {}
  }
  method mkconstant {} {
    set constant 1
  }
  method constant {} {
    set constant
  }
  method external {} {
    return "\"[
      string map {\\ \\\\ \" \\\" \n \\n} [my value]]\""
  }
  method write {port} {
    $port put [my external]
  }
  method display {port} {
    $port put [my value]
  }
  method show {} {
    my external
  }
}
\end{lstlisting}

\subsection{MkString generator}
\label{mkstring-generator}
\index{MkString generator}

\texttt{MkString} generates a String object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkString (internal)} \\
str & an external rep of a string \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkString \
  {} ::constcl::String new
\end{lstlisting}

\subsection{string? procedure}
\label{string-procedure}
\index{string? procedure}

\texttt{string?} recognizes a string by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg string?

proc ::constcl::string? {val} {
  typeof? $val String
}
\end{lstlisting}

\subsection{make-string procedure}
\label{makestring-procedure}
\index{make-string procedure}

\texttt{make-string} creates a string of \emph{k} characters, optionally filled with \emph{char} characters. If \emph{char} is omitted, the string will be filled with space characters.

Example:

\begin{verbatim}
(let ((k 5))
  (make-string k))        ==>  "     "
(let ((k 5) (char #\A))
  (make-string k char))   ==>  "AAAAA"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-string (public)} \\
k & a number \\
?char? & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg make-string

proc ::constcl::make-string {k args} {
  set i [$k numval]
  if {[llength $args] == 0} {
    set char " "
  } else {
    lassign $args c
    set char [$c char]
  }
  return [MkString [::string repeat $char $i]]
}
\end{lstlisting}

\subsection{string procedure}
\label{string-procedure1}
\index{string procedure}

\texttt{string} constructs a string from a number of Lisp characters.

Example:

\begin{verbatim}
(string #\f #\o #\o)   ==>  "foo"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string (public)} \\
args & some characters \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string

proc ::constcl::string {args} {
  set str {}
  foreach char $args {
    check {::constcl::char? $char} {
      CHAR expected\n([pn] [lmap c $args \
        {$c show}])
    }
    ::append str [$char char]
  }
  return [MkString $str]
}
\end{lstlisting}

\subsection{string-length procedure}
\label{stringlength-procedure}
\index{string-length procedure}

\texttt{string-length} reports a string's length.

Example:

\begin{verbatim}
(string-length "foobar")   ==> 6
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-length (public)} \\
str & a string \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-length

proc ::constcl::string-length {str} {
  check {::constcl::string? $str} {
    STRING expected\n([pn] [$str show])
  }
  return [$str length]
}
\end{lstlisting}

\subsection{string-ref procedure}
\label{stringref-procedure}
\index{string-ref procedure}

\texttt{string-ref} yields the \emph{k}-th character (0-based) in \emph{str}.

Example:

\begin{verbatim}
(string-ref "foobar" 3)   ==> #\b
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-ref (public)} \\
str & a string \\
k & a number \\
\textit{Returns:} & a character \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-ref

proc ::constcl::string-ref {str k} {
  check {::constcl::string? $str} {
    STRING expected\n([pn] [$str show] \
      [$k show])
  }
  check {::constcl::number? $k} {
    INTEGER expected\n([pn] [$str show] \
      [$k show])
  }
  return [$str ref $k]
}
\end{lstlisting}

\subsection{string-set! procedure}
\label{stringset-procedure}
\index{string-set"! procedure}

\texttt{string-set!} replaces the character at \emph{k} with \emph{char} in a non-constant string.

Example:

\begin{verbatim}
(let ((str (string #\f #\o #\o))
      (k 2)
      (char #\x))
  (string-set! str k char))         ==>  "fox"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-set! (public)} \\
str & a string \\
k & a number \\
char & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-set!

proc ::constcl::string-set! {str k char} {
  check {string? $str} {
    STRING expected\n([pn] [$str show] [$k show] \
      [$char show])
  }
  check {number? $k} {
    INTEGER expected\n([pn] [$str show] \
      [$k show] [$char show])
  }
  check {char? $char} {
    CHAR expected\n([pn] [$str show] [$k show] \
      [$char show])
  }
  $str set! $k $char
  return $str
}
\end{lstlisting}

\textbf{string=?}, \textbf{string-ci=?}

\textbf{string<?}, \textbf{string-ci<?}

\textbf{string>?}, \textbf{string-ci>?}

\textbf{string<=?}, \textbf{string-ci<=?}

\textbf{string>=?}, \textbf{string-ci>=?}

\texttt{string=?}, \texttt{string<?}, \texttt{string>?}, \texttt{string<=?}, \texttt{string>=?} and their case insensitive variants \texttt{string-ci=?}, \texttt{string-ci<?}, \texttt{string-ci>?}, \texttt{string-ci<=?}, \texttt{string-ci>=?} compare strings.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string=?, string<?, string>? (public)} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string<=?, string>=? (public)} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-ci=?, string-ci<?, string-ci>? (public)} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-ci<=?, string-ci>=? (public)} \\
str1 & a string \\
str2 & a string \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}
\index{string=?}

\begin{lstlisting}
reg string=?

proc ::constcl::string=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[$str1 value] eq [$str2 value]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string-ci=?}

\begin{lstlisting}
reg string-ci=?

proc ::constcl::string-ci=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[::string tolower [$str1 value]] eq
      [::string tolower [$str2 value]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string<?}

\begin{lstlisting}
reg string<?

proc ::constcl::string<? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[$str1 value] < [$str2 value]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string-ci<?}

\begin{lstlisting}
reg string-ci<?

proc ::constcl::string-ci<? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[::string tolower [$str1 value]] <
      [::string tolower [$str2 value]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string>?}

\begin{lstlisting}
reg string>?

proc ::constcl::string>? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[$str1 value] > [$str2 value]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string-ci>?}

\begin{lstlisting}
reg string-ci>?

proc ::constcl::string-ci>? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[::string tolower [$str1 value]] >
      [::string tolower [$str2 value]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string<=?}

\begin{lstlisting}
reg string<=?

proc ::constcl::string<=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[$str1 value] <= [$str2 value]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string-ci<=?}

\begin{lstlisting}
reg string-ci<=?

proc ::constcl::string-ci<=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[::string tolower [$str1 value]] <=
      [::string tolower [$str2 value]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string>=?}

\begin{lstlisting}
reg string>=?

proc ::constcl::string>=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[$str1 value] >= [$str2 value]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}
\index{string-ci>=?}

\begin{lstlisting}
reg string-ci>=?

proc ::constcl::string-ci>=? {str1 str2} {
  check {string? $str1} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  check {string? $str2} {
    STRING expected\n([pn] [$str1 show] \
      [$str2 show])
  }
  if {[::string tolower [$str1 value]] >=
      [::string tolower [$str2 value]]} {
    return #t
  } else {
    return #f
  }
}
\end{lstlisting}

\subsection{substring procedure}
\label{substring-procedure}
\index{substring procedure}

\texttt{substring} yields the substring of \emph{str} that starts at \emph{start} and ends at \emph{end}.

Example:

\begin{verbatim}
(substring "foobar" 2 4)   ==> "oba"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf substring (public)} \\
str & a string \\
start & a number \\
end & a number \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg substring

proc ::constcl::substring {str start end} {
  check {string? $str} {
    STRING expected\n([pn] [$str show] \
      [$start show] [$end show])
  }
  check {number? $start} {
    NUMBER expected\n([pn] [$str show] \
      [$start show] [$end show])
  }
  check {number? $end} {
    NUMBER expected\n([pn] [$str show] \
      [$start show] [$end show])
  }
  return [MkString [$str substring $start $end]]
}
\end{lstlisting}

\subsection{string-append procedure}
\label{stringappend-procedure}
\index{string-append procedure}

\texttt{string-append} joins strings together.

Example:

\begin{verbatim}
(string-append "foo" "bar")   ==>  "foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-append (public)} \\
args & some strings \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-append

proc ::constcl::string-append {args} {
    MkString [::append --> {*}[lmap arg $args {
      $arg value
    }]]
}
\end{lstlisting}

\subsection{string->list procedure}
\label{stringlist-procedure}
\index{string->list procedure}

\texttt{string->list} converts a string to a Lisp list of characters.

Example:

\begin{verbatim}
(string->list "foo")   ==>  (#\f #\o #\o)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string->list (public)} \\
str & a string \\
\textit{Returns:} & a Lisp list of characters \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->list

proc ::constcl::string->list {str} {
  list {*}[$str store]
}
\end{lstlisting}

\subsection{list->string procedure}
\label{liststring-procedure}
\index{list->string procedure}

\texttt{list->string} converts a Lisp list of characters to a string.

Example:

\begin{verbatim}
(list->string '(#\1 #\2 #\3))   ==> "123"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list->string (public)} \\
list & a Lisp list of characters \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg list->string

proc ::constcl::list->string {list} {
  MkString [::append --> {*}[
    lmap c [splitlist $list] {$c char}]]
}
\end{lstlisting}

\subsection{string-copy procedure}
\label{stringcopy-procedure}
\index{string-copy procedure}

\texttt{string-copy} makes a copy of a string.

Example:

\begin{verbatim}
(let ((str (string-copy "abc"))
      (k 0)
      (char #\x))
  (string-set! str k char))       ==>  "xbc"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-copy (public)} \\
str & a string \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-copy

proc ::constcl::string-copy {str} {
  check {string? $str} {
    STRING expected\n([pn] [$str show])
  }
  return [MkString [$str value]]
}
\end{lstlisting}

\subsection{string-fill! procedure}
\label{stringfill-procedure}
\index{string-fill"! procedure}

\texttt{string-fill!} \emph{str} \emph{char} fills a non-constant string with \emph{char}.

Example:

\begin{verbatim}
(let ((str (string-copy "foobar"))
      (char #\X))
  (string-fill! str char))           ==>  "XXXXXX"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string-fill! (public)} \\
str & a string \\
char & a character \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg string-fill!

proc ::constcl::string-fill! {str char} {
  check {string? $str} {
    STRING expected\n([pn] [$str show] \
      [$char show])
  }
  $str fill! $char
  return $str
}
\end{lstlisting}

\section{Symbols}
\label{symbols}
\index{Symbols}

Symbols are like little immutable strings that are used to refer to things (variables, category labels, collection keys, etc) or for equality comparison against each other.

\subsection{Symbol class}
\label{symbol-class}
\index{Symbol class}

\begin{lstlisting}
oo::class create ::constcl::Symbol {
  superclass ::constcl::NIL
  variable name caseconstant
  constructor {n} {
    ::constcl::idcheck $n
    set name $n
    set caseconstant 0
  }
  method name {} {
    set name
  }
  method value {} {
    set name
  }
  method = {symname} {
    if {$name eq $symname} {
      return #t
    } else {
      return #f
    }
  }
  method constant {} {
    return 1
  }
  method make-case-constant {} {
    set caseconstant 1
  }
  method case-constant {} {
    set caseconstant
  }
  method write {port} {
    $port put [my name]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    my name
  }
}
\end{lstlisting}

\subsection{MkSymbol generator}
\label{mksymbol-generator}
\index{MkSymbol generator}

\texttt{MkSymbol} generates a symbol with a given name. If a symbol with that name already exists, it is returned. Otherwise, a fresh symbol is created. Short form: \texttt{S}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkSymbol (internal)} \\
str & a Tcl string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
proc ::constcl::MkSymbol {str} {
  if {[dict exists $::constcl::symbolTable $str]} {
    return [dict get $::constcl::symbolTable $str]
  } else {
    set sym [::constcl::Symbol new $str]
    dict set ::constcl::symbolTable $str $sym
    return $sym
  }
}
interp alias {} S {} ::constcl::MkSymbol
\end{lstlisting}

\subsection{symbol? procedure}
\label{symbol-procedure}
\index{symbol? procedure}

\texttt{symbol?} recognizes a symbol by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf symbol? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg symbol?

proc ::constcl::symbol? {val} {
  typeof? $val Symbol
}
\end{lstlisting}

\subsection{symbol->string procedure}
\label{symbolstring-procedure}
\index{symbol->string procedure}

\texttt{symbol->string} yields a string consisting of the symbol name, usually lower-cased.

Example:

\begin{verbatim}
(let ((sym 'Foobar))
  (symbol->string sym))   ==>  "foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf symbol->string (public)} \\
sym & a symbol \\
\textit{Returns:} & a string \\
\hline
\end{tabular}

\begin{lstlisting}
reg symbol->string

proc ::constcl::symbol->string {sym} {
  check {symbol? $sym} {
    SYMBOL expected\n([pn] [$sym show])
  }
  if {![$sym case-constant]} {
    set str [MkString [
      ::string tolower [$sym name]]]
  } else {
    set str [MkString [$sym name]]
  }
  $str mkconstant
  return $str
}
\end{lstlisting}

\subsection{string->symbol procedure}
\label{stringsymbol-procedure}
\index{string->symbol procedure}

\texttt{string->symbol} creates a symbol with the name given by the string. The symbol is 'case-constant', i.e. it will not be lower-cased.

Example:

\begin{verbatim}
(define sym (let ((str "Foobar"))
              (string->symbol str)))
sym                                    ==>  Foobar
(symbol->string sym)                   ==>  "Foobar"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf string->symbol (public)} \\
str & a string \\
\textit{Returns:} & a symbol \\
\hline
\end{tabular}

\begin{lstlisting}
reg string->symbol

proc ::constcl::string->symbol {str} {
  check {string? $str} {
    STRING expected\n([pn] [$obj show])
  }
  set sym [MkSymbol [$str value]]
  $sym make-case-constant
  return $sym
}
\end{lstlisting}

\section{Vectors}
\label{vectors}
\index{Vectors}

Vectors are heterogenous structures of fixed length whose elements are indexed by integers. The number of elements that a vector contains (the \emph{length}) is set when the vector is created. Elements can be indexed by integers from zero to length minus one.

\subsection{Vector class}
\label{vector-class}
\index{Vector class}

\begin{lstlisting}
oo::class create ::constcl::Vector {
  superclass ::constcl::NIL
  variable data constant
  constructor {v} {
    if {[T [::constcl::list? $v]]} {
      set len [[::constcl::length $v] numval]
      set vsa [::constcl::vsAlloc $len]
      set idx $vsa
      while {[::constcl::null? $v] ne "#t"} {
        set elt [::constcl::car $v]
        lset ::constcl::vectorSpace $idx $elt
        incr idx
        set v [::constcl::cdr $v]
      }
    } else {
      set len [llength $v]
      set vsa [::constcl::vsAlloc $len]
      set idx $vsa
      foreach elt $v {
        lset ::constcl::vectorSpace $idx $elt
        incr idx
      }
    }
    set data [::constcl::cons [N $vsa] [N $len]]
    set constant 0
  }
  method baseadr {} {
    ::constcl::car $data
  }
  method length {} {
    ::constcl::cdr $data
  }
  method ref {k} {
    set k [$k numval]
    if {$k < 0 || $k >= [[my length] numval]} {
      ::error "index out of range\n$k"
    }
    lindex [my store] $k
  }
  method store {} {
    set base [[my baseadr] numval]
    set end [expr {[[my length] numval] +
      $base - 1}]
    lrange $::constcl::vectorSpace $base $end
  }
  method value {} {
    my store
  }
  method set! {k obj} {
    if {[my constant]} {
      ::error "vector is constant"
    } else {
      set k [$k numval]
      if {$k < 0 || $k >= [[my length] numval]} {
        ::error "index out of range\n$k"
      }
      set base [[my baseadr] numval]
      lset ::constcl::vectorSpace $k+$base $obj
    }
    return [self]
  }
  method fill! {val} {
    if {[my constant]} {
      ::error "vector is constant"
    } else {
      set base [[my baseadr] numval]
      set len [[my length] numval]
      for {set idx $base} \
        {$idx < $len+$base} \
        {incr idx} {
        lset ::constcl::vectorSpace $idx $val
      }
    }
    return [self]
  }
  method mkconstant {} {
    set constant 1
  }
  method constant {} {
    set constant
  }
  method write {port} {
    $port put [my show]
  }
  method display {port} {
    my write $port
  }
  method show {} {
    format "#(%s)" [
      join [lmap val [my value] {$val show}]]
  }
}
\end{lstlisting}

\subsection{MkVector generator}
\label{mkvector-generator}
\index{MkVector generator}

\texttt{MkVector} generates a Vector object.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf MkVector (internal)} \\
vals & a Lisp or Tcl list of values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
interp alias {} ::constcl::MkVector \
  {} ::constcl::Vector new
\end{lstlisting}

\subsection{vector? procedure}
\label{vector-procedure}
\index{vector? procedure}

\texttt{vector?} recognizes vectors by type.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector? (public)} \\
val & a value \\
\textit{Returns:} & a boolean \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector?

proc ::constcl::vector? {val} {
  typeof? $val Vector
}
\end{lstlisting}

\subsection{make-vector procedure}
\label{makevector-procedure}
\index{make-vector procedure}

\texttt{make-vector} creates a vector with a given length and optionally a fill value. If a fill value isn't given, the empty list will be used.

Example:

\begin{verbatim}
(let ((k 3))
  (make-vector k))        ==>  #(() () ())
(let ((k 3) (val #\A))
  (make-vector k val))    ==>  #(#\A #\A #\A)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf make-vector? (public)} \\
k & a number \\
?val? & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg make-vector

proc ::constcl::make-vector {k args} {
  if {[llength $args] == 0} {
    set val #NIL
  } else {
    lassign $args val
  }
  MkVector [lrepeat [$k numval] $val]
}
\end{lstlisting}

\subsection{vector procedure}
\label{vector-procedure1}
\index{vector procedure}

Given a number of Lisp values, \texttt{vector} creates a vector containing them.

Example:

\begin{verbatim}
(vector 'a "foo" 99)   ==>  #(a "foo" 99)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector (public)} \\
args & some values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector

proc ::constcl::vector {args} {
  MkVector $args
}
\end{lstlisting}

\subsection{vector-length procedure}
\label{vectorlength-procedure}
\index{vector-length procedure}

\texttt{vector-length} returns the length of a vector.

Example:

\begin{verbatim}
(vector-length #(a "foo" 99))   ==>  3
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector-length (public)} \\
vec & a vector \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-length

proc ::constcl::vector-length {vec} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec show])
  }
  return [$vec length]
}
\end{lstlisting}

\subsection{vector-ref procedure}
\label{vectorref-procedure}
\index{vector-ref procedure}

\texttt{vector-ref} returns the element of \emph{vec} at index \emph{k} (0-based).

Example:

\begin{verbatim}
(let ((vec #(a "foo" 99)) (k 1))
  (vector-ref vec k))              ==>  "foo"
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector-ref (public)} \\
vec & a vector \\
k & a number \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-ref

proc ::constcl::vector-ref {vec k} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec show] [$k show])
  }
  check {number? $k} {
    NUMBER expected\n([pn] [$vec show] [$k show])
  }
  return [$vec ref $k]
}
\end{lstlisting}

\subsection{vector-set! procedure}
\label{vectorset-procedure}
\index{vector-set"! procedure}

\texttt{vector-set!} sets the element at index \emph{k} to \emph{val} on a vector that isn't constant.

Example:

\begin{verbatim}
(let ((vec #(a b c))
      (k 1)
      (val 'x))
  (vector-set! vec k val))      ==>  *error*
(let ((vec (vector 'a 'b 'c))
      (k 1)
      (val 'x))
  (vector-set! vec k val))      ==>  #(a x c)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector-set! (public)} \\
vec & a vector \\
k & a number \\
val & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-set!

proc ::constcl::vector-set! {vec k val} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec show] [$k show])
  }
  check {number? $k} {
    NUMBER expected\n([pn] [$vec show] [$k show])
  }
  return [$vec set! $k $val]
}
\end{lstlisting}

\subsection{vector->list procedure}
\label{vectorlist-procedure}
\index{vector->list procedure}

\texttt{vector->list} converts a vector value to a Lisp list.

Example:

\begin{verbatim}
(vector->list #(a b c))   ==>  (a b c)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector->list (public)} \\
vec & a vector \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector->list

proc ::constcl::vector->list {vec} {
  list {*}[$vec value]
}
\end{lstlisting}

\subsection{list->vector procedure}
\label{listvector-procedure}
\index{list->vector procedure}

\texttt{list->vector} converts a Lisp list value to a vector.

Example:

\begin{verbatim}
(list->vector '(1 2 3))   ==>  #(1 2 3)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list->vector (public)} \\
list & a Lisp list of values \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg list->vector

proc ::constcl::list->vector {list} {
  vector {*}[splitlist $list]
}
\end{lstlisting}

\subsection{vector-fill! procedure}
\label{vectorfill-procedure}
\index{vector-fill"! procedure}

\texttt{vector-fill!} fills a non-constant vector with a given value.

Example:

\begin{verbatim}
(define vec (vector 'a 'b 'c))
(vector-fill! vec 'x)             ==>  #(x x x)
vec                               ==>  #(x x x)
\end{verbatim}

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf vector-fill! (public)} \\
vec & a vector \\
fill & a value \\
\textit{Returns:} & a vector \\
\hline
\end{tabular}

\begin{lstlisting}
reg vector-fill!

proc ::constcl::vector-fill! {vec fill} {
  check {vector? $vec} {
    VECTOR expected\n([pn] [$vec show] \
      [$fill show])
  }
  $vec fill! $fill
}
\end{lstlisting}

\chapter{Initialization}
\label{initialization}

Initialize the memory space for vector contents.

\begin{lstlisting}
set ::constcl::vectorSpace [lrepeat 1024 #NIL]

set ::constcl::vectorAssign 0

proc ::constcl::vsAlloc {num} {
  # TODO calculate free space
  set va $::constcl::vectorAssign
  incr ::constcl::vectorAssign $num
  return $va
}
\end{lstlisting}

Initialize the symbol table and gensym number.

\begin{lstlisting}
unset -nocomplain ::constcl::symbolTable
set ::constcl::symbolTable [dict create]

set ::constcl::gensymnum 0
\end{lstlisting}

Make it possible to reach (fact 100). Probably more than needed, but this amount can't hurt (used to be 1000).

\begin{lstlisting}
interp recursionlimit {} 2000
\end{lstlisting}

Pre-make a set of constants (e.g. \#NIL, \#t, and \#f) and give them aliases for use in source text.

\begin{lstlisting}
interp alias {} #NIL {} [::constcl::NIL new]

interp alias {} #t {} [::constcl::MkBoolean #t]

interp alias {} #f {} [::constcl::MkBoolean #f]

interp alias {} #-1 {} [N -1]

interp alias {} #0 {} [N 0]

interp alias {} #1 {} [N 1]

interp alias {} #+ {} [::constcl::MkSymbol +]

interp alias {} #- {} [::constcl::MkSymbol -]

interp alias {} #UNS {} [::constcl::Unspecified new]

interp alias {} #UND {} [::constcl::Undefined new]

interp alias {} #EOF {} [::constcl::EndOfFile new]
\end{lstlisting}

Crown the definition register with the queen of numbers (or at least a double-precision floating point approximation).
\index{pi}

\begin{lstlisting}
regvar pi [N 3.1415926535897931]
\end{lstlisting}

In this interpreter, \texttt{nil} does refer to the empty list.
\index{nil}

\begin{lstlisting}
regvar nil #NIL
\end{lstlisting}

\section{Environment startup}
\label{environment-startup}
\index{Environment startup}

On startup, two \texttt{Environment} objects called \texttt{null\_env} (the null environment, not the same as \texttt{null-environment} in Scheme) and \texttt{global\_env} (the global environment) are created.

Make \texttt{null\_env} empty and judgemental: this is where searches for unbound symbols end up.
\index{null\_env}

\begin{lstlisting}
::constcl::Environment create \
  ::constcl::null_env #NIL {}

oo::objdefine ::constcl::null_env {
  method find {sym} {
    self
  }
  method get {sym} {
    ::error "Unbound variable: [$sym name]"
  }
  method set {sym t_ i_} {
    ::error "Unbound variable: [$sym name]"
  }
}
\end{lstlisting}

Meanwhile, \texttt{global\_env} is populated with all the definitions from the definitions register, \texttt{defreg}. This is where top level evaluation happens.
\index{global\_env}

\begin{lstlisting}
namespace eval ::constcl {
  Environment create global_env #NIL {} \
    ::constcl::null_env
  foreach v [dict values $defreg] {
    lassign $v key val
    lassign $val bt in
    global_env bind [S $key] $bt $in
  }
}
\end{lstlisting}

Load the Scheme base to add more definitions to the global environment.
\index{schemebase}

\begin{lstlisting}
pe {(load "schemebase.scm")}
\end{lstlisting}

Thereafter, each time a user-defined procedure is called, a new \texttt{Environment} object is created to hold the bindings introduced by the call, and also a link to the outer environment (the one closed over when the procedure was defined).

\chapter{A Scheme base}
\label{a-scheme-base}

\begin{lstlisting}
; An assortment of procedures to supplement the builtins.
\end{lstlisting}

\subsection{get procedure}
\label{get-procedure}
\index{get procedure}

\texttt{get} is a procedure for picking out values out of property lists. It returns either the value or \texttt{\#f} if the key isn't found.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf get (public)} \\
plist & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a value OR \#f \\
\hline
\end{tabular}

\begin{lstlisting}
(define (get plist key)
  (let ((v (memq key plist)))
    (if v
      (cadr v)
      #f)))
\end{lstlisting}

\subsection{list-find-key procedure}
\label{listfindkey-procedure}
\index{list-find-key procedure}

\texttt{list-find-key} searches for a key in a property list. If it finds it, it returns the (0-based) index of it. If it doesn't find it, it returns -1. It doesn't look at the values.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list-find-key (public)} \\
lst & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-find-key lst key)
  (lfk lst key 0))
\end{lstlisting}

\subsection{lfk procedure}
\label{lfk-procedure}
\index{lfk procedure}

\texttt{lfk} does the work for \texttt{list-find-key}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf lfk (public)} \\
lst & a Lisp list of values \\
key & a symbol \\
count & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (lfk lst key count)
  (if (null? lst)
    -1
    (if (eq? (car lst) key)
      count
      (lfk (cddr lst) key (+ count 2)))))
\end{lstlisting}

\subsection{list-set! procedure}
\label{listset-procedure}
\index{list-set"! procedure}

\texttt{list-set!} works in analogy with \texttt{string-set!}. Given a list and an index, it finds the place to insert a value. Is in real trouble if the index value is out of range.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list-set! (public)} \\
lst & a Lisp list of values \\
idx & a number \\
val & a value \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-set! lst idx val)
  (if (zero? idx)
    (set-car! lst val)
    (list-set! (cdr lst) (- idx 1) val)))
\end{lstlisting}

\subsection{delete! procedure}
\label{delete-procedure}
\index{delete"! procedure}

\texttt{delete!} removes a key-value pair from a property list. Returns the list.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf delete! (public)} \\
lst & a Lisp list of values \\
key & a symbol \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (delete! lst key)
  (let ((idx (list-find-key lst key)))
    (if (< idx 0)
      lst
      (if (= idx 0)
        (set! lst (cddr lst))
        (let ((bef (del-seek lst (- idx 1)))
              (aft (del-seek lst (+ idx 2))))
          (set-cdr! bef aft))))
    lst))
\end{lstlisting}

\subsection{del-seek procedure}
\label{delseek-procedure}
\index{del-seek procedure}

\texttt{del-seek} does the searching for \texttt{delete!}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf del-seek (public)} \\
lst & a Lisp list of values \\
idx & a number \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (del-seek lst idx)
  (if (zero? idx)
    lst
    (del-seek (cdr lst) (- idx 1))))
\end{lstlisting}

\subsection{get-alist procedure}
\label{getalist-procedure}
\index{get-alist procedure}

\texttt{get-alist} is like \texttt{get} but for association lists.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf get-alist (public)} \\
lst & a Lisp list of association pairs \\
key & a symbol \\
\textit{Returns:} & a value \\
\hline
\end{tabular}

\begin{lstlisting}
(define (get-alist lst key)
  (let ((item (assq key lst)))
    (if item
      (cdr item)
      #f)))
\end{lstlisting}

\subsection{pairlis procedure}
\label{pairlis-procedure}
\index{pairlis procedure}

\texttt{pairlis} takes two lists like \texttt{'(a b c)} and \texttt{'(1 2 3)} and produces a list of association pairs \texttt{'((a . 1) (b . 2) (c . 3))}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf pairlis (public)} \\
a & a Lisp list of values \\
b & a Lisp list of values \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
(define (pairlis a b)
  (if (null? a)
    ()
    (cons
      (cons (car a) (car b))
      (pairlis (cdr a) (cdr b)))))
\end{lstlisting}

\subsection{set-alist! procedure}
\label{setalist-procedure}
\index{set-alist"! procedure}

\texttt{set-alist!} updates a value in an association list, given a key.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf set-alist! (public)} \\
lst & a Lisp list of association pairs \\
key & a symbol \\
val & a value \\
\textit{Returns:} & a Lisp list of association pairs \\
\hline
\end{tabular}

\begin{lstlisting}
(define (set-alist! lst key val)
  (let ((item (assq key lst)))
    (if item
      (begin (set-cdr! item val) lst)
      lst)))
\end{lstlisting}

\subsection{fact procedure}
\label{fact-procedure}
\index{fact procedure}

\texttt{fact} calculates the factorial of \emph{n}.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf fact (public)} \\
n & a number \\
\textit{Returns:} & a number \\
\hline
\end{tabular}

\begin{lstlisting}
(define (fact n)
  (if (<= n 1)
    1
    (* n (fact (- n 1)))))
\end{lstlisting}

\subsection{list-copy procedure}
\label{listcopy-procedure}
\index{list-copy procedure}

Returns a newly allocated copy of \emph{list}. This copies each of the pairs comprising \emph{list}. From MIT Scheme.

\noindent\begin{tabular}{ |p{1.9cm} p{8cm}| }
\hline
\rowcolor[HTML]{CCCCCC} \multicolumn{2}{|l|}{\bf list-copy (public)} \\
list & a Lisp list of values \\
\textit{Returns:} & a Lisp list of values \\
\hline
\end{tabular}

\begin{lstlisting}
(define (list-copy list)
  (if (null? list)
    '()
    (cons (car list)
      (list-copy (cdr list)))))
\end{lstlisting}

And that's all. Thank you for joining me on this voyage of exploration.



\printindex
\end{document}

