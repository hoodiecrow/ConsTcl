
H2 Evaluation

MD(
The second thing an interpreter must be able to do is to reduce expressions to
their E{normal form}, or E{evaluate}I{eval}I{evaluator} them. As an example, 2 +
6 and 8 are two expressions that have the same value, but the latter is in
normal form (can't be reduced further) and the former is not.
MD)

h3 Environments

MD(
Before I can talk about evaluation, I need to spend some time on environments.
To simplify, an environment can be seen as a table--or spreadsheet, if you
will--that connects (binds) names to cells, which contain values. The evaluator
looks up values in the environment that way. But there's more to an environment
than just a name-value coupling. The environment also contains references to the
very procedures that make up the Lisp library. And their bindings aren't just a
simple connection: there are several kinds of bindings, from variable binding,
the most common one, to special-form bindings for the fundamental operations of
the interpreter, and syntax bindings for the macros that get expanded to
`normal' code.

There isn't just one environment, either. Every time a non-primitive procedure
is called, a new environment is created which has bindings for the procedure
arguments and which links to the environment that was current when the procedure
was defined (which in turn links backwards all the way to the original global
environment). The evaluator follows into the new environment to evaluate the
body of the procedure there, and then as the evaluator goes back along its call
stack, it sheds environment references.

Not only procedures but binding forms (such as K{let}) create new environments
for the evaluator to work in. As they do that, they also bind variables to
values. Just like with procedures, the added local bindings can shadow bindings
in underlying environments but does not affect them: once the local environment
has been forgotten by the evaluator, the underlying bindings are once more visible.
The other side of the coin is that temporary environments don't have to be
complete: every binding that the evaluator can't find in a temporary environment
it looks for in the parent environment, or its parent and so on.

Environments make up the world the evaluator lives in and are the source of its
values and procedures. The ability of procedure calls and execution of binding
forms to temporarily change the current environment is a powerful one. But still
the evaluator eventually backtracks into the previous environments. 
MD)

IF /images/environments.png Two sample environments

MD(
I will talk some more about the implementation of environments in a later section.
MD)

h3 The evaluator

H4 eval procedure

MD(
The heart of the Lisp interpreter, K{eval} takes a Lisp expression and processes
it according to its form. Symbols to the value they R{refer
  to}{variable-reference}, self-evaluating types to their R{own
    value}{constant-literal}, and expressions that are lists to the value that
    K{eval-form} gets out of them.
MD)

PR(
eval (public);expr expr ?env? env -> val
PR)

CB(
reg eval

proc ::constcl::eval \
  {expr {env ::constcl::global_env}} {
  if {[T [symbol? $expr]]} {
    lookup $expr $env
  } elseif {[T [self-evaluating? $expr]]} {
    set expr
  } elseif {[T [pair? $expr]]} {
    eval-form $expr $env
  } else {
    error "unknown expression type"
  }
}
CB)

MD(
B{self-evaluating?} procedure

Only numeric, string, character, and boolean constants evaluate to themselves.
MD)

PR(
self-evaluating? (internal);val val -> bool
PR)

IX self-evaluating? procedure
CB(
proc ::constcl::self-evaluating? {val} {
  if {[T [number? $val]] || 
    [T [string? $val]] || 
    [T [char? $val]] || 
    [T [boolean? $val]]} {
    return #t
  } else {
    return #f
  }
}
CB)

H4 eval-form procedure
  
MD(
If the K{car} of the expression (the operator) is a symbol, K{eval-form} looks
at the E{binding information} (which the K{reg} R{procedure}{reg-procedure} puts
into the standard library and thereby the global environment) for the symbol.
The E{binding type} tells in general how the expression should be treated: as a
special form, a variable, or a R{macro}{macros}. The E{handling info} gives the
exact procedure that will take care of the expression. If the operator isn't a
symbol, it is evaluated and applied to the evaluated rest of the expression.
MD)

PR(
eval-form (internal);expr expr env env -> val
PR)

CB(
proc ::constcl::eval-form {expr env} {
  set op [car $expr]
  set args [cdr $expr]
  if {[T [symbol? $op]]} {
    lassign [binding-info $op $env] btype hinfo
    switch $btype {
      UNBOUND {
        error "unbound symbol" $op
      }
      SPECIAL {
        $hinfo $expr $env
      }
      VARIABLE {
        invoke $hinfo [eval-list $args $env]
      }
      SYNTAX {
        set expr [$hinfo $expr $env]
        eval $expr $env
      }
      default {
        error "unrecognized binding type" $btype
      }
    }
  } else {
    invoke [eval $op $env] [eval-list $args $env]
  }
}
CB)

MD(
B{binding-info} procedure

The K{binding-info} procedure takes a symbol and returns a list of two items: 1)
the binding type of the symbol, and 2) the handling info that K{eval-form} uses to
handle this symbol.
MD)

PR(
binding-info (internal);op sym env env -> bindfo
PR)

CB(
proc ::constcl::binding-info {op env} {
  set actual_env [$env find $op]
  # parentless envs have #NIL
  if {$actual_env ne "::constcl::null_env"} {
    return [$actual_env get $op]
  } else {
    return [::list UNBOUND {}]
  }
}
CB)

h3 Syntactic forms

MD(
There are nine diffent forms or classes of expressions in Lisp:
MD)

EN variable reference
EN constant literal
EN quotation
EN conditional
EN sequence
EN definition
EN assignment
EN procedure definition
EN procedure call

MD(
The evaluator
recognizes each one by its internal representation and chooses the appropriate
process to evaluate them. The nine forms will be described in the following
sections.
MD)

h3 Variable reference

MD(
EM Example: K{r} ==> 10 (a symbol K{r} is evaluated to what it's bound to)

A variableI{variable}I{variable reference} is an identifier (symbol) bound to a
location in the environment. If an expression consists of an identifier it is
evaluated to the value stored in that location. This is handled by the helper
procedure K{lookup}. It searches the environment chain for the identifier, and
returns the value stored in the location it is bound to.  It is an error to do
lookup on an unbound symbol.
MD)

H4 lookup procedure

PR(
lookup (internal);sym sym env env -> val
PR)

CB(
proc ::constcl::lookup {sym env} {
  lassign [binding-info $sym $env] btype hinfo
  if {$btype eq "VARIABLE"} {
    return $hinfo
  } else {
    error "not a variable name" $sym
  }
}
CB)

TT(
::tcltest::test eval-1.0 {try eval-ing a symbol} -body {
  pew "(let ((r 10)) r)"
} -output "10\n"

::tcltest::test eval-1.2 {try eval-ing an unbound symbol} -body {
  pew "k"
} -returnCodes error -result "not a variable name (k)"
TT)

h3 Constant literal

MD(
EM Example: K{99} ==> 99 (a number evaluates to itself)

Not just numbersI{constant literal} but booleans, characters, and strings
evaluate to themselves, to their innate value. Because of this, they are called
self-evaluating or autoquoting types (see next section).
MD)

TT(
::tcltest::test eval-2.0 {try eval-ing a constant} -body {
  pew "99"
} -output "99\n"
TT)

h3 Quotation

MD(
EM Example: K{(quote r)} ==> K{r} (quotation makes the symbol evaluate to itself, like a constant)

According to the rules of variable reference, a symbol evaluates to its stored
value. Well, sometimes one wishes to use the symbol itself as a value. That is
partly what quotationI{quotation} is for. K{(quote x)} evaluates to the symbol
K{x} itself and not to any value that might be stored under it. This is so
common that there is a shorthand notation for it: K{'x} is interpreted as
K{(quote x)} by the Lisp reader. The argument of K{quote} may be any external
representation of a Lisp object. In this way, for instance a vector or list
constant can be introduced in the program text.
MD)

H4 quote special form

MD(
Syntax: (B{quote} E{datum})

The K{quote} special form is expanded by K{special-quote}.
MD)

PR(
special-quote (internal);expr expr env env -> expr
PR)

CB(
reg special quote

proc ::constcl::special-quote {expr env} {
  cadr $expr
}
CB)

TT(
::tcltest::test eval-3.0 {try eval-ing a quotation} -body {
  pew "'m"
} -output "m\n"

TT)

h3 Conditional

MD(
EM Example: K{(if (> 99 100) (* 2 2) (+ 2 4))} ==> 6

The conditionalI{conditional} form K{if} evaluates a Lisp list of three
expressions. The first, the E{condition}, is evaluated first. If it evaluates to
anything other than K{#f} (false), the second expression (the E{consequent}) is
evaluated and the value returned. Otherwise, the third expression (the
E{alternate}) is evaluated and the value returned. One of the two latter
expressions will be evaluated, and the other will remain unevaluated.

H4 if special form

MD(
Syntax: (B{if} E{cond} E{consequent} ?E{alternate}?)

The K{if} special form is expanded by K{special-if}.
MD)

PR(
special-if (internal);expr expr env env -> val
PR)

CB(
reg special if

proc ::constcl::special-if {expr env} {
  set args [cdr $expr]
  if {[T [null? [cddr $args]]]} {
    /if1 {[eval [car $args] $env]} \
      {eval [cadr $args] $env}
  } else {
    /if {[eval [car $args] $env]} \
      {eval [cadr $args] $env} \
      {eval [caddr $args] $env}
  }
}
CB)

MD(
The two procedures that help the if form out are K{/if} and K{/if1}. The
former takes both a consequent and an alternate, the latter takes only a
consequent.

B{/if} procedure
B{/if1} procedure
MD)

PR(
/if (internal);cond expr consequent expr alternate expr -> val
PR)

PR(
/if1 (internal);cond expr consequent expr -> val
PR)

IX /if
IX /if1
CB(
proc ::constcl::/if {cond conseq altern} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  } else {
    uplevel $altern
  }
}

proc ::constcl::/if1 {cond conseq} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  }
}
CB)

TT(
::tcltest::test eval-4.0 {try eval-ing a conditional} -body {
  pew "(if (= 2 2) (display 'a) (display 'b))"
} -output "a"

::tcltest::test eval-4.0 {try eval-ing a short conditional} -body {
  pew "(if (= 2 3) (display 'a))"
} -output ""
TT)

H4 case special form

MD(
Another conditional form is K{case}. It implements a multi-choice where a single
expression selects between alternatives. The body of the K{case} form consists
of a key-expression and a number of clauses. Each clause has a list of values
and a body. If the key-expression evaluates to a value that occurs in one of the
value-lists (considered in order), that clause's body is evaluated and all other
clauses are ignored.

MD)

MD(
Syntax: (B{case} E{key} E{clause} ...)

Where each E{clause} has the form

((E{datum} ...) E{expression} ...)

The last clause may have the form

(B{else} E{expression} ...)

The K{case} special form is expanded by K{special-case}.
It expands to K{'()} if there are
no clauses (left), and to nested K{if} constructs if there are some.
MD)

MD(
B{special-case} procedure
MD)

PR(
special-case (internal);expr expr env env -> expr
PR)

CB(
reg special case

proc ::constcl::special-case {expr env} {
  set tail [cdr $expr]
  set expr [do-case [car $tail] [cdr $tail] $env]
  eval $expr $env
}
CB)

PT(
H5 caar, cadr, cdar, and the rest

MD(
The K{do-case} procedure uses extensions of the K{car}/K{cdr} operators like
K{caar} and K{cdar}I{car/cdr operators}. K{car}/K{cdr} notation gets really
powerful when combined to form operators from K{caar} to K{cddddr}. One can read
K{caar L} as `the first element of the first element of L', implying that the
first element of K{L} is a list.  K{cdar L} is `the rest of the elements of the
first element of L', and K{cadr L} is `the first element of the rest of the
elements of L' or in layman's terms, the second element of L.
MD)
PT)

PT(
H5 Quasiquote

MD(
In this and many other special form and macro form expanders I use a
quasiquoteI{quasiquote} construct to lay out how the form is to be expanded. A
quasiquote starts with a backquote (K{`}) instead of the single quote that
precedes regular quoted material. A quasiquote allows for `unquoting' of
selected parts: this is notated with a comma (K{,}).  K{`(foo ,bar baz)} is very
nearly the same as K{('foo bar 'baz)}.  In both cases K{foo} and K{baz} are
constants while K{bar} is a variable which will be evaluated.  Like in
K{do-case} here, a quasiquote serves well as a templating mechanism. The
variables in the quasiquote need to be a part of the environment in which the
quasiquote is expanded: I use K{/define} to bind them in a temporary
environment.
MD)
PT)

MD(
B{do-case} procedure
MD)

PR(
do-case (internal);keyexpr expr clauses lexprs env env -> expr
PR)

IX do-case procedure
CB(
proc ::constcl::do-case {keyexpr clauses env} {
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set keyl [caar $clauses]
    set body [cdar $clauses]
    set keyl [list [S memv] $keyexpr \
        [list [S quote] $keyl]]
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the condition
      if {[T [eq? [caar $clauses] [S else]]]} {
        set keyl #t
      }
    }
    set env [MkEnv $env]
    /define [S keyl] $keyl $env
    /define [S body] $body $env
    /define [S rest] [
      do-case $keyexpr [cdr $clauses] $env] $env
    set qq "`(if ,keyl
               (begin ,@body)
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
CB)

TT(
::tcltest::test eval-5.0 {expand case macro} -body {
    set x [p "(case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite))"]
    set x [::constcl::do-case [::constcl::cadr $x] [::constcl::cddr $x] ::constcl::global_env]
    w $x
} -output "(if (memv (* 2 3) (quote (2 3 5 7))) (begin (quote prime)) (if (memv (* 2 3) (quote (1 4 6 8 9))) (begin (quote composite)) (quote ())))\n"

::tcltest::test eval-5.1 {run case macro} -body {
    pew "(case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite))"
} -output "composite\n"

::tcltest::test eval-5.2 {expand case macro} -body {
    set x [p "(case (car (quote (c d))) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant))"]
    set x [::constcl::do-case [::constcl::cadr $x] [::constcl::cddr $x] ::constcl::global_env]
    w $x
} -output "(if (memv (car (quote (c d))) (quote (a e i o u))) (begin (quote vowel)) (if (memv (car (quote (c d))) (quote (w y))) (begin (quote semivowel)) (if #t (begin (quote consonant)) (quote ()))))\n"

::tcltest::test eval-5.3 {run case macro} -body {
    pew "(case (car (quote (c d))) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant))"
} -output "consonant\n"
TT)

H4 cond special form

MD(
K{cond} is the third conditional form.
The K{cond} form has a list of clauses, each with a predicate and a body. The
clauses is considered in order, and if a predicate evaluates to something other
than K{#f} the body is evaluated and the remaining clauses are ignored.
MD)

MD(
Syntax: (B{cond} E{clause} ...)

Where each E{clause} has the form

(E{test} E{expression} ...)

or

(E{test} B{=>} E{recipient})

where E{recipient} is a procedure that accepts one argument, which is evaluated
with the result of the predicate as argument.

The last clause may have the form

(B{else} E{expression} ...)

The K{cond} special form is expanded by K{special-cond}.
It expands to K{'()} if there are
no clauses (left), and to nested K{if} constructs if there are some.
MD)

B{special-cond} procedure
MD)

PR(
special-cond (internal);expr expr env env -> expr
PR)

CB(
reg special cond

proc ::constcl::special-cond {expr env} {
  set expr [do-cond [cdr $expr] $env]
  eval $expr $env
}
CB)

MD(
B{do-cond} procedure

K{do-cond} is called recursively for every clause of the K{cond} form. It chops
up the clause into predicate and body. In the last clause, the predicate is allowed to be K{else} (which gets
translated to K{#t}). If there is no body, the body is set to the predicate. The
form is expanded to a recursive K{if} form.
MD)

PR(
do-cond (internal);tail lexprs env env -> expr
PR)

IX do-cond procedure
CB(
proc ::constcl::do-cond {tail env} {
  set clauses $tail
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set pred [caar $clauses]
    set body [cdar $clauses]
    if {[T [symbol? [car $body]]] &&
        [[car $body] name] eq "=>"} {
      set body [list [caddar $clauses] $pred]
    } else {
      if {[[length $body] numval] == 1} {
        set body [car $body]
      } elseif {[[length $body] numval] > 1} {
        set body [cons [S begin] $body]
      }
    }
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the predicate
      if {[T [eq? $pred [S else]]]} {
        set pred #t
      }
    }
    if {[T [null? $body]]} {
        set body $pred
    }
    set env [MkEnv $env]
    /define [S pred] $pred $env
    /define [S body] $body $env
    /define [S rest] [
      do-cond [cdr $clauses] $env] $env
    set qq "`(if ,pred
               ,body
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
CB)

TT(
::tcltest::test eval-6.0 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (+ 4 2) (if (> 1 2) (+ 5 5) (if #t (- 8 5) (quote ()))))\n"

::tcltest::test eval-6.1 {run cond macro} -body {
    pew "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"
} -output "3\n"

::tcltest::test eval-6.2 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (+ 4 2) (if (> 1 2) (+ 5 5) (quote ())))\n"

::tcltest::test eval-6.3 {run cond macro} -body {
    pew "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"
} -output "()\n"

::tcltest::test eval-6.4 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2) (+ 3 5)) ((> 1 2) (+ 5 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (begin (+ 4 2) (+ 3 5)) (if (> 1 2) (+ 5 5) (quote ())))\n"

::tcltest::test eval-6.5 {expand cond macro} -body {
  p {(define alist '((a . 1) (b . 2)))}
    set x [p "(cond ((assv 'b alist) => cdr) (else #f))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (assv (quote b) alist) (cdr (assv (quote b) alist)) (if #t #f (quote ())))\n"

::tcltest::test eval-6.6 {run cond macro} -body {
    pew "(cond ((assv 'b '((a . 1) (b . 2))) => cdr) (else #f))"
} -output "2\n"

TT)

h3 Sequence

MD(
EM Example: K{(begin (define r 10) (* r r))} ==> 100

When expressions are evaluated in sequenceI{sequence}, the order is important
for two reasons. If the expressions have any side effects, they happen in the
same order of sequence. Also, if expressions are part of a pipeline of
calculations, then they need to be processed in the order of that pipeline.

As part of the processing of sequences E{local defines} are resolved, acting on
expressions of the form K{(begin (define ...} when in a local environment. See
the part about R{resolving local defines}{resolving-local-defines}.

The following forms have an implicit K{begin} in their bodies and the use of
K{begin} is therefore unnecessary with them:

K{case}, K{cond}, K{define} (“procedure define” only), K{lambda}, K{let}, K{let*}, K{letrec}.
MD)

H4 begin special form

MD(
Syntax: (B{begin} E{expression} ...)

The K{begin} special form is expanded by K{special-begin}.
MD)

PR(
special-begin (internal);expr expr env env -> val
PR)

CB(
reg special begin

proc ::constcl::special-begin {expr env} {
  if {$env ne "::constcl::global_env" && 
    [T [pair? [cadr $expr]]] &&
    [T [eq? [caadr $expr] [S define]]]
  } {
    set expr [resolve-local-defines $expr]
    eval $expr $env
  } else {
    /begin [cdr $expr] $env
  }
}
CB)

MD(
B{/begin} procedure

The
K{/begin} helper procedure takes a Lisp list of expressions and evaluates them
in sequence, returning the value of the last one.
MD)

PR(
/begin (internal);exps lexprs env env -> val
PR)

IX /begin
CB(
proc ::constcl::/begin {exps env} {
  /if {[pair? $exps]} {
    /if {[pair? [cdr $exps]]} {
      eval [car $exps] $env
      return [/begin [cdr $exps] $env]
    } {
      return [eval [car $exps] $env]
    }
  } {
    return #NIL
  }
}
CB)

TT(
::tcltest::test eval-7.0 {try eval-ing a sequence} -body {
  pew "(begin (display 'a) (display 'b))"
} -output "ab"

::tcltest::test eval-7.1 {try eval-ing a sequence} -body {
  set x [p "(begin (define a 3) (define b 4) (display a) (display b))"]
  set v [::constcl::eval $x [::constcl::MkEnv ::constcl::global_env]]
} -output "34"
TT)

h3 Definition

MD(
EM Example: K{(define r 10)} ==> ... (a definition doesn't evaluate to anything)

We've already seen the relationship between symbols and values. Through
(variable) definitionI{variable definition}I{definition}, a symbol is bound to a
value (or rather to the location the value is in), creating a variable. The
K{/define} helper procedure adds a variable to the current environment. It first
checks that the symbol name is a valid identifier, then it updates the
environment with the new binding.
MD)

H4 define special form

MD(
Syntax: either

(B{define} E{variable} E{expression})

(B{define} (E{variable} E{formals}) E{body})

(where E{formals} is a proper or dotted list of identifiers; equivalent form:)

(B{define} E{variable} (B{lambda} (E{formals}) E{body})).

or

(B{define} (E{variable} . E{formal}) E{body})

(where E{formal} is a single identifier; equivalent form:)

(B{define} E{variable} (B{lambda} E{formal} E{body}))

E{body} should be one or more expressions.

The K{define} special form is expanded by K{special-define}.
MD)

PR(
special-define (internal);expr expr env env -> none
PR)

CB(
reg special define

proc ::constcl::special-define {expr env} {
  set expr [rewrite-define $expr $env]
  set sym [cadr $expr]
  set val [eval [caddr $expr] $env]
  /define $sym $val $env
}
CB)

MD(
B{rewrite-define} procedure

K{define} has two variants, one of which requires some rewriting. It's the one
with an implied K{lambda} call, the one that defines a procedure. 

(define (E{symbol} E{formals}) E{body})

is transformed by K{rewrite-define} into

(define E{symbol} (lambda E{formals} E{body}))

which conforms better to K{eval}'s standard of (define E{symbol} E{value}).
The other variant passes through K{rewrite-define} unchanged.
MD)

PR(
rewrite-define (internal);expr expr env env -> expr
PR)

IX rewrite-define
CB(
proc ::constcl::rewrite-define {expr env} {
  if {[T [pair? [cadr $expr]]]} {
    set tail [cdr $expr]
    set env [::constcl::MkEnv $env]
    /define [S tail] $tail $env
    set qq "`(define ,(caar tail)
               (lambda ,(cdar tail) ,@(cdr tail)))"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
  } 
  return $expr
}
CB)

TT(
::tcltest::test eval-8.0 {define} -body {
    w [::constcl::rewrite-define [p {(define (foo a b) (+ a b) (* a b))}] ::constcl::global_env]
} -output "(define foo (lambda (a b) (+ a b) (* a b)))\n"

::tcltest::test eval-8.1 {define} -body {
    w [::constcl::rewrite-define [p "(define (fib n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))"] ::constcl::global_env]
} -output "(define fib (lambda (n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))\n"

::tcltest::test eval-8.2 {define} -body {
    w [::constcl::rewrite-define [p "(define (f) (define r 20) (* r r))"] ::constcl::global_env]
} -output "(define f (lambda () (define r 20) (* r r)))\n"

::tcltest::test eval-8.3 {define} -body {
    w [::constcl::rewrite-define [p "(define (list-find-key lst key)\n(lfk lst key 0))"] ::constcl::global_env]
} -output "(define list-find-key (lambda (lst key) (lfk lst key 0)))\n"

::tcltest::test eval-8.4 {define} -body {
    w [::constcl::rewrite-define [p "(define (f . r) (* r r))"] ::constcl::global_env]
} -output "(define f (lambda r (* r r)))\n"

TT)

MD(
B{/define} procedure
MD)

PR(
/define (internal);sym sym val val env env -> none
PR)

IX /define
CB(
proc ::constcl::/define {sym val env} {
  varcheck [idcheck [$sym name]]
  $env bind $sym VARIABLE $val
  return
}
CB)

TT(
::tcltest::test eval-9.0 {try eval-ing a define} -body {
  pew "(define r 10)"
  pew "r"
} -output "10\n"

::tcltest::test eval-9.1 {try eval-ing a define, with an inappropriate symbol} -body {
  pew "(define let 10)"
} -returnCodes error -result "Variable name is reserved: let"

::tcltest::test eval-9.2 {try eval-ing a define, with an inappropriate symbol} -body {
  pew "(define +foo 10)"
} -returnCodes error -result "Identifier expected (+foo)"
TT)

h3 Assignment

MD(
EM Example: K{(set! r 20)} ==> 20 (K{r} is a bound symbol, so it's allowed to assign to it)

Once a variable has been created, the value at the location it is bound to can
be changed (hence the name `variable', something that can vary). The
process is called assignment. The K{set!} special form does assignment:
it modifies an existing variable that is bound somewhere in the environment
chain. It finds the variable's environment and updates the binding. It returns
the value, so calls to K{set!} can be chained: K{(set! foo (set! bar 99))} sets
both variables to 99. By Scheme convention, procedures that modify variables
have `!' at the end of their name.
MD)

H4 set"! special form

MD(
Syntax: (B{set!} E{variable} E{expression})

The K{set!} special form is expanded by K{special-set!}.
MD)

PR(
special-set! (internal);expr expr env env -> val
PR)

CB(
reg special set!

proc ::constcl::special-set! {expr env} {
  set args [cdr $expr]
  set var [car $args]
  set val [eval [cadr $args] $env]
  [$env find $var] assign $var VARIABLE $val
  set val
}
CB)

TT(
::tcltest::test eval-10.0 {try eval-ing an assignment} -body {
  unbind [S r]
  pew "(define r 10)"
  pew "(set! r 20)"
  pew "r"
} -output "20\n20\n"
TT)

h3 Procedure definition

MD(
EM Example: K{(lambda (r) (* r r))} ==> K{::oo::Obj3601} (it will be a different object each time)

In Lisp, procedures are values just like numbers or characters. They can be
definedI{procedure definition} as the value of a symbol, passed to other
procedures, and returned from procedures. One difference from most values is
that procedures need to be specified.  Two questions must answered: what is the
procedure meant to do? The code that does that will form the E{body} of the
procedure. Also, what, if any, items of data (E{parameters}) will have to be
provided to the procedure to make it possible to calculate its result?

As an example, imagine that we want to have a procedure that calculates the
square (K{x * x}) of a given number. In Lisp, expressions are written with
the operator first and then the operandsI{operator operand order}: K{(* x x)}.
That is the body of the procedure. Now, what data will we have to provide to the
procedure to make it work? A value stored in the variable K{x} will do. It's
only a single variable, but by custom we need to put it in a list: K{(x)}. The
operator that creates procedures is called K{lambda}I{lambda}, and we create the
function with K{(lambda (x) (* x x))}.

One more step is needed before we can use the procedure. It must have a name. We
could define it like this: K{(define square (lambda (x) (* x x)))} but there is
actually a shortcut notation for it: K{(define (square x) (* x x))}.

Now, K{square} is pretty tame. How about the K{hypotenuse} procedure? K{(define
  (hypotenuse a b) (sqrt (+ (square a) (square b))))}. It calculates the square
  root of the sum of two squares.

The lambda special form makes a R{Procedure}{control} object. First
it needs to convert the Lisp list K{body}. It is packed inside a K{begin} if it
has more than one expression (K{S begin} stands for `the symbol begin'.), and
taken out of its list if not. The Lisp list K{formals} is passed on as it is.
MD)

PT(
H5 Scheme formal parameters lists

MD(
A Scheme formals listI{formals list} is either:
MD)

IT An E{empty list}, K{()}, meaning that no arguments are accepted,
IT A E{proper list}, K{(a b c)}, meaning it accepts three arguments, one in each symbol,
IT A E{symbol}, K{a}, meaning that all arguments go into K{a}, or
IT A E{dotted list}, K{(a b . c)}, meaning that two arguments go into K{a} and K{b}, and the rest into K{c}.

PT)

H4 lambda special form

MD(
Syntax: (B{lambda} E{formals} E{body})

where E{body} is one or more expressions.

The K{lambda} special form is expanded by K{special-lambda}.
MD)

PR(
special-lambda (internal);expr expr env env -> proc
PR)

CB(
reg special lambda

proc ::constcl::special-lambda {expr env} {
  set args [cdr $expr]
  set formals [car $args]
  set body [cdr $args]
  if {[[length $body] numval] > 1} {
    set body [cons [S begin] $body]
  } else {
    set body [car $body]
  }
  return [MkProcedure $formals $body $env]
}
CB)

TT(
::tcltest::test eval-11.0 {try eval-ing a procedure definition} -body {
  pew "(define (square x) (* x x))"
  pew "(square 20)"
} -output "400\n"
TT)

h3 Procedure call

MD(
EM Example: K{(+ 1 6)} ==> 7

Once we have procedures, we can callI{procedure call} them to have their
calculations performed and yield results. The procedure name is put in the
operator position at the front of a list, and the operands follow in the rest of
the list. Our K{square} procedure would be called for instance like this:
K{(square 11)}, and it will return 121.

K{invoke} arranges for a procedure to be called with each of the values in
the E{argument list} (the list of operands). It checks if E{pr} really is a
procedure, and determines whether to call E{pr} as an object or as a Tcl command.
MD)

H4 invoke procedure

PR(
invoke (internal);pr proc vals lvals -> invoke
PR)

CB(
proc ::constcl::invoke {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([$pr show] val ...)
  }
  if {[info object isa object $pr]} {
    $pr call {*}[splitlist $vals]
  } else {
    $pr {*}[splitlist $vals]
  }
}
CB)

TT(
::tcltest::test eval-12.0 {try eval-ing a procedure call} -body {
  pew "(* 5 20)"
} -output "100\n"

::tcltest::test eval-12.1 {try triggering a check} -body {
    ::constcl::invoke #NIL [list #NIL #NIL]
} -returnCodes error -result "PROCEDURE expected\n(() val ...)"
TT)

H3 Binding forms

MD(
The binding forms are not fundamental the way the earlier nine forms are. They
are an application of a combination of the procedure definition form and a
procedure call. But their use is sufficiently distinguished to earn them their
own heading.

MD)

H4 let special form

MD(
Syntax: (B{let} ((E{variable} E{init}) ...) E{body})

or

(B{let} E{variable} ((E{variable} E{init}) ...) E{body})

where E{body} is one or more expressions.

The K{let} special form (both forms) is expanded by K{special-let}.
They are ultimately rewritten to K{lambda} constructs and evaluated as such.
MD)

PR(
special-let (internal);expr expr env env -> expr
PR)

CB(
reg special let

proc ::constcl::special-let {expr env} {
  if {[T [symbol? [cadr $expr]]]} {
    set expr [rewrite-named-let $expr $env]
  }
  set expr [rewrite-let $expr $env]
  eval $expr $env
}
CB)

MD(
B{rewrite-named-let} procedure

The rewriter for named K{let} chops up the expression into E{variable},
E{bindings}, and E{body}. It creates a dictionary with the E{variable} as key
and K{#f} as value. Then it fills up the dictionary with variable/value pairs
from the E{bindings}. It uses the dictionary to build a declaration list for a
K{let} form, a variable list for a K{lambda} form, and a procedure call. Then it
assembles a K{let} form with the declaration list and a body consisting of an
assignment and the procedure call.  The assignment binds the variable to a
K{lambda} form with the varlist and the original E{body}. The K{let} form is
returned, meaning that the primary expansion of the named K{let} is a regular
K{let} form.
MD)

PR(
rewrite-named-let (internal);expr expr env env -> expr
PR)

IX rewrite-named-let procedure
CB(
proc ::constcl::rewrite-named-let {expr env} {
  # named let
  set tail [cdr $expr]
  set variable [car $tail]
  set bindings [cadr $tail]
  set body [cddr $tail]
  set vars [dict create $variable #f]
  parse-bindings vars $bindings
  set env [MkEnv $env]
  /define [S decl] [list {*}[dict values [
    dict map {k v} $vars {list $k $v}]]] $env
  /define [S variable] $variable $env
  /define [S varlist] [list {*}[lrange [
    dict keys $vars] 1 end]] $env
  /define [S body] $body $env
  /define [S call] [list {*}[
    dict keys $vars]] $env
  set qq "`(let ,decl
             (set!
               ,variable
                 (lambda ,varlist ,@body)) ,call)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
CB)

MD(
B{rewrite-let} procedure

The rewriter for regular K{let} chops up the original expression into
E{bindings} and E{body}. It creates an empty dictionary and fills it up with
variable/value pairs from the E{bindings}. Then it builds a K{lambda} operator
form with the variable list, the E{body}, and the value list. The K{lambda} call
is returned as the expansion of the regular K{let} form.
MD)

PR(
rewrite-let (internal);expr expr env env -> expr
PR)

IX rewrite-let procedure
CB(
proc ::constcl::rewrite-let {expr env} {
  # regular let
  set tail [cdr $expr]
  set bindings [car $tail]
  set body [cdr $tail]
  set vars [dict create]
  parse-bindings vars $bindings
  set env [MkEnv $env]
  /define [S varlist] [list {*}[
    dict keys $vars]] $env
  /define [S body] $body $env
  /define [S vallist] [list {*}[
    dict values $vars]] $env
  set qq "`((lambda ,varlist ,@body)
             ,@vallist)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
CB)

MD(
B{parse-bindings} procedure

K{parse-bindings} is a helper procedure that traverses a K{let} bindings list
and extracts variables and values, which it puts in a dictionary. It throws an
error if a variable occurs more than once.
MD)

PR(
parse-bindings (internal);name name bindings lvals -> none
PR)

IX parse-bindings procedure
CB(
proc ::constcl::parse-bindings {name bindings} {
  upvar $name vars
  foreach binding [splitlist $bindings] {
    set var [car $binding]
    set val [cadr $binding]
    if {$var in [dict keys $vars]} {
        ::error "'[$var name]' occurs more than once"
    }
    dict set vars $var $val
  }
  return
}
CB)

TT(
::tcltest::test eval-13.3 {expand let macro} -body {
    set x [p "(let ((x 10)) (* x x))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
    set x [p "(let ((x 10) (y 5)) (* x y))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
    set x [p "(let ((x 10) (y 5)) (define z 7) (* x y z))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
} -output "((lambda (x) (* x x)) 10)\n((lambda (x y) (* x y)) 10 5)\n((lambda (x y) (define z 7) (* x y z)) 10 5)\n"

::tcltest::test eval-13.4 {run let macro} -body {
    pew "(let ((x 10)) (* x x))"
    pew "(let ((x 10) (y 5)) (* x y))"
    pew "(let ((x 10) (y 5) (z 7)) (+ 2 3) (* x y z))"
} -output "100\n50\n350\n"

::tcltest::test eval-13.5 {expand named let macro} -body {
    set x [p {(let loop ((lst lst) (result '()))
    (if (null? lst)
        (reverse result)
        (let ((item (car lst)))
          (loop (cdr lst)
                (if (fn item) result (cons item result))))))}]
    set x [::constcl::rewrite-named-let $x ::constcl::global_env]
    w $x
} -output "(let ((loop #f) (lst lst) (result (quote ()))) (set! loop (lambda (lst result) (if (null? lst) (reverse result) (let ((item (car lst))) (loop (cdr lst) (if (fn item) result (cons item result))))))) (loop lst result))\n"

::tcltest::test eval-13.7 {expand let macro} -body {
    set x [p "(let ((vec #(a b c)) (k 1)) (list vec k))"]
    set x [::constcl::rewrite-let $x ::constcl::global_env]
    w $x
} -output "((lambda (vec k) (list vec k)) #(a b c) 1)\n"

::tcltest::test eval-13.8 {run let macro} -body {
    pew "(let ((vec '#(a b c)) (k 1)) (list vec k))"
} -output "(#(a b c) 1)\n"

::tcltest::test eval-13.9 {trigger error in let macro} -body {
    pew "(let ((a 0) (a 1)) (* a a))"
} -returnCodes error -result "'a' occurs more than once"

TT)

H4 letrec special form

MD(
The K{letrec} form is similar to K{let}, but the bindings are created before the
values for them are calculated. This means that one can define mutually
recursive procedures.
MD)

MD(
Syntax: (B{letrec} ((E{variable} E{init}) ...) E{body})

where E{body} is one or more expressions.

The K{letrec} special form is expanded by K{special-letrec}.
MD)

PR(
special-letrec (internal);expr expr env env -> expr
PR)

CB(
reg special letrec

proc ::constcl::special-letrec {expr env} {
  set expr [rewrite-letrec $expr $env]
  eval $expr $env
}
CB)

MD(
B{rewrite-letrec} procedure
MD)

PR(
rewrite-letrec (internal);expr expr env env -> expr
PR)

IX rewrite-letrec procedure
CB(
proc ::constcl::rewrite-letrec {expr env} {
  # regular let
  set tail [cdr $expr]
  set bindings [car $tail]
  set body [cdr $tail]
  set vars [dict create]
  parse-bindings vars $bindings
  foreach {key val} $vars {
    dict set outer $key [list [S quote] #UND]
    dict set inner [set g [gensym "g"]] $val
    dict set assigns $key $g
  }
  set env [MkEnv $env]
  /define [S outervars] [
    list {*}[dict keys $outer]] $env
  /define [S outervals] [
    list {*}[dict values $outer]] $env
  /define [S innervars] [
    list {*}[dict keys $inner]] $env
  /define [S innervals] [
    list {*}[dict values $inner]] $env
  /define [S assigns] [list {*}[lmap {k v} $assigns {
      list [S set!] $k $v
    }]] $env
  /define [S body] $body $env
  set qq "`((lambda ,outervars
             ((lambda ,innervars ,@assigns) ,@innervals)
             ,@body) ,@outervals)"
  set expr [expand-quasiquote [parse $qq] $env]
  $env destroy
  return $expr
}
CB)

TT(
::tcltest::test eval-14.0 {expand letrec} -body {
  set x [p "(letrec ((a 0) (b 1)) (- a b))"]
  set x [::constcl::rewrite-letrec $x ::constcl::global_env]
  w $x
} -match glob -output {((lambda (a b) ((lambda (g<[0-9]*> g<[0-9]*>) (set! a g<[0-9]*>) (set! b g<[0-9]*>)) 0 1) (- a b)) (quote #<undefined>) (quote #<undefined>))*}

::tcltest::test eval-14.1 {run letrec} -body {
  pew "(letrec ((a 0) (b 1)) (- a b))"
} -output "-1\n"

::tcltest::test eval-14.2 {run letrec} -body {
  pew {(letrec ((even?
          (lambda (n)
            (if (zero? n)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                #f
                (even? (- n 1))))))
  (even? 88))}
} -output "#t\n"
TT)

H4 let* special form

MD(
The K{let*} form is similar to K{let}, but the items in the binding list are
considered sequentially, so the initializer in the second or later binding can
reference the first binding, etc.
MD)

MD(
Syntax: (B{let*} ((E{variable} E{init}) ...) E{body})

where E{body} is one or more expressions.

The K{let*} special form is expanded by K{special-let*}.
MD)

PR(
special-let* (internal);expr expr env env -> expr
PR)

CB(
reg special let*

proc ::constcl::special-let* {expr env} {
  set tail [cdr $expr]
  set expr [rewrite-let* [car $tail] [cdr $tail] $env]
  set expr [rewrite-let $expr $env]
  eval $expr $env
}
CB)

MD(
B{rewrite-let*} procedure
MD)

PR(
rewrite-let* (internal);bindings lvals body lexprs env env -> expr
PR)

IX rewrite-let* procedure
CB(
proc ::constcl::rewrite-let* {bindings body env} {
  set env [MkEnv $env]
  if {$bindings eq "#NIL"} {
    /define [S body] $body $env
    set qq "`(begin ,@body)"
    set expr [expand-quasiquote [parse $qq] $env]
  } else {
    /define [S binding] [car $bindings] $env
    /define [S rest] [rewrite-let* [cdr $bindings] \
      $body $env] $env
    set qq "`(let (,binding) ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
  }
  $env destroy
  return $expr
}
CB)

TT(
::tcltest::test eval-15.0 {expand let*} -body {
  set x [p "(let* ((a 2) (b (+ a 1))) (* a b))"]
  set bind [::constcl::cadr $x]
  set body [::constcl::cddr $x]
  set x [::constcl::rewrite-let* $bind $body ::constcl::global_env]
  w $x
} -output "(let ((a 2)) (let ((b (+ a 1))) (begin (* a b))))\n"

::tcltest::test eval-15.1 {run let*} -body {
  pew "(let* ((a 2) (b (+ a 1))) (* a b))"
} -output "6\n"

TT)

MD(
B{splitlist} procedure

K{splitlist} converts a Lisp list to a Tcl list with Lisp objects.
MD)

PR(
splitlist (internal);vals lvals -> tvals
PR)

IX splitlist
CB(
proc ::constcl::splitlist {vals} {
  set result {}
  while {[T [pair? $vals]]} {
    lappend result [car $vals]
    set vals [cdr $vals]
  }
  return $result
}
CB)

MD(
B{eval-list} procedure

K{eval-list} successively evaluates the elements of a Lisp list and returns the
collected results as a Lisp list.
MD)

PR(
eval-list (internal);exps lexprs env env -> lvals
PR)

IX eval-list
CB(
proc ::constcl::eval-list {exps env} {
  # don't convert to /if, it breaks (fact 100)
  if {[T [pair? $exps]]} {
    return [cons [eval [car $exps] $env] \
      [eval-list [cdr $exps] $env]]
  } {
    return #NIL
  }
}
CB)

TT(

::tcltest::test eval-16.0 {lambda parameter lists} -body {
    pew {((lambda (x y z) (list x y z)) 3 4 5)}
    pew {((lambda x                  x) 3 4 5 6)}
    pew {((lambda (x y . z) (list x y)) 3 4 5 6)}
    pew {((lambda (x y . z) z) 3 4 5 6)}
} -output "(3 4 5)\n(3 4 5 6)\n(3 4)\n(5 6)\n"


::tcltest::test eval-16.1 {conditional: does internal if accept a #t? Yes, b/c of the ne in condition handling} -body {
    pew "(if (zero? 0) (* 4 4) (- 5 5))"
} -output "16\n"

TT)

# vim: ft=tcl tw=80 ts=2 sw=2 sts=2 et 
