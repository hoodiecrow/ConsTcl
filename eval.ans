
H2 Evaluation

MD(
The second thing an interpreter must be able to do is to reduce expressions to
their E{normal form}, or E{evaluate}I{eval}I{evaluator} them. As an example, 2 +
6 and 8 are two expressions that have the same value, but the latter is in
normal form (can't be reduced further) and the former is not.
MD)

h3 The evaluator

H4 eval procedure

MD(
The heart of the Lisp interpreter, K{eval} takes a Lisp expression and processes
it according to its form. Symbols to the value they R{refer
  to}{variable-reference}, numbers etc to their R{own value}{constant-literal},
  and expressions that are lists to the value that K{eval-form} assigns to them.
MD)

PR(
eval (public);expr expr env env -> val
PR)

CB(
reg eval

proc ::constcl::eval \
  {expr {env ::constcl::global_env}} {
  if {[T [symbol? $expr]]} {
    lookup $expr $env
  } elseif {[T [null? $expr]] ||
    [T [atom? $expr]]} {
    set expr
  } elseif {[T [pair? $expr]]} {
    eval-form $expr $env
  } else {
    error "unknown expression type"
  }
}
CB)

H4 eval-form procedure

MD(
K{eval} also does two kinds of rewriting of expressions: 1) E{macro expansion}
on a non-atomic expression into a more concrete expression. See the part about
R{macros}{macros} below, and 2) resolving E{local defines}, acting on
expressions of the form K{(begin (define ...} when in a local environment. See
the part about R{resolving local defines}{resolving-local-defines}.
MD)

PR(
eval-form (internal);expr expr env env -> val
PR)

CB(
proc ::constcl::eval-form {expr env} {
  set op [car $expr]
  set args [cdr $expr]
  if {[T [symbol? $op]]} {
    set bi [binding-info $op $env]
    lassign $bi bt in
    switch $bt {
      UNBOUND {
        error "unbound symbol" $op
      }
      SPECIAL {
        $in $expr $env
      }
      VARIABLE {
        invoke $in [eval-list $args $env]
      }
      SYNTAX {
        set expr [$in $expr $env]
        eval $expr $env
      }
      default {
        error "unrecognized binding type" $bt
      }
    }
  } else {
    invoke [eval $op $env] [eval-list $args $env]
  }
}
CB)

MD(
B{binding-info} procedure

The K{binding-info} procedure takes a symbol and returns a list of two items: 1)
the binding type of the symbol, and 2) the handling info that K{eval-form} uses to
handle this symbol.
MD)

PR(
binding-info (internal);op sym env env -> bindfo
PR)

CB(
proc ::constcl::binding-info {op env} {
  set actual_env [$env find $op]
  # parentless envs have #NIL
  if {$actual_env ne "::constcl::null_env"} {
    return [$actual_env get $op]
  } else {
    return [::list UNBOUND {}]
  }
}
CB)

h3 Syntactic forms

MD(
There are nine diffent forms or classes of expressions in Lisp:
MD)

EN variable reference
EN constant literal
EN quotation
EN conditional
EN sequence
EN definition
EN assignment
EN procedure definition
EN procedure call

MD(
The evaluator
recognizes each one by its internal representation and chooses the appropriate
process to evaluate them. The nine forms will be described in the following
sections.
MD)

h3 Variable reference

MD(
EM Example: K{r} ==> 10 (a symbol K{r} is evaluated to 10)

A variableI{variable}I{variable reference} is an identifier (symbol) bound to a
location in the environment. If an expression consists of an identifier it is
evaluated to the value stored in that location. This is handled by the helper
procedure K{lookup}. It searches the environment chain for the identifier, and
returns the value stored in the location it is bound to.  It is an error to do
lookup on an unbound symbol.
MD)

H4 lookup procedure

PR(
lookup (internal);sym sym env env -> val
PR)

CB(
proc ::constcl::lookup {sym env} {
  lindex [[$env find $sym] get $sym] 1
}
CB)

TT(
::tcltest::test eval-1.0 {try eval-ing a symbol} -body {
  pew "(let ((r 10)) r)"
} -output "10\n"

::tcltest::test eval-1.2 {try eval-ing an unbound symbol} -body {
  pew "k"
} -returnCodes error -result "Unbound variable: k"
TT)

h3 Constant literal

MD(
EM Example: K{99} ==> 99 (a number evaluates to itself)

Not just numbersI{constant literal} but booleans, characters, strings, and
vectors evaluate to themselves, to their innate value. Because of this, they are
called autoquoting types (see next paragraph).
MD)

TT(
::tcltest::test eval-2.0 {try eval-ing a constant} -body {
  pew "99"
} -output "99\n"
TT)

h3 Quotation

MD(
EM Example: K{(quote r)} ==> K{r} (quotation makes the symbol evaluate to itself, like a constant)

According to the rules of variable reference, a symbol evaluates to its stored
value. Well, sometimes one wishes to use the symbol itself as a value. That is
what quotationI{quotation} is for. K{(quote x)} evaluates to the symbol K{x}
itself and not to any value that might be stored under it. This is so common
that there is a shorthand notation for it: K{'x} is interpreted as K{(quote x)}
by the Lisp reader.
MD)

H4 quote special form

PR(
special-quote (public);expr expr env env -> val
PR)

CB(
regspecial quote

proc ::constcl::special-quote {expr env} {
  return [cadr $expr]
}
CB)

TT(
::tcltest::test eval-3.0 {try eval-ing a quotation} -body {
  pew "'m"
} -output "m\n"

::tcltest::test eval-3.1 {try getting a usage error} -body {
  pew "(quote)"
} -returnCodes error -result "usage error\n(quote datum) not (quote)"

::tcltest::test eval-3.2 {try getting a usage error} -body {
  pew "(quote foo bar)"
} -returnCodes error -result "usage error\n(quote datum) not (quote foo bar)"
TT)

h3 Conditional

MD(
EM Example: K{(if (> 99 100) (* 2 2) (+ 2 4))} ==> 6

The conditionalI{conditional} form K{if} evaluates a Lisp list of three
expressions. The first, the E{condition}, is evaluated first. If it evaluates to
anything other than K{#f} (false), the second expression (the E{consequent}) is
evaluated and the value returned. Otherwise, the third expression (the
E{alternate}) is evaluated and the value returned. One of the two latter
expressions will be evaluated, and the other will remain unevaluated.

H4 if special form

PR(
special-if (public);expr expr env env -> val
PR)

CB(
regspecial if

proc ::constcl::special-if {expr env} {
  set args [cdr $expr]
  if {[T [null? [cddr $args]]]} {
    /if1 {[eval [car $args] $env]} \
      {eval [cadr $args] $env}
  } else {
    /if {[eval [car $args] $env]} \
      {eval [cadr $args] $env} \
      {eval [caddr $args] $env}
  }
}
CB)

MD(
The two procedures that help the if form out are K{/if} and K{/if1}. The
former takes both a consequent and an alternate, the latter takes only a
consequent.

B{/if} procedure
B{/if1} procedure
MD)

PR(
/if (internal);condition expr consequent expr alternate expr -> val
PR)

PR(
/if1 (internal);condition expr consequent expr -> val
PR)

IX /if
IX /if1
CB(
proc ::constcl::/if {cond conseq altern} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  } {
    uplevel $altern
  }
}

proc ::constcl::/if1 {cond conseq} {
  if {[T [uplevel [::list expr $cond]]]} {
    uplevel $conseq
  }
}
CB)

TT(
::tcltest::test eval-4.0 {try eval-ing a conditional} -body {
  pew "(if (= 2 2) (display 'a) (display 'b))"
} -output "a"

::tcltest::test eval-4.0 {try eval-ing a short conditional} -body {
  pew "(if (= 2 3) (display 'a))"
} -output ""
TT)

MD(
Another conditional form is K{case}. It implements a multi-choice where a single
expression selects between alternatives. The body of the K{case} form consists
of a key-expression and a number of clauses. Each clause has a list of values
and a body. If the key-expression evaluates to a value that occurs in one of the
value-lists (considered in order), that clause's body is evaluated and all other
clauses are ignored.

The K{case} form is implemented by K{special-case}, with help from K{do-case}.
It expands to K{'()} if there are
no clauses (left), and to nested K{if} constructs if there are some.
MD)

H5 caar, cadr, cdar, and the rest: an aside

MD(
The K{do-case} procedure uses extensions of the K{car}/K{cdr} operators like K{caar}
and K{cdar}. K{car}/K{cdr} notation gets really powerful when combined to form
operators from K{caar} to K{cddddr}. One can read K{caar L} as `the first element of
the first element of L', implying that the first element of K{L} is a list.
K{cdar L} is `the rest of the elements of the first element of L', and K{cadr L}
is `the first element of the rest of the elements of L' or in layman's terms,
the second element of L.
MD)

H4 case special form

PR(
special-case (internal);expr expr env env -> expr
PR)

CB(
regspecial case

proc ::constcl::special-case {expr env} {
  set tail [cdr $expr]
  set expr [do-case [car $tail] [cdr $tail] $env]
  eval $expr $env
}

proc ::constcl::do-case {keyexpr clauses env} {
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set keyl [caar $clauses]
    set body [cdar $clauses]
    set keyl [list [S memv] $keyexpr \
        [list [S quote] $keyl]]
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the condition
      if {[T [eq? [caar $clauses] [S else]]]} {
        set keyl #t
      }
    }
    set env [Environment new #NIL {} $env]
    /define [S keyl] $keyl $env
    /define [S body] $body $env
    /define [S rest] [
      do-case $keyexpr [cdr $clauses] $env] $env
    set qq "`(if ,keyl
               (begin ,@body)
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
CB)

TT(
::tcltest::test macros-3.0 {expand case macro} -body {
    set x [p "(case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite))"]
    set x [::constcl::do-case [::constcl::cadr $x] [::constcl::cddr $x] ::constcl::global_env]
    w $x
} -output "(if (memv (* 2 3) (quote (2 3 5 7))) (begin (quote prime)) (if (memv (* 2 3) (quote (1 4 6 8 9))) (begin (quote composite)) (quote ())))\n"

::tcltest::test macros-3.1 {run case macro} -body {
    pew "(case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite))"
} -output "composite\n"

::tcltest::test macros-3.2 {expand case macro} -body {
    set x [p "(case (car (quote (c d))) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant))"]
    set x [::constcl::do-case [::constcl::cadr $x] [::constcl::cddr $x] ::constcl::global_env]
    w $x
} -output "(if (memv (car (quote (c d))) (quote (a e i o u))) (begin (quote vowel)) (if (memv (car (quote (c d))) (quote (w y))) (begin (quote semivowel)) (if #t (begin (quote consonant)) (quote ()))))\n"

::tcltest::test macros-3.3 {run case macro} -body {
    pew "(case (car (quote (c d))) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant))"
} -output "consonant\n"
TT)

MD(
The K{cond} form has a list of clauses, each with a predicate and a body. The
clauses is considered in order, and if a predicate evaluates to something other
than K{#f} the body is evaluated and the remaining clauses are ignored.

The K{cond} form is expanded by K{special-cond}. It expands to K{'()} if there are no
clauses (left), and to nested K{if} constructs if there are some.

MD)

H4 cond special form

PR(
special-cond (internal);expr expr env env -> expr
PR)

CB(
regspecial cond

proc ::constcl::special-cond {expr env} {
  set expr [do-cond [cdr $expr] $env]
  eval $expr $env
}
CB)

MD(
B{do-cond} procedure

K{do-cond} is called recursively for every clause of the K{cond} form. It chops
up the clause into predicate and body, stepping over any K{=>} symbols in
between. In the last clause, the predicate is allowed to be K{else} (which gets
translated to K{#t}). If there is no body, the body is set to the predicate. The
form is expanded to a recursive K{if} form.
MD)

PR(
do-cond (internal);tail lexprs env env -> expr
PR)

IX do-cond procedure
CB(
proc ::constcl::do-cond {tail env} {
  set clauses $tail
  if {[T [null? $clauses]]} {
    return [parse "'()"]
  } else {
    set pred [caar $clauses]
    set body [cdar $clauses]
    if {[T [symbol? [car $body]]] &&
        [[car $body] name] eq "=>"} {
      set body [cddar $clauses]
    }
    # if this is the last clause...
    if {[T [eq? [length $clauses] #1]]} {
      # ...allow 'else' in the predicate
      if {[T [eq? $pred [S else]]]} {
        set pred #t
      }
    }
    if {[T [null? $body]]} {
        set body $pred
    }
    set env [Environment new #NIL {} $env]
    /define [S pred] $pred $env
    /define [S body] $body $env
    /define [S rest] [
      do-cond [cdr $clauses] $env] $env
    set qq "`(if ,pred
               (begin ,@body)
               ,rest)"
    set expr [expand-quasiquote [parse $qq] $env]
    $env destroy
    return $expr
  }
}
CB)

TT(
::tcltest::test macros-4.0 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (begin (+ 4 2)) (if (> 1 2) (begin (+ 5 5)) (if #t (begin (- 8 5)) (quote ()))))\n"

::tcltest::test macros-4.1 {run cond macro} -body {
    pew "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)) (else (- 8 5)))"
    pew "(cond ((> 3 4) => (+ 4 2)) ((> 1 2) => (+ 5 5)) (else (- 8 5)))"
} -output "3\n3\n"

::tcltest::test macros-4.2 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (begin (+ 4 2)) (if (> 1 2) (begin (+ 5 5)) (quote ())))\n"

::tcltest::test macros-4.3 {run cond macro} -body {
    pew "(cond ((> 3 4) (+ 4 2)) ((> 1 2) (+ 5 5)))"
} -output "()\n"

::tcltest::test macros-4.4 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) (+ 4 2) (+ 3 5)) ((> 1 2) (+ 5 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (begin (+ 4 2) (+ 3 5)) (if (> 1 2) (begin (+ 5 5)) (quote ())))\n"

::tcltest::test macros-4.5 {expand cond macro} -body {
    set x [p "(cond ((> 3 4) => (+ 4 2) (+ 3 5)) ((> 1 2) => (+ 5 5)))"]
    set x [::constcl::do-cond [::constcl::cdr $x] ::constcl::global_env]
    w $x
} -output "(if (> 3 4) (begin (+ 4 2) (+ 3 5)) (if (> 1 2) (begin (+ 5 5)) (quote ())))\n"

TT)

h3 Sequence

MD(
EM Example: K{(begin (define r 10) (* r r))} ==> 100

When expressions are evaluated in sequenceI{sequence}, the order is important
for two reasons. If the expressions have any side effects, they happen in the
same order of sequence. Also, if expressions are part of a pipeline of
calculations, then they need to be processed in the order of that pipeline.
MD)

H4 begin special form

PR(
special-begin (public);expr expr env env -> val
PR)

CB(
regspecial begin

proc ::constcl::special-begin {expr env} {
  #      TODO
  if {   0 &   $env ne "::constcl::global_env"} {
    set expr [resolve-local-defines $expr]
  }
  set args [cdr $expr]
  /begin $args $env
}
CB)

MD(
B{/begin} procedure

The
K{/begin} helper procedure takes a Lisp list of expressions and evaluates them
in sequence, returning the value of the last one.
MD)

PR(
/begin (internal);exps lexprs env env -> val
PR)

IX /begin
CB(
proc ::constcl::/begin {exps env} {
  /if {[pair? $exps]} {
    /if {[pair? [cdr $exps]]} {
      eval [car $exps] $env
      return [/begin [cdr $exps] $env]
    } {
      return [eval [car $exps] $env]
    }
  } {
    return #NIL
  }
}
CB)

TT(
::tcltest::test eval-5.0 {try eval-ing a sequence} -body {
  pew "(begin (display 'a) (display 'b))"
} -output "ab"
TT)

h3 Definition

MD(
EM Example: K{(define r 10)} ==> ... (a definition doesn't evaluate to anything)

We've already seen the relationship between symbols and values. Through
(variable) definitionI{variable definition}I{definition}, a symbol is bound to a
value (or rather to the location the value is in), creating a variable. The
K{/define} helper procedure adds a variable to the current environment. It first
checks that the symbol name is a valid identifier, then it updates the
environment with the new binding.
MD)

H4 define special form

PR(
special-define (public);expr expr env env -> none
PR)

CB(
regspecial define
proc ::constcl::special-define {expr env} {
  set expr [rewrite-define $expr $env]
  set sym [cadr $expr]
  set val [eval [caddr $expr] $env]
  /define $sym $val $env
}
CB)

MD(
B{rewrite-define} procedure

K{define} has two variants, one of which requires some rewriting. It's the one
with an implied K{lambda} call, the one that defines a procedure. 

(define (E{symbol} E{formals}) E{body})

is transformed by K{rewrite-define} into

(define E{symbol} (lambda E{formals} E{body}))

which conforms better to K{eval}'s standard of (define E{symbol} E{value}).
The other variant passes through K{rewrite-define} unchanged.
MD)

PR(
rewrite-define (internal);expr expr env env -> expr
PR)

IX rewrite-define
CB(
proc ::constcl::rewrite-define {expr env} {
  if {[T [pair? [cadr $expr]]]} {
    set tail [cdr $expr]
    set _env [::constcl::Environment new #NIL {} $env]
    /define [S tail] $tail $_env
    set qq "`(define ,(caar tail)
               (lambda ,(cdar tail) ,@(cdr tail)))"
    set expr [expand-quasiquote [parse $qq] $_env]
    $_env destroy
  } 
  return $expr
}
CB)

TT(
::tcltest::test eval-5.0 {define} -body {
    w [::constcl::rewrite-define [p {(define (foo a b) (+ a b) (* a b))}] ::constcl::global_env]
} -output "(define foo (lambda (a b) (+ a b) (* a b)))\n"

::tcltest::test eval-5.1 {define} -body {
    w [::constcl::rewrite-define [p "(define (fib n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))"] ::constcl::global_env]
} -output "(define fib (lambda (n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))\n"

::tcltest::test eval-5.2 {define} -body {
    w [::constcl::rewrite-define [p "(define (f) (define r 20) (* r r))"] ::constcl::global_env]
} -output "(define f (lambda () (define r 20) (* r r)))\n"

::tcltest::test eval-5.3 {define} -body {
    w [::constcl::rewrite-define [p "(define (list-find-key lst key)\n(lfk lst key 0))"] ::constcl::global_env]
} -output "(define list-find-key (lambda (lst key) (lfk lst key 0)))\n"

TT)

MD(
B{/define} procedure
MD)

PR(
/define (internal);sym sym val val env env -> none
PR)

IX /define
CB(
proc ::constcl::/define {sym val env} {
  varcheck [idcheck [$sym name]]
  $env bind $sym VARIABLE $val
  return
}
CB)

TT(
::tcltest::test eval-6.0 {try eval-ing a define} -body {
  pew "(define r 10)"
  pew "r"
} -output "10\n"

::tcltest::test eval-6.1 {try eval-ing a define, with an inappropriate symbol} -body {
  pew "(define let 10)"
} -returnCodes error -result "Variable name is reserved: let"

::tcltest::test eval-6.2 {try eval-ing a define, with an inappropriate symbol} -body {
  pew "(define +foo 10)"
} -returnCodes error -result "Identifier expected (+foo)"
TT)

h3 Assignment

MD(
EM Example: K{(set! r 20)} ==> 20 (K{r} is a bound symbol, so it's allowed to assign to it)

Once a variable has been created, the value at the location it is bound to can
be changed (hence the name `variable', something that can vary). The
process is called assignment. The K{/set!} helper does assignment:
it modifies an existing variable that is bound somewhere in the environment
chain. It finds the variable's environment and updates the binding. It returns
the value, so calls to K{set!} can be chained: K{(set! foo (set! bar 99))} sets
both variables to 99. By Scheme convention, procedures that modify variables
have `!' at the end of their name.
MD)

H4 set"! special form

PR(
special-set! (public);expr expr env env -> val
PR)

CB(
regspecial set!

proc ::constcl::special-set! {expr env} {
  set args [cdr $expr]
  set var [car $args]
  set val [eval [cadr $args] $env]
  [$env find $var] assign $var VARIABLE $val
  set val
}
CB)

TT(
::tcltest::test eval-7.0 {try eval-ing an assignment} -body {
  unbind [S r]
  pew "(define r 10)"
  pew "(set! r 20)"
  pew "r"
} -output "20\n20\n"
TT)

h3 Procedure definition

MD(
EM Example: K{(lambda (r) (* r r))} ==> K{::oo::Obj3601} (it will be a different object each time)

In Lisp, procedures are values just like numbers or characters. They can be
definedI{procedure definition} as the value of a symbol, passed to other
procedures, and returned from procedures. One diffence from most values is that
procedures need to be defined.  Two questions must answered: what is the
procedure meant to do? The code that does that will form the body of the
procedure. Also, what, if any, items of data will have to be provided to the
procedure to make it possible to calculate its result?

As an example, imagine that we want to have a procedure that calculates the
square (K{x * x}) of a given number. In Lisp, expressions are written with
the operator first and then the operandsI{operator operand order}: K{(* x x)}.
That is the body of the procedure. Now, what data will we have to provide to the
procedure to make it work? A value stored in the variable K{x} will do. It's
only a single variable, but by custom we need to put it in a list: K{(x)}. The
operator that defines procedures is called K{lambda}I{lambda}, and we define the
function with K{(lambda (x) (* x x))}.

One more step is needed before we can use the procedure. It must have a name. We
could define it like this: K{(define square (lambda (x) (* x x)))} but there is
actually a shortcut notation for it: K{(define (square x) (* x x))}.

Now, K{square} is pretty tame. How about the K{hypotenuse} procedure? K{(define
  (hypotenuse a b) (sqrt (+ (square a) (square b))))}. It calculates the square
  root of the sum of two squares.

The lambda special form makes a R{Procedure}{control} object. First
it needs to convert the Lisp list K{body}. It is packed inside a K{begin} if it
has more than one expression (K{S begin} stands for `the symbol begin'.), and
taken out of its list if not. The Lisp list K{formals} is passed on as it is.

H5 Scheme formals lists: an aside

A Scheme formals listI{formals list} is either:

IT An E{empty list}, K{()}, meaning that no arguments are accepted,
IT A E{proper list}, K{(a b c)}, meaning it accepts three arguments, one in each symbol,
IT A E{symbol}, K{a}, meaning that all arguments go into K{a}, or
IT A E{dotted list}, K{(a b . c)}, meaning that two arguments go into K{a} and K{b}, and the rest into K{c}.
MD)

H4 lambda special form

PR(
special-lambda (public);expr expr env env -> proc
PR)

CB(
regspecial lambda

proc ::constcl::special-lambda {expr env} {
  set args [cdr $expr]
  set formals [car $args]
  set body [cdr $args]
  if {[[length $body] numval] > 1} {
    set body [cons [S begin] $body]
  } else {
    set body [car $body]
  }
  return [MkProcedure $formals $body $env]
}
CB)

TT(
::tcltest::test eval-8.0 {try eval-ing a procedure definition} -body {
  pew "(define (square x) (* x x))"
  pew "(square 20)"
} -output "400\n"
TT)

h3 Procedure call

MD(
EM Example: K{(+ 1 6)} ==> 7

Once we have procedures, we can callI{procedure call} them to have their
calculations performed and yield results. The procedure name is put in the
operator position at the front of a list, and the operands follow in the rest of
the list. Our K{square} procedure would be called for instance like this:
K{(square 11)}, and it will return 121.

K{invoke} arranges for a procedure to be called with each of the values in
the E{argument list} (the list of operands). It checks if E{pr} really is a
procedure, and determines whether to call E{pr} as an object or as a Tcl command.
MD)

H4 invoke procedure

PR(
invoke (internal);pr proc vals lvals -> invoke
PR)

CB(
proc ::constcl::invoke {pr vals} {
  check {procedure? $pr} {
    PROCEDURE expected\n([$pr show] val ...)
  }
  if {[info object isa object $pr]} {
    $pr call {*}[splitlist $vals]
  } else {
    $pr {*}[splitlist $vals]
  }
}
CB)

TT(
::tcltest::test eval-9.0 {try eval-ing a procedure call} -body {
  pew "(* 5 20)"
} -output "100\n"

::tcltest::test eval-9.1 {try triggering a check} -body {
    ::constcl::invoke #NIL [list #NIL #NIL]
} -returnCodes error -result "PROCEDURE expected\n(() val ...)"
TT)

MD(
B{splitlist} procedure

K{splitlist} converts a Lisp list to a Tcl list with Lisp objects.
MD)

PR(
splitlist (internal);vals lvals -> tvals
PR)

IX splitlist
CB(
proc ::constcl::splitlist {vals} {
  set result {}
  while {[T [pair? $vals]]} {
    lappend result [car $vals]
    set vals [cdr $vals]
  }
  return $result
}
CB)

MD(
B{eval-list} procedure

K{eval-list} successively evaluates the elements of a Lisp list and returns the
collected results as a Lisp list.
MD)

PR(
eval-list (internal);exps lexprs env env -> lvals
PR)

IX eval-list
CB(
proc ::constcl::eval-list {exps env} {
  # don't convert to /if, it breaks (fact 100)
  if {[T [pair? $exps]]} {
    return [cons [eval [car $exps] $env] \
      [eval-list [cdr $exps] $env]]
  } {
    return #NIL
  }
}
CB)

TT(

::tcltest::test eval-10.0 {lambda parameter lists} -body {
    pew {((lambda (x y z) (list x y z)) 3 4 5)}
    pew {((lambda x                  x) 3 4 5 6)}
    pew {((lambda (x y . z) (list x y)) 3 4 5 6)}
    pew {((lambda (x y . z) z) 3 4 5 6)}
} -output "(3 4 5)\n(3 4 5 6)\n(3 4)\n(5 6)\n"


::tcltest::test eval-10.1 {conditional: does internal if accept a #t? Yes, b/c of the ne in condition handling} -body {
    pew "(if (zero? 0) (* 4 4) (- 5 5))"
} -output "16\n"

TT)

CB
proc ::constcl::scheme-report-environment {version} {
    # TODO
}
CB

CB
proc ::constcl::null-environment {version} {
    # TODO
}
CB

CB
proc ::constcl::interaction-environment {} {
    # TODO
}
CB

# vim: ft=tcl tw=80 ts=2 sw=2 sts=2 et 
